

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="黄山">
  <meta name="keywords" content="C/C++,Python,C#,Go,Web,AI,游戏开发,网络安全">
  
    <meta name="description" content="一、最长公共子序列 在生物应用中，经常需要比较两个(或多个)不同生物体的 DNA。一个 DNA 串由一串称为碱基(base)的分子组成，碱基有腺嘌呤、鸟嘌呤、胞嘧啶和胸腺嘧啶 4 种类型。我们用英文单词首字母表示 4 种碱基，这样就可以将一个 DNA 串表示为有限集{A,C,G,T}上的一个字符串(参见附录 C 中对字符串的定义)。例如，某种生物的 DNA 可能为$S_{\mathrm{i}}&#x3D;$">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法分析：专题内容——动态规划2之例题讲解（代码详解+万字长文+算法导论+力扣题）">
<meta property="og:url" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89/">
<meta property="og:site_name" content="钺不言">
<meta property="og:description" content="一、最长公共子序列 在生物应用中，经常需要比较两个(或多个)不同生物体的 DNA。一个 DNA 串由一串称为碱基(base)的分子组成，碱基有腺嘌呤、鸟嘌呤、胞嘧啶和胸腺嘧啶 4 种类型。我们用英文单词首字母表示 4 种碱基，这样就可以将一个 DNA 串表示为有限集{A,C,G,T}上的一个字符串(参见附录 C 中对字符串的定义)。例如，某种生物的 DNA 可能为$S_{\mathrm{i}}&#x3D;$">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5Ce552e039834d48b1b466105cf181d6cd.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5Ca60986accab8408b95d849b421e8025f.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5Cbff517c65bc843688baf8c6870c1196b.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5C5409cc26f4b045879a1a5a7fdafe326c.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5C20a4dce830734efd87c510534082b9e2.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5C83c2ec99951840ebb911a615ef81c985.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5C70248a9a0640419a970c13117803a077.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5Cc61c15f4fb984a24bf0647c8b1080c6a.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5C18666736f6564d50bea38d3e08a6b2d3.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5Cabb24aff87fd40dbb2d0082876ffdd73.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5Cbe9d67c0137940a7a89f975e479dfe8b.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5Cc77c8b990d7a4b629da4a330dda4fe40.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5Cd7e03a69211f4d9aae9844312fe02ffc.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5Cdf104cc570584be081462e408e2e19dc.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5C2b447e87799c4c82aa5397f93f9a7f4e.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5C4a0764721d984343817fb18a3af8106e.png">
<meta property="article:published_time" content="2025-03-18T18:19:05.000Z">
<meta property="article:modified_time" content="2025-03-18T18:19:05.850Z">
<meta property="article:author" content="黄山">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="Web">
<meta property="article:tag" content="AI">
<meta property="article:tag" content="游戏开发">
<meta property="article:tag" content="网络安全">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5Ce552e039834d48b1b466105cf181d6cd.png">
  
  
  
  <title>数据结构与算法分析：专题内容——动态规划2之例题讲解（代码详解+万字长文+算法导论+力扣题） - 钺不言</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"mounthuangshan.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="数据结构与算法分析：专题内容——动态规划2之例题讲解（代码详解+万字长文+算法导论+力扣题）"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-03-19 02:19" pubdate>
          2025年3月19日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          18k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          148 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">数据结构与算法分析：专题内容——动态规划2之例题讲解（代码详解+万字长文+算法导论+力扣题）</h1>
            
            
              <div class="markdown-body">
                
                <h1>一、最长公共子序列</h1>
<p>在生物应用中，经常需要比较两个(或多个)不同生物体的 DNA。一个 DNA 串由一串称为碱基(base)的分子组成，碱基有腺嘌呤、鸟嘌呤、胞嘧啶和胸腺嘧啶 4 种类型。我们用英文单词首字母表示 4 种碱基，这样就可以将一个 DNA 串表示为有限集{A,C,G,T}上的一个字符串(参见附录 C 中对字符串的定义)。例如，某种生物的 DNA 可能为$S_{\mathrm{i}}=$ACCGGTOGAGTGCGGGAGCGGGGGGGGGGGGGGGGG 另一种生物的 DNA 可能为$S_2=GTCGTTCGGAATGCCGTTGCTCTGTAAA$。我们比较两个DNA串的一个原因是希望确定它们的“相似度”,作为度量两种生物相近程度的指标。我们可以用很多不同的方式来定义相似度，实际上也确实已经出现了很多相似度的定义。例如，如果一个DNA 串是另一个 DNA 串的子串，那么可以说它们是相似的(第 32 章讨论了如何求解此问题)。但在我们的例子中，S_1 和 S_2 都不是对方的子串。我们还可以这样来定义相似性：如果将一个串转换为另一个串所需的操作很少，那么可以说两个串是相似的(思考题 15-5 讨论了此概念)。另一种衡量串$S_1$和$S_2$的相似度的方式是：寻找第三个串$S_3$,它的所有碱基也都出现在$S_1$和$S_2$中，且在三个串中出现的顺序都相同，但在$S_1$和$S_2$中不要求连续出现。可以找到的$S_{3}$越长，就可以认为 Si 和$S_{2}$的相似度越高。在我们的例子中，最长的$S_{3}$为 GTCGTCGGAAGCGGGCGAA。<br>
我们将最后一种相似度的概念命名为最长公共子序列问题。一个给定序列的子序列，就是将给定序列中零个或多个元素去掉之后得到的结果。其形式化定义如下：给定一个序列$X=\langle x_1,x_2,\cdots$, $x_m$〉,另一个序列$Z=\langle z_1,z_2,…,z_k\rangle$满足如下条件时称为$X$的子序列(subsequence),即存在一个严格递增的$X$的下标序列$\langle i_1,i_2,…,i_k\rangle$,对所有$j=1,2,…,k$,满足$x_i_j=z_j$。例如，$Z=\langle B$,$C,D,B\rangle 是X=\langle A,B,C,B,D,A,B\rangle$的子序列，对应的下标序列为(2,3,5,7)。<br>
给定两个序列$X$和$Y$,如果$Z$既是$X$的子序列，也是$Y$的子序列，我们称它是$X$和 Y 的公共子序列(common subsequence)。例如，如果$X=\langle A,B,C,B,D,A,B\rangle,Y=\langle B,D,C$, $A,B,A\rangle,那么序列\langle B,C,A\rangle$就是$X$ 和$Y$ 的公共子序列。但它不是 $X$ 和$Y$ 的最长公共子序列(LCS),因为它长度为 3,而〈$B,C,B,A$〉也是 $X$ 和$Y$的公共子序列，其长度为 4。〈B,C, $B,A\rangle$是 $X$ 和$Y$的最长公共子序列，$\langle B,D,A,B\rangle$也是，因为$X$ 和$Y$不存在长度大于等于 5的公共子序列。<br>
最长公共子序列问题(longest-common-subsequence problem)给定两个序列$X=\langle x_1,x_2,\cdots$, $x_m$&gt;和$Y=\langle y_1,y_2,\cdots,y_n\rangle$,求$X$和$Y$长度最长的公共子序列。本节将展示如何用动态规划方法高效地求解 LCS 问题。</p>
<p><strong>步骤 1: 刻画最长公共子序列的特征</strong><br>
如果用暴力搜索方法求解 LCS问题，就要穷举 X 的所有子序列，对每个子序列检查它是否也是$Y$的子序列，记录找到的最长子序列。$X$的每个子序列对应$X$的下标集合$\langle1,2,\cdots,m\rangle$的一个子集，所以 $X$ 有 2” 个子序列，因此暴力方法的运行时间为指数阶，对较长的序列是不实用的。<br>
但是，如下面的定理所示，LCS 问题具有最优子结构性质。我们将看到，子问题的自然分类对应两个输人序列的“前缀”对。前缀的严谨定义如下：给定一个序列$X=\langle x_1,x_2,\ldots,x_m\rangle$, 对$i=0,1,…,m$,定义$X$的第$i$前缀为$X_i=\langle x_1,x_2,…,x_i\rangle$。例如，若$X=\langle A,B,C,B$, $D$, $A$, $B\rangle$, 则 $X_{4}= \langle A$, $B$, $C$, $B\rangle$, $X_{0}$ 为空串。<br>
定理 15.1(LCS 的最优子结构)令$X=\langle x_1,x_2,\cdots,x_m\rangle$和$Y=\langle y_1,y_2,\cdots,y_n\rangle$为两个序<br>
列，$Z= \langle z_1$, $z_2$, $\cdots$, $z_k\rangle$为 $X$和Y的任意 LCS。<br>
1.如果 $x_m=y_n$, 则 $z_k=x_m=y_n$ 且$Z_k-1$是$X_m-1$和$Y_n-1$的一个LCS。<br>
2.如果 $x_m\neq y_n$, 那么 $z_k\neq x_m$ 意味着$Z$ 是$X_m-1$和$Y$的一个LCS。<br>
3.如果 $x_m\neq y_n$, 那么 $z_k\neq y_n$ 意味着$Z$ 是$X$ 和$Y_n-1$的一个 LCS。<br>
证明 ：<br>
(1)如果$z_k\neq x_m$,那么可以将$x_m=y_n$追加到$Z$的末尾，得到$X$和$Y$的一个长度为$k+1$的公共子序列，与$Z$是$X$ 和$Y$ 的最长公共子序列的假设矛盾。因此，必然有 $z_k=x_m=y_n$。这样，前缀 $Z_{k-1}$是 $X_{m-1}$ 和$Y_{n-1}$的一个长度为 $k-1$ 的公共子序列。我们希望证明它是一个 LCS。利用反证法，假设存在 $X_{m-1}$和$Y_{n-1}$的一个长度大于 $k-1$ 的公共子序列 $W$,则将 $x_m=y_n$ 追加到$W$的末尾会得到$X$和$Y$的一个长度大于$k$的公共子序列，矛盾。<br>
(2)如果 $z_k\neq x_m$,那么 $Z$ 是$X_m-1$和$Y$ 的一个公共子序列。如果存在 $X_m-1$和$Y$ 的一个长度大于$k$ 的公共子序列$W$,那么$W$也是$X_m$ 和$Y$的公共子序列，与$Z$ 是$X$ 和$Y$的最长公共子序列的假设矛盾。<br>
(3)与情况(2)对称。<br>
定理 15.1 告诉我们，两个序列的 LCS 包含两个序列的前缀的 LCS。因此，LCS 问题具有最<br>
优子结构性质。我们马上还会看到，其递归算法也具有重叠子问题性质。</p>
<p><strong>步骤2：一个递归解</strong><br>
定理 15. 1 意味着，在求 $X=\langle x_1,x_2,\cdotp\cdotp\cdotp,x_m\rangle$和 $Y=\langle y_1,y_2,\cdotp\cdotp\cdotp,y_n\rangle$的一个 LCS 时，我们需要求解一个或两个子问题。如果 $x_m=y_n$,我们应该求解 $X_{m-1}$和$Y_{n-1}$的一个 LCS。将 $x_m=y_\pi$ 追加到这个 LCS 的末尾，就得到 $X$ 和$Y$的一个 LCS。如果 $x_m\neq y_n$,我们必须求解两个子问题： 求$X_{m-1}$和Y的一个LCS与$X$ 和$Y_{n-1}$的一个LCS。两个 LCS 较长者即为 $X$ 和$Y$ 的一个 LCS。由于这些情况覆盖了所有可能性，因此我们知道必然有一个子问题的最优解出现在$X$和 Y 的$LCS中$。<br>
我们可以很容易看出 LCS 问题的重叠子问题性质。为了求$X$和$Y$的一个 LCS,我们可能需要求 $X$ 和$Y_{n-1}$的一个 LCS 及 $X_{m-1}$和$Y$的一个 ICS。但是这几个子问题都包含求解 $X_{m-1}$和$Y_{n-1}$ 的 LCS 的子子问题。很多其他子问题也都共享子子问题。<br>
与矩阵链乘法问题相似，设计 LCS 问题的递归算法首先要建立最优解的递归式。我们定义$c[i,j]$表示$X_i$和$Y_j$的 LCS 的长度。如果$i=0$或$j=0$,即一个序列长度为 0,那么 ICS 的长度为0。根据 LCS问题的最优子结构性质，可得如下公式：<br>
若$i=0$或$j=0$<br>
$c[i,j]=\begin{cases}0&amp;\text{若 }i=0\text{ 或 }j=0\c[i-1,j-1]+1&amp;\text{若 }i,j&gt;0\text{ 且 }x_{i}=y_{j}\\max(c[i,j-1],c[i-1,j])&amp;\text{若 }i,j&gt;0\text{ 且 }x_{i}\neq y_{j}\end{cases}$<br>
(15.9)<br>
观察到在递归公式中，我们通过限制条件限定了需要求解哪些子问题。当$x_i=y_j$时，我们可以而且应该求解子问题：$X_{i-1}$和$Y_{j-1}$的一个 LCS。否则，应该求解两个子问题：$X_i$ 和$Y_{j-1}$的一个 LCS 及 $X_{i-1}$和$Y_j$ 的一个 LCS。在之前讨论过的钢条切割问题和矩阵链乘法问题的动态规划算法中，根据问题的条件，我们没有排除任何子问题。不过，LCS 问题并非唯一根据条件排除子问题的动态规划算法。例如，编辑距离问题(见思考题 15-5)也具有这种特点。</p>
<p><strong>步骤 3: 计算 LCS 的长度</strong><br>
根据公式(15.9),我们可以很容易地写出一个指数时间的递归算法来计算两个序列的 LCS 的长度。但是，由于 LCS 问题只有 $\Theta(mn)$个不同的子问题，我们可以用动态规划方法自底向上地计算。<br>
过程 LCS LENGTH 接受两个序列$X=\langle x_1,x_2,\cdots,x_m\rangle$和$Y=\langle y_1,y_2,\cdots,y_n\rangle$为输入。它将 $c[i,j]$的值保存在表 $c[0\ldots m,0…n]$中，并按行主次序(row-major order)计算表项(即首先由左至右计算 c 的第一行，然后计算第二行，依此类推)。过程还维护一个表$b[1…m,1…n]$, 帮助构造最优解。$b[i,j]$指向的表项对应计算 c$[i,j]$时所选择的子问题最优解。过程返回表 $b$<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5Ce552e039834d48b1b466105cf181d6cd.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
图15-8显示了LCS-LENGTH对输入序列X=&lt;A,B,C,D,A,B&gt;和Y=&lt;B,.D,C,A,B,A&gt;生成的结果。过程的运行时间为 $\Theta(mn)$，因为每个表项的计算时间为 $\Theta(1)$。<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5Ca60986accab8408b95d849b421e8025f.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
<strong>步骤4：构造LCS</strong><br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5Cbff517c65bc843688baf8c6870c1196b.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
<strong>算法改进</strong><br>
一旦设计出一个算法，通常情况下你都会发现它在时空开销上有改进的余地。一些改进可以简化代码，将性能提高常数倍，但除此之外不会产生性能方面的渐近性提升。而另一些改进可以带来时空上巨大的渐近性提升。<br>
例如，对 ICS算法，我们完全可以去掉表$b$。每个 c[$i,j]$项只依赖于表$c$中的其他三项： $c[i-1,j]$、$c[i,j-1]$和 $c[i-1,j-1]$。给定 $c[i,j]$的值，我们可以在 O(1)时间内判断出在计算 $c[i,j]$时使用了这三项中的哪一项。因此，我们可以用一个类似 PRINT-LCS 的过程在$O(m+n)$时间内完成重构 LCS 的工作，而且不必使用表 $b$。但是，虽然这种方法节省了$\Theta(mn)$的空间，但计算 LCS 所需的辅助空间并未渐近减少，因为无论如何表$c$都需要$\Theta(mn)$的空间。<br>
不过，LCS-LENGTH 的空间需求是可以渐近减少的，因为在任何时刻它只需要表$c$中的两行：当前正在计算的一行和前一行。如果我们只需计算 LCS 的长度，这一改进是有效的。但如果需要重构 LCS 中的元素，这么小的表空间所保存的信息不足以在 $O(m+n)$时间内完成重构工作。</p>
<h1>二、最优二叉搜索树</h1>
<p>假定我们正在设计一个程序，实现英语文本到法语的翻译。对英语文本中出现的每个单词， 我们需要查找对应的法语单词。为了实现这些查找操作，我们可以创建一棵二叉搜索树，将 $n$个英语单词作为关键字，对应的法语单词作为关联数据。由于对文本中的每个单词都要进行搜索， 我们希望花费在搜索上的总时间尽量少。通过使用红黑树或其他平衡搜索树结构，我们可以假定每次搜索时间为$O(\lg n)$。但是，单词出现的频率是不同的，像“the”这种频繁使用的单词有可能位于搜索树中远离根的位置上，而像“machicolation”这种很少使用的单词可能位于靠近根的置上。这样的结构会减慢翻译的速度，因为在二叉树搜索树中搜索一个关键字需要访问的结点数等于包含关键字的结点的深度加 1。我们希望文本中频繁出现的单词被置于靠近根的位置$^{\ominus}$。而且，文本中的一些单词可能没有对应的法语单词$^{\textcircled{5}}$,这些单词根本不应该出现在二叉搜索树中。在给定单词出现频率的前提下，我们应该如何组织一棵二叉搜索树，使得所有搜索操作访问的结点总数最少呢？<br>
这个问题称为最优二叉搜索树(optimal binary search tree)问题。其形式化定义如下：给定一个$n$个不同关键字的已排序的序列$K=\langle k_1,k_2,…,k_n\rangle($因此$k_1&lt;k_2&lt;…&lt;k_n)$,我们希望用这些关键字构造一棵二叉搜索树。对每个关键字$k_i$,都有一个概率$p_i$表示其搜索频率。有些要搜索的值可能不在$K$中，因此我们还有$n+ 1$ 个 “ 伪 关 键 字 ” $d_0, d_1, d_2, . . . , d_n$表示不在$K$中的值。$d_0$表示所有小于$k_1$的值，$d_n$表示所有大于$k_n$的值，对$i=1,2,…,n-1$,伪关键字$d_i$表示所有在$k_\mathrm{i}$ 和$k_{i+1}$之间的值。对每个伪关键字 $d_i$,也都有一个概率 $p_i$ 表示对应的搜索频率。图 15-9显示了对一个$n=5$个关键字的集合构造的两棵二叉搜索树。每个关键字$k_i$是一个内部结点，而每个伪关键字$d_i$是一个叶结点。每次搜索要么成功(找到某个关键字$k_i)$要么失败(找到某个伪关键字$d_i$),因此有如下公式$$:\\sum_{i=1}^np_i+\sum_{i=0}^nq_i=1$$<br>
(15.10)<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5C5409cc26f4b045879a1a5a7fdafe326c.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
由于我们知道每个关键字和伪关键字的搜索概率,因而可以确定在一棵给定的二叉搜索树T中进行一次搜索的期望代价。假定一次搜索的代价等于访问的结点数,即此次搜索找到的结点在T中的深度再加1。那么在T中进行一次搜索的期望代价为:<br>
$$\begin{aligned}<br>
\text{E[T中搜索代价]}&amp; =\sum_{i=1}^{n}(\mathrm{depth}<em>{T}(k</em>{i})+1)\bullet p_{i}+\sum_{i=0}^{n}(\mathrm{depth}<em>{T}(d</em>{i})+1)\bullet q_{i} \<br>
&amp;=1+\sum_{i=1}^{n}\mathrm{depth}<em>{T}(k</em>{i})\bullet p_{i}+\sum_{i=0}^{n}\mathrm{depth}<em>{T}(d</em>{i})\bullet q_{i}<br>
\end{aligned}$$<br>
其中$depth_r$表示一个结点在树T中的深度。最后一个等式是由公式(15.10)推导而来。在图15-9(a)中,我们逐个结点期望搜索代价：<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5C20a4dce830734efd87c510534082b9e2.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
对于一个给定的概率集合,我们希望构造一棵期望搜索代价最小的二叉搜索树,我们称之为最优二叉搜索树。图15-9(b)所示的二叉搜索树就是给定概率集合的最优二叉搜索树,其期望代价为2.75。这个例子显示,最优二叉搜索树不一定是高度最矮的。而且,概率最高的关键字也不一定出现在二叉搜索树的根结点。在此例中，关键字$k_{5}$的搜索概率最高但最优二叉搜索树的根结点为$k_{2}$(在所有以$k_{5}$为根的二叉搜索树中，期望搜索代价最小者为2.85)。<br>
与矩阵链乘法问题相似，对本问题来说，穷举并检查所有可能的二叉搜索树不是一个高效的算法。对任意一棵$n$个结点的二叉树，我们都可以通过对结点标记关键字$k_1,k_2,…,k_n$构造出一棵二叉搜索树，然后向其中添加伪关键字作为叶结点。在思考题 12-4 中，我们会看到$n$个结点的二叉树的数量为$\Omega(4^n/n^{3/2})$,因此穷举法需要检查指数棵二叉搜索树。不出意外，我们将使用动态规划方法求解此问题。</p>
<p><strong>步骤 1:最优二叉搜索树的结构</strong><br>
为了刻画最优二叉搜索树的结构，我们从观察子树特征开始。考虑一棵二叉搜索树的任意子树。它必须包含连续关键字$k_i,\ldots,k_j,1\leqslant i\leqslant j\leqslant n$,而且其叶结点必然是伪关键字$d_i-1,\ldots,d_j$。<br>
我们现在可以给出二叉搜索树问题的最优子结构：如果一棵最优二叉搜索树$T$有一棵包含关键字$k_i,\cdots,k_j$ 的子树$T^\prime$, 那 么 $T^{\prime }$必然是包含关键字 $k_i,\cdots,k_j$ 和伪关键字$d_i-1,\cdots,d_j$ 的子问题的最优解。我们依旧用剪切一粘贴法来证明这一结论。如果存在子树$T^{\prime\prime}$,其期望搜索代价比 $T^{\prime}$低，那么我们将 $T^{\prime}$从 $T$ 中删除，将 $T^{\prime\prime}$粘贴到相应位置，从而得到一棵期望搜索代价低于$T$的二叉搜索树，与$T$最优的假设矛盾。<br>
我们需要利用最优子结构性质来证明，我们可以用子问题的最优解构造原问题的最优解。给定关键字序列$k_i,\cdots,k_j$,其中某个关键字，比如说$k,(i\leqslant r\leqslant j)$,是这些关键字的最优子树的根结点。那么$k$,的左子树就包含关键字$k_i,…,k_{r-1}($和伪关键字$d_i-1,…,d_{r-1})$,而右子树包含关键字$k_{r+1},\cdots,k_{j}($和伪关键字$d_r,\cdots,d_j)$。只要我们检查所有可能的根结点 $k_r(i\leqslant r\leqslant j)$, 并对每种情况分别求解包含$k_i,…,k_{r-1}$及包含$k_r+1,…,k_j$ 的最优二叉搜索树，即可保证找到原问题的最优解。<br>
这里还有一个值得注意的细节——“空子树”。假定对于包含关键字$k_i,…,k_j$ 的子问题，我们选定$k_i$为根结点。根据前文论证，$k_i$的左子树包含关键字$k_i,…,k_{i-1}$。我们将此序列解释为不包含任何关键字。但请注意，子树仍然包含伪关键字。按照惯例，我们认为包含关键字序列$k_i,\cdots,k_{i-1}$的子树不含任何实际关键字，但包含单一伪关键字$d_{i-1}$。对称地，如果选择$k_j$为根结点，那么$k_j$ 的右子树包含关键字$k_{j+1},\cdots,k_j$——此右子树不包含任何实际关键字，但包含伪关键字$d_j.$</p>
<p><strong>步骤2：一个递归算法</strong><br>
我们已经准备好给出最优解值的递归定义。我们选取子问题域为：求解包含关键字$k_i,\cdots$, $k_j$ 的最优二叉搜索树，其中$i\geqslant 1, j\leqslant n$且 $j\geqslant i- 1($当$j=i-1$ 时，子树不包含实际关键字，只包含伪关键字$d_i-1$)。定义$e[i,j]$为在包含关键字$k_i,\cdots,k_j$的最优二叉搜索树中进行一次搜索的期望代价。最终，我们希望计算出$e[1,n]$。<br>
$j=i-1$的情况最为简单，由于子树只包含伪关键字$d_{i-1}$,期望搜索代价为$e[i,i-1]=q_{i-1}$。当$j\geqslant i$ 时，我们需要从$k_i,\cdots,k_j$ 中选择一个根结点$k_r$,然后构造一棵包含关键字$k_i,\cdots$,<br>
$k_{r-1}$的最优二叉搜索树作为其左子树，以及一棵包含关键字 $k_{r+1},\cdots,k_j$ 的二叉搜索树作为其右子树。当一棵子树成为一个结点的子树时，期望搜索代价有何变化？由于每个结点的深度都增加了1，根据公式(15.11),这棵子树的期望搜索代价的增加值应为所有概率之和。对于包含关键字$k_i,\cdots,k_j$的子树，所有概率之和为<br>
$$w(i,j)=\sum_{l=i}^jp_l+\sum_{l=i-1}^jq_l$$<br>
(15.12)<br>
因此，若点$_r$为包含关键字$k_i,…,k_j$ 的最优二叉搜索树的根结点，我们有如下公式：<br>
$e[i,j]=p_r+(e[i,r-1]+w(i,r-1))+(e[r+1,j]+w(r+1,j))$<br>
注意</p>
<p>$$w(i,j)=w(i,r-1)+p_r+w(r+1,j)$$</p>
<p>因此 $e[i,j]$可重写为</p>
<p>(15.13)</p>
<p>$$e[i,j]=e[i,r-1]+e[r+1,j]+w(i,j)$$<br>
递归公式(15.13)假定我们知道哪个结点$k$应该作为根结点。如果选取期望搜索代价最低者<br>
作为根结点，可得最终递归公式：<br>
$$\begin{aligned}&amp;\text{1}\&amp;e[i,j]=\begin{cases}q_{i-1}&amp;\text{若 }j=i-1\\min_{n\leqslant n\leqslant j}{e[i,r-1]+e[r+1,j]+w(i,j)}&amp;\text{若 }i\leqslant j\end{cases}\end{aligned}$$</p>
<p>(15.14)</p>
<p>$e[i,j]$的值给出了最优二叉搜索树的期望搜索代价。为了记录最优二叉搜索树的结构，对于包含关键字$k_i,…,k_j(1\leqslant i\leqslant j\leqslant n)$的最优二叉搜索树，我们定义 $root[i,j]$保存根结点 k,的下标$r$。虽然我们将看到如何计算 $root[i,j]$的值，但是利用这些值来构造最优二叉搜索树的问题将留作练习(练习15.5-1)。</p>
<p><strong>步骤 3: 计算最优二叉搜索树的期望搜索代价</strong><br>
现在，你可能已经注意到我们求解最优二叉搜索树和矩阵链乘法的一些相似之处。它们的子问题都由连续的下标子域组成。而公式(15.14)的直接递归实现，也会与矩阵链乘法问题的直接递归算法一样低效。因此，我们设计替代的高效算法，我们用一个表 $e[1\ldots n+1,0\ldots n]$来保存$e[i,j]$值。第一维下标上界为$n+1$而不是$n$,原因在于对于只包含伪关键字$d_n$的子树，我们需要计算并保存 e[$n+1,n]$。第二维下标下界为 0,是因为对于只包含伪关键字$d_{\mathrm{o}}$的子树，我们需要计算并保存$e[1,0]$。我们只使用表中满足$j\geqslant i-1$的表项$e[i,j]$。我们还使用一个表$root$,表项$root[i,j]$记录包含关键字$k_i,…,k_j$的子树的根。我们只使用此表中满足 1$\leqslant i\leqslant j\leqslant n$ 的表项$root[i,j]$。<br>
我们还需要另一个表来提高计算效率。为了避免每次计算$e[i,j]$时都重新计算 $w(i,j)$,我们将这些值保存在表 $w[1\ldots n+1,0\ldots n]$中，这样每次可节省 $\Theta(j-i)$次加法。对基本情况，令$w[ i$, $i- 1] = q_{i- 1}( 1\leqslant i\leqslant n+ 1) 。对$ $j\geqslant i$的情况，可如下计算：<br>
$$w[i,j]=w[i,j-1]+p_j+q_j$$<br>
(15.15)<br>
这样，对$\Theta(n^{2})$个$w[i,j]$,每个的计算时间为$\Theta(1)$。<br>
下面的伪代码接受概率列表$p_1,\ldots,p_n$和$q_0,\ldots,q_n$及规模$n$作为输人，返回表$e$和root 。</p>
<p>OPTIMAL-BST( $p,q,n)$<br>
1 let $e[1…n+1,0…n],w[1…n+1,0…n]$,and $root[1…n,1…n]$be new tables<br>
2 for $i=1$ to $n+1$<br>
3 $e[i,i-1]=q_{i-1}$<br>
4 $w[i,i-1]=q_{i-1}$<br>
5 for $l=1$ to $n$<br>
6 for $i=1$ to $n-l+1$<br>
7 $j=i+l-1$<br>
8 $e[i,j]=\infty$<br>
9 $w[i,j]=w[i,j-1]+p_j+q_j$<br>
10 $\operatorname{for}r=i$ to $j$<br>
11 $t=e[i,r-1]+e[r+1,j]+w[i,j]$<br>
12 $\textbf{if }t&lt; e[ i, j]$<br>
13 $e[i,j]=t$<br>
14 $root[i,j]=r$<br>
15 return $e$ and root<br>
根据前文的描述，以及与前面的算法 MATRIX-CHAIN-ORDER 的相似性，很容易理解此算法。第 2~4 行的 for 循环初始化 e[i,$i-1]$和 $w[i,i-1]$的值。第 5~14 行的 for 循环利用递归式(15.14)和递归式(15.15)来对所有$1\leqslant i\leqslant j\leqslant n$计算 e$[i,j]$和$w[i,j]$。在第一个循环步中，$l=1$,循环对所有$i=1,2,\cdots,n$计算e$[i,i]$和$w[i,i]$。第二个循环步中，$l=2$,对所有$i=1,2,\cdots,n-1$计算 $e[i,i+1]$和 $w[i,i+1]$,依此类推。第 10~14 行的内层 for 循环，逐个尝试下标$r$,确定哪个关键字$k$, 作 为 根 结 点 可 以 得 到 包 含 关 键 字 $k_i, . . . , k_j$的最优二叉搜索树。这个 for 循环在找到更好的关键字作为根结点时，会将其下标$r$ 保存在 $root[i,j]$中。<br>
图 15-10 给出了 OPTIMAL-BST 输人图 15-9 中的关键字分布后计算出的表 e[i,j]、w[i,j]和$root[i,j]$。与图 15-5 中矩阵链乘法问题的输出结果一样，本图中的表也进行了旋转，对角线旋转到了水平方向。OPTIMAL-BST 按自底向上的顺序逐行计算，在每行中由左至右计算每个表项。<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5C83c2ec99951840ebb911a615ef81c985.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
与 MATRIX-CHAIN-ORDER 一样，OPTIMAL-BST 的时间复杂度也是$\Theta(n^3)$。由于它包含三重 for 循环，而每层循环的下标最多取$n$个值，因此很容易得出其运行时间为$O(n^3)$。OPTIMAL-BST 的循环下标的范围与 MATRIX-CHAIN-ORDER 不完全一样，但每个方向最多相差 1。因此，与 MATRIX-CHAIN-ORDER 一样，OPTIMAL-BST 的运行时间为$\Omega(n^3)$(从而得出运行时间为$\Theta(n^3))$。</p>
<h1>三、问题分类</h1>
<h2 id="到达目标的最小（最大）路径">到达目标的最小（最大）路径</h2>
<p><strong>问题描述：</strong><br>
给定一个目标，找出达到目标的最小（最大）成本/路径/总和。<br>
<strong>解决方法：</strong><br>
在当前状态之前的所有可能路径中选择最小（最大）路径，然后为当前状态添加值。<br>
<strong>问题示例：</strong></p>
<h3 id="322-零钱兑换-（完全背包）中等">322.零钱兑换 （完全背包）中等</h3>
<blockquote>
<p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。<br>
计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。<br>
你可以认为每种硬币的数量是无限的。<br>
示例 1：<br>
输入：coins = [1, 2, 5], amount = 11<br>
输出：3<br>
解释：11 = 5 + 5 + 1<br>
示例 2：<br>
输入：coins = [2], amount = 3<br>
输出：-1<br>
示例 3：<br>
输入：coins = [1], amount = 0<br>
输出：0<br>
提示：<br>
1 &lt;= coins.length &lt;= 12<br>
1 &lt;= coins[i] &lt;= 231 - 1<br>
0 &lt;= amount &lt;= 104</p>
</blockquote>
<p><strong>解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-attr">public</span>:<br>    int <span class="hljs-title function_">coinChange</span>(<span class="hljs-params">vector&lt;int&gt;&amp; coins, int amount</span>) &#123;<br>        int n = coins.<span class="hljs-title function_">size</span>();<br>        vector&lt;int&gt; <span class="hljs-title function_">dp</span>(amount + <span class="hljs-number">1</span>, <span class="hljs-variable constant_">INT_MAX</span>);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">1</span>; i &lt;= amount; i++)&#123;<br>            <span class="hljs-keyword">for</span>(int j : coins)&#123;<br>                <span class="hljs-keyword">if</span>(i &gt;= j &amp;&amp; dp[i - j] != <span class="hljs-variable constant_">INT_MAX</span>)&#123;<br>                    dp[i] = <span class="hljs-title function_">min</span>(dp[i], dp[i - j] + <span class="hljs-number">1</span>);<br>                &#125;  <br>            &#125;      <br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount] == <span class="hljs-variable constant_">INT_MAX</span>? -<span class="hljs-number">1</span> : dp[amount];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h3 id="518-零钱兑换-II-（完全背包-求方案数）中等">518.零钱兑换 II （完全背包-求方案数）中等</h3>
<blockquote>
<p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。<br>
请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。<br>
假设每一种面额的硬币有无限个。<br>
题目数据保证结果符合 32 位带符号整数。<br>
示例 1：<br>
输入：amount = 5, coins = [1, 2, 5]<br>
输出：4<br>
解释：有四种方式可以凑成总金额：<br>
5=5<br>
5=2+2+1<br>
5=2+1+1+1<br>
5=1+1+1+1+1<br>
示例 2：<br>
输入：amount = 3, coins = [2]<br>
输出：0<br>
解释：只用面额 2 的硬币不能凑成总金额 3 。<br>
示例 3：<br>
输入：amount = 10, coins = [10]<br>
输出：1<br>
提示：<br>
1 &lt;= coins.length &lt;= 300<br>
1 &lt;= coins[i] &lt;= 5000<br>
coins 中的所有值 互不相同<br>
0 &lt;= amount &lt;= 5000</p>
</blockquote>
<p><strong>解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    public int <span class="hljs-title function_">change</span>(<span class="hljs-params">int cnt, int[] cs</span>) &#123;<br>        int n = cs.<span class="hljs-property">length</span>;<br>        int[][] f = <span class="hljs-keyword">new</span> int[n + <span class="hljs-number">1</span>][cnt + <span class="hljs-number">1</span>];<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            int val = cs[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt;= cnt; j++) &#123;<br>                f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">for</span> (int k = <span class="hljs-number">1</span>; k * val &lt;= j; k++) &#123;<br>                    f[i][j] += f[i - <span class="hljs-number">1</span>][j - k * val];  <br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n][cnt];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="不同的方式——达到目标不同方式的总数">不同的方式——达到目标不同方式的总数</h2>
<p><strong>问题描述：</strong><br>
给定一个目标，找到许多不同的方法来达到目标。<br>
<strong>解决方法：</strong><br>
求和所有可能达到当前状态的方法<br>
<strong>问题示例：</strong></p>
<h3 id="935-骑士拨号器（递推型DP、状态压缩DP）中等">935.骑士拨号器（递推型DP、状态压缩DP）中等</h3>
<blockquote>
<p>象棋骑士有一个独特的移动方式，它可以垂直移动两个方格，水平移动一个方格，或者水平移动两个方格，垂直移动一个方格(两者都形成一个 L 的形状)。<br>
象棋骑士可能的移动方式如下图所示:<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5C70248a9a0640419a970c13117803a077.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
我们有一个象棋骑士和一个电话垫，如下所示，骑士只能站在一个数字单元格上(即蓝色单元格)。<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5Cc61c15f4fb984a24bf0647c8b1080c6a.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
给定一个整数 n，返回我们可以拨多少个长度为 n 的不同电话号码。<br>
你可以将骑士放置在任何数字单元格上，然后你应该执行 n - 1 次移动来获得长度为 n 的号码。所有的跳跃应该是有效的骑士跳跃。<br>
因为答案可能很大，所以输出答案模 109 + 7.<br>
示例 1：<br>
输入：n = 1<br>
输出：10<br>
解释：我们需要拨一个长度为1的数字，所以把骑士放在10个单元格中的任何一个数字单元格上都能满足条件。<br>
示例 2：<br>
输入：n = 2<br>
输出：20<br>
解释：我们可以拨打的所有有效号码为[04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]<br>
示例 3：<br>
输入：n = 3131<br>
输出：136006598<br>
解释：注意取模<br>
提示：<br>
1 &lt;= n &lt;= 5000</p>
</blockquote>
<p><strong>解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    public int <span class="hljs-title function_">knightDialer</span>(<span class="hljs-params">int n</span>) &#123;<br>        <span class="hljs-comment">// dp[i][j] = \sum_&#123;k=0&#125;^&#123;9&#125; dp[i-1][k]</span><br>        int mod = <span class="hljs-number">1000000000</span> + <span class="hljs-number">7</span>;<br>        int[][] dp = <span class="hljs-keyword">new</span> int[n][<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (int k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">10</span>; k++) &#123;<br>            dp[<span class="hljs-number">0</span>][k] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        int[][] moves = <span class="hljs-keyword">new</span> int[][]&#123;<br>                &#123;<span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;, &#123;<span class="hljs-number">6</span>, <span class="hljs-number">8</span>&#125;, &#123;<span class="hljs-number">7</span>, <span class="hljs-number">9</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">8</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>&#125;, &#123;&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">6</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>&#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (int k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">10</span>; k++) &#123;<br>                int[] mo = moves[k];<br>                <span class="hljs-keyword">for</span> (int m : mo) &#123;<br>                    dp[i][k] = (dp[i][k] + dp[i-<span class="hljs-number">1</span>][m]) % mod;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        int res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (int k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">10</span>; k++) &#123;<br>            res = (res + dp[n-<span class="hljs-number">1</span>][k]) % mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="576-出界的路径数（记忆化搜索）中等">576 出界的路径数（记忆化搜索）中等</h3>
<blockquote>
<p>给你一个大小为 m x n 的网格和一个球。球的起始坐标为 [startRow, startColumn] 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 最多 可以移动 maxMove 次球。<br>
给你五个整数 m、n、maxMove、startRow 以及 startColumn ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 109 + 7 取余 后的结果。<br>
示例 1：<br>
输入：m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0<br>
输出：6<br>
示例 2：<br>
输入：m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1<br>
输出：12<br>
提示：<br>
1 &lt;= m, n &lt;= 50<br>
0 &lt;= maxMove &lt;= 50<br>
0 &lt;= startRow &lt; m<br>
0 &lt;= startColumn &lt; n</p>
</blockquote>
<p><strong>解决方案</strong><br>
记忆化搜索：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> int mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  map&lt;pair&lt;pair&lt;int,int&gt;, int&gt;, long&gt; ret;<br><span class="hljs-attr">public</span>:<br>  int <span class="hljs-title function_">findPaths</span>(<span class="hljs-params">int m, int n, int maxMove, int startRow, int startColumn</span>) <br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">dfs</span>(m, n, startRow, startColumn,maxMove);<br>  &#125;<br>  int <span class="hljs-title function_">dfs</span>(<span class="hljs-params">int m, int n, int i, int j, int num</span>)<br>  &#123;<br>    <span class="hljs-comment">//当前位置出界，说明找到一条路径</span><br>    <span class="hljs-keyword">if</span> (i&lt; <span class="hljs-number">0</span> || j&lt; <span class="hljs-number">0</span> || i&gt;= m || j&gt;= n)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//判断当前位置的结果是否求出</span><br>    <span class="hljs-keyword">if</span> (ret.<span class="hljs-title function_">find</span>(&#123;&#123; i,j &#125;, num&#125;) != ret.<span class="hljs-title function_">end</span>())<br>      <span class="hljs-keyword">return</span> ret[&#123; &#123;i, j&#125;, num&#125;];<br>    <span class="hljs-comment">//如果当前可移动次数小于等于0，并且还没有出界，那么则不算一条路径</span><br>    <span class="hljs-keyword">if</span> (num&lt;=<span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//当前位置的路径和等于来自他四个方向之和</span><br>    int sum = <span class="hljs-number">0</span>;<br>    sum += <span class="hljs-title function_">dfs</span>(m, n, i + <span class="hljs-number">1</span>, j, num - <span class="hljs-number">1</span>);<br>    sum %= mod;<br>    sum += <span class="hljs-title function_">dfs</span>(m, n, i - <span class="hljs-number">1</span>, j, num - <span class="hljs-number">1</span>);<br>    sum %= mod;<br>    sum += <span class="hljs-title function_">dfs</span>(m, n, i, j + <span class="hljs-number">1</span>, num - <span class="hljs-number">1</span>);<br>    sum %= mod;<br>    sum += <span class="hljs-title function_">dfs</span>(m, n, i, j - <span class="hljs-number">1</span>, num - <span class="hljs-number">1</span>);<br>    sum %= mod;<br>    <span class="hljs-keyword">return</span> ret[&#123; &#123;i, j&#125;, num&#125;]=sum ;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>动态规划：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    int mod = (int)<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>    int m, n, N;<br>    public int <span class="hljs-title function_">findPaths</span>(<span class="hljs-params">int _m, int _n, int _N, int _i, int _j</span>) &#123;<br>        m = _m; n = _n; N = _N;<br>        <br>        <span class="hljs-comment">// f[i][j] 代表从 idx 为 i 的位置出发，移动步数不超过 j 的路径数量</span><br>        int[][] f = <span class="hljs-keyword">new</span> int[m * n][N + <span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-comment">// 初始化边缘格子的路径数量</span><br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) <span class="hljs-title function_">add</span>(i, j, f);<br>                <span class="hljs-keyword">if</span> (i == m - <span class="hljs-number">1</span>) <span class="hljs-title function_">add</span>(i, j, f);<br>                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) <span class="hljs-title function_">add</span>(i, j, f);<br>                <span class="hljs-keyword">if</span> (j == n - <span class="hljs-number">1</span>) <span class="hljs-title function_">add</span>(i, j, f);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 定义可移动的四个方向</span><br>        int[][] dirs = <span class="hljs-keyword">new</span> int[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;&#125;;<br>        <br>        <span class="hljs-comment">// 从小到大枚举「可移动步数」</span><br>        <span class="hljs-keyword">for</span> (int step = <span class="hljs-number">1</span>; step &lt;= N; step++) &#123;<br>            <span class="hljs-comment">// 枚举所有的「位置」</span><br>            <span class="hljs-keyword">for</span> (int k = <span class="hljs-number">0</span>; k &lt; m * n; k++) &#123;<br>                int x = <span class="hljs-title function_">parseIdx</span>(k)[<span class="hljs-number">0</span>], y = <span class="hljs-title function_">parseIdx</span>(k)[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">for</span> (int[] d : dirs) &#123;<br>                    int nx = x + d[<span class="hljs-number">0</span>], ny = y + d[<span class="hljs-number">1</span>];<br>                    <span class="hljs-comment">// 如果位置有「相邻格子」，则「相邻格子」参与状态转移</span><br>                    <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; n) &#123;<br>                        f[k][step] += f[<span class="hljs-title function_">getIndex</span>(nx, ny)][step - <span class="hljs-number">1</span>];<br>                        f[k][step] %= mod;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 最终结果为从起始点触发，最大移动步数不超 N 的路径数量</span><br>        <span class="hljs-keyword">return</span> f[<span class="hljs-title function_">getIndex</span>(_i, _j)][N];<br>    &#125;<br>    <br>    <span class="hljs-comment">// 为每个「边缘」格子，添加一条路径</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">int x, int y, int[][] f</span>) &#123;<br>        int idx = <span class="hljs-title function_">getIndex</span>(x, y);<br>        <span class="hljs-keyword">for</span> (int step = <span class="hljs-number">1</span>; step &lt;= N; step++) &#123;<br>            f[idx][step]++;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 将 (x, y) 转换为 index</span><br>    int <span class="hljs-title function_">getIndex</span>(<span class="hljs-params">int x, int y</span>) &#123;<br>        <span class="hljs-keyword">return</span> x * n + y;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 将 index 解析回 (x, y)</span><br>    int[] <span class="hljs-title function_">parseIdx</span>(<span class="hljs-params">int idx</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> int[]&#123;idx / n, idx % n&#125;;<br>    &#125;<br>&#125; <br><br></code></pre></td></tr></table></figure>
<p>动态规划套壳法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> int mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-attr">public</span>:<br>  int <span class="hljs-title function_">findPaths</span>(<span class="hljs-params">int m, int n, int maxMove, int startRow, int startColumn</span>) <br>  &#123;<br>    <span class="hljs-comment">//f[i][j][num]从(i,j)出发第num步出界的路径总数，等价于从外界出发第num步走到(i,j)的路径总数</span><br>    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; <span class="hljs-title function_">dp</span>(m + <span class="hljs-number">2</span>, vector&lt;vector&lt;int&gt;&gt;(n + <span class="hljs-number">2</span>,vector&lt;int&gt;(maxMove+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)));<br>    <span class="hljs-comment">//外部一圈初始化</span><br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">2</span>; i++)<span class="hljs-comment">//第一行和最后一行同时进行初始化</span><br>    &#123;<br>      dp[<span class="hljs-number">0</span>][i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      dp[m + <span class="hljs-number">1</span>][i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">1</span>; j &lt; m+<span class="hljs-number">2</span>; j++)<span class="hljs-comment">//左右两列初始化</span><br>    &#123;<br>      dp[j][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>      dp[j][n + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (int k = <span class="hljs-number">1</span>; k &lt;= maxMove; k++)<br>    &#123;<br>      <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt; m + <span class="hljs-number">1</span>; i++)<br>      &#123;<br>        <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">1</span>; j &lt; n + <span class="hljs-number">1</span>; j++)<br>        &#123;<br>          dp[i][j][k] += dp[i - <span class="hljs-number">1</span>][j][k - <span class="hljs-number">1</span>];<br>          dp[i][j][k] %= mod;<br>          dp[i][j][k] += dp[i + <span class="hljs-number">1</span>][j][k - <span class="hljs-number">1</span>];<br>          dp[i][j][k] %= mod;<br>          dp[i][j][k] += dp[i][j - <span class="hljs-number">1</span>][k - <span class="hljs-number">1</span>];<br>          dp[i][j][k] %= mod;<br>          dp[i][j][k] += dp[i][j + <span class="hljs-number">1</span>][k - <span class="hljs-number">1</span>];<br>          dp[i][j][k] %= mod;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">//计算起点出界路径总和</span><br>    int sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (int k = <span class="hljs-number">1</span>; k &lt;=maxMove; k++)<br>    &#123;<br>      sum=(sum+dp[startRow+<span class="hljs-number">1</span>][startColumn+<span class="hljs-number">1</span>][k])%mod;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>  &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h3 id="808-分汤（概率型DP）中等">808 分汤（概率型DP）中等</h3>
<blockquote>
<p>有 A 和 B 两种类型 的汤。一开始每种类型的汤有 n 毫升。有四种分配操作：<br>
提供 100ml 的 汤A 和 0ml 的 汤B 。<br>
提供 75ml 的 汤A 和 25ml 的 汤B 。<br>
提供 50ml 的 汤A 和 50ml 的 汤B 。<br>
提供 25ml 的 汤A 和 75ml 的 汤B 。<br>
当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为 0.25 的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。<br>
注意 不存在先分配 100 ml 汤B 的操作。<br>
需要返回的值： 汤A 先分配完的概率 +  汤A和汤B 同时分配完的概率 / 2。返回值在正确答案 10-5 的范围内将被认为是正确的。<br>
示例 1:<br>
输入: n = 50<br>
输出: 0.62500<br>
解释:如果我们选择前两个操作，A 首先将变为空。<br>
对于第三个操作，A 和 B 会同时变为空。<br>
对于第四个操作，B 首先将变为空。<br>
所以 A 变为空的总概率加上 A 和 B 同时变为空的概率的一半是 0.25 *(1 + 1 + 0.5 + 0)= 0.625。<br>
示例 2:<br>
输入: n = 100<br>
输出: 0.71875<br>
提示:<br>
0 &lt;= n &lt;= 109​​​​​​​</p>
</blockquote>
<p><strong>解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-attr">public</span>:<br>    double <span class="hljs-title function_">soupServings</span>(<span class="hljs-params">int N</span>) &#123;<br>      unordered_map&lt;int,unordered_map&lt;int,double&gt;&gt; dp, temp;<br>        <span class="hljs-keyword">if</span>(N &gt;= <span class="hljs-number">4800</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//经过计算 N=4800时，prob = 0.99999，误差小于1e-6</span><br>      dp[N][N] = <span class="hljs-number">1.0</span>;<br>      double prob = <span class="hljs-number">0.0</span>, p;<br>      vector&lt;vector&lt;int&gt;&gt; delta = &#123;&#123;<span class="hljs-number">100</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">75</span>,<span class="hljs-number">25</span>&#125;,&#123;<span class="hljs-number">50</span>,<span class="hljs-number">50</span>&#125;,&#123;<span class="hljs-number">25</span>,<span class="hljs-number">75</span>&#125;&#125;;<br>      int A, B, nA, nB, i;<br>        <span class="hljs-keyword">while</span>(!dp.<span class="hljs-title function_">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">for</span>(auto&amp; item1 : dp)<br>            &#123;  <br>                A = item1.<span class="hljs-property">first</span>;<br>                <span class="hljs-keyword">for</span>(auto&amp; item2 : item1.<span class="hljs-property">second</span>)<br>                &#123;<br>                    B = item2.<span class="hljs-property">first</span>;<br>                    p = item2.<span class="hljs-property">second</span>;<br>                    <span class="hljs-keyword">if</span>(A == <span class="hljs-number">0</span>)<span class="hljs-comment">//A喝完了</span><br>                    &#123;<br>                        <span class="hljs-keyword">if</span>(B == <span class="hljs-number">0</span>)<span class="hljs-comment">//AB同时喝完</span><br>                            prob += p/<span class="hljs-number">2.0</span>;<br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(B &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//A先喝完</span><br>                            prob += p;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><span class="hljs-comment">//A没完</span><br>                    &#123;<br>                        <span class="hljs-keyword">if</span>(B == <span class="hljs-number">0</span>)<span class="hljs-comment">//B先喝完，不在答案考虑范围内</span><br>                            <span class="hljs-keyword">continue</span>;<br>                        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<span class="hljs-comment">//4种情况</span><br>                        &#123;<br>                            nA = <span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, A-delta[i][<span class="hljs-number">0</span>]);<span class="hljs-comment">//不够，直接全部喝完，为0</span><br>                            nB = <span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, B-delta[i][<span class="hljs-number">1</span>]);<br>                            temp[nA][nB] += p*<span class="hljs-number">0.25</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            dp.<span class="hljs-title function_">swap</span>(temp);<span class="hljs-comment">//更新dp</span><br>            temp.<span class="hljs-title function_">clear</span>();<br>        &#125;<br>      <span class="hljs-keyword">return</span> prob;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h3 id="62-不同路径（计数型DP）中等">62 不同路径（计数型DP）中等</h3>
<blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br>
问总共有多少条不同的路径？<br>
示例 1：<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5C18666736f6564d50bea38d3e08a6b2d3.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
输入：m = 3, n = 7<br>
输出：28<br>
示例 2：<br>
输入：m = 3, n = 2<br>
输出：3<br>
解释：<br>
从左上角开始，总共有 3 条路径可以到达右下角。<br>
1.向右 -&gt; 向下 -&gt; 向下<br>
2.向下 -&gt; 向下 -&gt; 向右<br>
3.向下 -&gt; 向右 -&gt; 向下<br>
示例 3：<br>
输入：m = 7, n = 3<br>
输出：28<br>
示例 4：<br>
输入：m = 3, n = 3<br>
输出：6<br>
提示：<br>
1 &lt;= m, n &lt;= 100<br>
题目数据保证答案小于等于 2 * 109</p>
</blockquote>
<p><strong>解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    public int <span class="hljs-title function_">uniquePaths</span>(<span class="hljs-params">int m, int n</span>) &#123;<br>        int[] dp = <span class="hljs-keyword">new</span> int[n];<br>        <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">fill</span>(dp, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[j] = dp[j-<span class="hljs-number">1</span>] + dp[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="区间合并">区间合并</h2>
<p><strong>问题描述：</strong><br>
给定一组数字，根据当前数字以及你能从左右两边得到的最好结果，找到问题的最优解。<br>
<strong>解决方法：</strong><br>
找到每个区间的所有最优解，并返回最佳答案。<br>
<strong>问题示例：</strong></p>
<h3 id="1039-多边形三角剖分的最低得分（区间DP）中等">1039 多边形三角剖分的最低得分（区间DP）中等</h3>
<blockquote>
<p>你有一个凸的 n 边形，其每个顶点都有一个整数值。给定一个整数数组 values ，其中 values[i] 是第 i 个顶点的值（即 顺时针顺序 ）。<br>
假设将多边形 剖分 为 n - 2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 n - 2 个三角形的值之和。<br>
返回 多边形进行三角剖分后可以得到的最低分 。<br>
示例 1：<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5Cabb24aff87fd40dbb2d0082876ffdd73.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
输入：values = [1,2,3]<br>
输出：6<br>
解释：多边形已经三角化，唯一三角形的分数为 6。<br>
示例 2：<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5Cbe9d67c0137940a7a89f975e479dfe8b.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
输入：values = [3,7,4,5]<br>
输出：144<br>
解释：有两种三角剖分，可能得分分别为：3<em>7</em>5 + 4<em>5</em>7 = 245，或 3<em>4</em>5 + 3<em>4</em>7 = 144。最低分数为 144。<br>
示例 3：<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5Cc77c8b990d7a4b629da4a330dda4fe40.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
输入：values = [1,3,1,4,1,5]<br>
输出：13<br>
解释：最低分数三角剖分的得分情况为 1<em>1</em>3 + 1<em>1</em>4 + 1<em>1</em>5 + 1<em>1</em>1 = 13。<br>
提示：<br>
n == values.length<br>
3 &lt;= n &lt;= 50<br>
1 &lt;= values[i] &lt;= 100</p>
</blockquote>
<p><strong>解决方案：</strong><br>
记忆化搜索：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-attr">public</span>:<br>    int f[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>];<br>    int <span class="hljs-title function_">minScoreTriangulation</span>(<span class="hljs-params">vector&lt;int&gt;&amp; values</span>) <br>    &#123;<br>        <span class="hljs-title function_">memset</span>(f,<span class="hljs-number">0x3f3f3f3f</span>,<span class="hljs-title function_">sizeof</span>(f));<br> <br>        <span class="hljs-keyword">function</span>&lt;<span class="hljs-title function_">int</span>(int, int)&gt; dfs = [&amp;](int i,int j)-&gt;int<br>        &#123;<br>             <span class="hljs-keyword">if</span>(<span class="hljs-title function_">abs</span>(i - j) &lt;= <span class="hljs-number">1</span>)<br>             &#123;<br>                 <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>             &#125;<br>             <span class="hljs-keyword">if</span>(f[i][j] != <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> f[i][j];<br>             <span class="hljs-keyword">for</span>(int k = i + <span class="hljs-number">1</span>;k &lt; j;k++)<br>             &#123;<br>                f[i][j] = <span class="hljs-title function_">min</span>(f[i][j],<span class="hljs-title function_">dfs</span>(i,k) + <span class="hljs-title function_">dfs</span>(k,j) + values[i]*values[j]*values[k]);<br>             &#125;<br>             <span class="hljs-keyword">return</span> f[i][j];<br>        &#125;;<br> <br>        <span class="hljs-title function_">dfs</span>(<span class="hljs-number">0</span>,values.<span class="hljs-title function_">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> f[<span class="hljs-number">0</span>][values.<span class="hljs-title function_">size</span>() - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>动态规划</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs javascript">#include &lt;iostream&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;cstring&gt;<br><span class="hljs-keyword">using</span> namespace std;<br><span class="hljs-keyword">const</span> int N = <span class="hljs-number">70</span>;<br> <br>int n;<br>int a[N];<br>__int128 f[N][N];<br>ostream &amp;operator &lt;&lt; (ostream &amp;out,__int128 x) &#123;<br>    <span class="hljs-keyword">if</span> (!x) &#123;<br>        out &lt;&lt; <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> out;<br>    &#125;<br>    int stk[<span class="hljs-number">110</span>],top = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (x) stk[++top] = x % <span class="hljs-number">10</span>,x /= <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">for</span> (int i = top;i &gt;= <span class="hljs-number">1</span>;i--) out &lt;&lt; stk[i];<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br>int <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)<br>&#123;<br>    cin&gt;&gt;n;<br>    <br>    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">1</span>;i &lt;= n;i++)<br>    &#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-comment">//memset(f,0x3f,sizeof f);</span><br>    <span class="hljs-keyword">for</span>(int len = <span class="hljs-number">1</span>;len &lt;= n;len++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(int l = <span class="hljs-number">1</span>,r;r = l + len - <span class="hljs-number">1</span>,r &lt;= n;l++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">3</span>) f[l][r] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                f[l][r] = <span class="hljs-number">1e29</span>;<br>            <span class="hljs-keyword">for</span>(int k = l + <span class="hljs-number">1</span>;k &lt; r;k++)<br>            &#123;<br>                f[l][r] = <span class="hljs-title function_">min</span>(f[l][r],f[l][k] + f[k][r] + (__int128)a[l] * a[k] * a[r]);<br>            &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    cout&lt;&lt;f[<span class="hljs-number">1</span>][n]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="312-戳气球（区间DP）困难">312 戳气球（区间DP）困难</h3>
<blockquote>
<p>有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。<br>
现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。<br>
求所能获得硬币的最大数量。<br>
示例 1：<br>
输入：nums = [3,1,5,8]<br>
输出：167<br>
解释：<br>
nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []<br>
coins =  3<em>1</em>5    +   3<em>5</em>8   +  1<em>3</em>8  + 1<em>8</em>1 = 167<br>
示例 2：<br>
输入：nums = [1,5]<br>
输出：10<br>
提示：<br>
n == nums.length<br>
1 &lt;= n &lt;= 300<br>
0 &lt;= nums[i] &lt;= 100</p>
</blockquote>
<p>解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    public int <span class="hljs-title function_">maxCoins</span>(<span class="hljs-params">int[] nums</span>) &#123;<br>        int n = nums.<span class="hljs-property">length</span>;<br>        int[] newNums = <span class="hljs-keyword">new</span> int[n + <span class="hljs-number">2</span>];<br>        newNums[<span class="hljs-number">0</span>] = newNums[n + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            newNums[i+<span class="hljs-number">1</span>] = nums[i];<br>        &#125;<br>        int[][] dp = <span class="hljs-keyword">new</span> int[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br><br>        <span class="hljs-keyword">for</span> (int i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (int j = i + <span class="hljs-number">2</span>; j &lt; n + <span class="hljs-number">2</span>; j++) &#123;<br>                <span class="hljs-keyword">for</span> (int k = i + <span class="hljs-number">1</span>; k &lt; j; k++) &#123;<br>                    dp[i][j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[i][j], newNums[i] * newNums[k] * newNums[j] + dp[i][k] + dp[k][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n+<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="字符串——字符串上的动态规划">字符串——字符串上的动态规划</h2>
<p><strong>问题描述：</strong><br>
此模式的一般问题陈述可能会有所不同，但大多数情况下，你会得到两个字符串，这些字符串的长度并不大，返回两个字符串和一些其他的结果。<br>
<strong>解决方法：</strong><br>
这种类型下的大多数问题都需要一个复杂度为$O（n^2）$的解决方案。<br>
<strong>问题示例:</strong></p>
<h3 id="1147-最长公共子序列（线性DP、最经典双串）中等">1147 最长公共子序列（线性DP、最经典双串）中等</h3>
<blockquote>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。<br>
一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>
例如，“ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。<br>
示例 1：<br>
输入：text1 = “abcde”, text2 = “ace”<br>
输出：3<br>
解释：最长公共子序列是 “ace” ，它的长度为 3 。<br>
示例 2：<br>
输入：text1 = “abc”, text2 = “abc”<br>
输出：3<br>
解释：最长公共子序列是 “abc” ，它的长度为 3 。<br>
示例 3：<br>
输入：text1 = “abc”, text2 = “def”<br>
输出：0<br>
解释：两个字符串没有公共子序列，返回 0 。<br>
提示：<br>
1 &lt;= text1.length, text2.length &lt;= 1000<br>
text1 和 text2 仅由小写英文字符组成。<br>
516 最长回文子序列（区间DP）中等</p>
</blockquote>
<p><strong>解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    public int <span class="hljs-title function_">longestCommonSubsequence</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> text1, <span class="hljs-built_in">String</span> text2</span>) &#123;<br>        int m = text1.<span class="hljs-title function_">length</span>(), n = text2.<span class="hljs-title function_">length</span>();<br>        int[][] dp = <span class="hljs-keyword">new</span> int[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            char c1 = text1.<span class="hljs-title function_">charAt</span>(i - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (c1 == text2.<span class="hljs-title function_">charAt</span>(j - <span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>如果要求返回最长子序列：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript">public <span class="hljs-title class_">String</span> <span class="hljs-title function_">LCS</span> (<span class="hljs-title class_">String</span> s1, <span class="hljs-title class_">String</span> s2) &#123;<br>    int m = s1.<span class="hljs-title function_">length</span>(), n = s2.<span class="hljs-title function_">length</span>();<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span> || n == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;-1&quot;</span>;<br>    &#125;<br>    int[][] dp = <span class="hljs-keyword">new</span> int[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (s1.<span class="hljs-title function_">charAt</span>(i - <span class="hljs-number">1</span>) == s2.<span class="hljs-title function_">charAt</span>(j - <span class="hljs-number">1</span>)) &#123;<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-title class_">StringBuilder</span> sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    int i = m, j = n;<br>    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; j &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (s1.<span class="hljs-title function_">charAt</span>(i - <span class="hljs-number">1</span>) == s2.<span class="hljs-title function_">charAt</span>(j - <span class="hljs-number">1</span>)) &#123;<br>            sb.<span class="hljs-title function_">append</span>(s1.<span class="hljs-title function_">charAt</span>(i - <span class="hljs-number">1</span>));<br>            i--;<br>            j--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (dp[i][j-<span class="hljs-number">1</span>] &gt; dp[i-<span class="hljs-number">1</span>][j]) &#123;<br>                j--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                i--;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (sb.<span class="hljs-title function_">length</span>() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;-1&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">toString</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="516-最长回文子序列（区间DP）中等">516.最长回文子序列（区间DP）中等</h3>
<blockquote>
<p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。<br>
子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。<br>
示例 1：<br>
输入：s = “bbbab”<br>
输出：4<br>
解释：一个可能的最长回文子序列为 “bbbb” 。<br>
示例 2：<br>
输入：s = “cbbd”<br>
输出：2<br>
解释：一个可能的最长回文子序列为 “bb” 。<br>
提示：<br>
1 &lt;= s.length &lt;= 1000<br>
s 仅由小写英文字母组成</p>
</blockquote>
<p><strong>解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    public <span class="hljs-title class_">String</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>) &#123;<br>        int n = s.<span class="hljs-title function_">length</span>();<br>        boolean[][] dp = <span class="hljs-keyword">new</span> boolean[n][n];<br>        <br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            dp[i][i] = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        int res = <span class="hljs-number">1</span>;<br>        int startId = <span class="hljs-number">0</span>, endId = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (s.<span class="hljs-title function_">charAt</span>(i) == s.<span class="hljs-title function_">charAt</span>(j)) &#123;<br>                    <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> == i) &#123;<br>                        dp[j][i] = <span class="hljs-literal">true</span>;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[j + <span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>]) &#123;<br>                        dp[j][i] = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (dp[j][i] &amp;&amp; i - j + <span class="hljs-number">1</span> &gt; res) &#123;<br>                        res = i - j + <span class="hljs-number">1</span>;<br>                        startId = j;<br>                        endId = i + <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">substring</span>(startId, endId);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>另一种写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">public int <span class="hljs-title function_">getLongestPalindrome</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> A, int n</span>) &#123;<br>        boolean[][] dp = <span class="hljs-keyword">new</span> boolean[n][n];<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">fill</span>(dp[i], <span class="hljs-literal">true</span>);<br>        &#125;<br><br>        int maxLen = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (int i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (int j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                dp[i][j] = A.<span class="hljs-title function_">charAt</span>(i) == A.<span class="hljs-title function_">charAt</span>(j) &amp;&amp; dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (dp[i][j]) &#123;<br>                    maxLen = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxLen, j - i + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="72-编辑距离（线性DP）困难">72 编辑距离（线性DP）困难</h3>
<blockquote>
<p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。<br>
你可以对一个单词进行如下三种操作：<br>
插入一个字符<br>
删除一个字符<br>
替换一个字符<br>
示例 1：<br>
输入：word1 = “horse”, word2 = “ros”<br>
输出：3<br>
解释：<br>
horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>
rorse -&gt; rose (删除 ‘r’)<br>
rose -&gt; ros (删除 ‘e’)<br>
示例 2：<br>
输入：word1 = “intention”, word2 = “execution”<br>
输出：5<br>
解释：<br>
intention -&gt; inention (删除 ‘t’)<br>
inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>
enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>
exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>
exection -&gt; execution (插入 ‘u’)<br>
提示：<br>
0 &lt;= word1.length, word2.length &lt;= 500<br>
word1 和 word2 由小写英文字母组成</p>
</blockquote>
<p><strong>解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    public int <span class="hljs-title function_">minDistance</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> word1, <span class="hljs-built_in">String</span> word2</span>) &#123;<br>        int m = word1.<span class="hljs-title function_">length</span>(), n = word2.<span class="hljs-title function_">length</span>();<br>        int[][] dp = <span class="hljs-keyword">new</span> int[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>) &#123;<br>                    dp[i][j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(i, j);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (word1.<span class="hljs-title function_">charAt</span>(i - <span class="hljs-number">1</span>) == word2.<span class="hljs-title function_">charAt</span>(j - <span class="hljs-number">1</span>)) &#123;<br>                        dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        dp[i][j] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]), dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="决策——取舍决定（当前元素取或是不取）">决策——取舍决定（当前元素取或是不取）</h2>
<p><strong>问题描述：</strong><br>
此类型的一般问题描述可以在决定是否使用当前状态的情况下进行，所以，这个问题要求你在当前状态下做出决定。即给定一组值，找到带有选择或者忽略当前值的选项的答案。<br>
<strong>解决方法：</strong><br>
如果您决定选择当前值，则使用先前忽略该值的结果；反之亦然，如果决定忽略当前值，则使用先前使用值的结果。<br>
<strong>问题示例：</strong></p>
<h3 id="121-买卖股票的最佳时机（线性DP）简单">121 买卖股票的最佳时机（线性DP）简单</h3>
<blockquote>
<p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。<br>
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。<br>
示例 1：<br>
输入：[7,1,5,3,6,4]<br>
输出：5<br>
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br>
示例 2：<br>
输入：prices = [7,6,4,3,1]<br>
输出：0<br>
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。<br>
提示：<br>
1 &lt;= prices.length &lt;= 105<br>
0 &lt;= prices[i] &lt;= 104</p>
</blockquote>
<p><strong>解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">lc_121</span> &#123;<br><br>    <span class="hljs-comment">// 解法三：动态规划</span><br>    public <span class="hljs-keyword">static</span> int <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">int[] prices</span>) &#123;<br>        int n = prices.<span class="hljs-property">length</span>;<br>        <span class="hljs-comment">// dp[i]表示前i天的最大利润</span><br>        int dp[] = <span class="hljs-keyword">new</span> int[n];<br>        <span class="hljs-comment">// minPrice初始化为prices[0]</span><br>        int minPrice = prices[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (prices[i] &lt; minPrice) &#123;<br>                minPrice = prices[i];<br>            &#125;<br>            <span class="hljs-comment">// 前i天的最大收益 = max&#123; 前i-1天的最大收益，第i天的价格 - 前i-1天中的最小价格 &#125;</span><br>            dp[i] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[i - <span class="hljs-number">1</span>], prices[i] - minPrice);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        int prices1[] = &#123;<span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>&#125;;<br>        int profit1 = <span class="hljs-title function_">maxProfit</span>(prices1);<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(profit1);<br><br>        int prices2[] = &#123;<span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;;<br>        int profit2 = <span class="hljs-title function_">maxProfit</span>(prices2);<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(profit2);<br><br>        int prices3[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>        int profit3 = <span class="hljs-title function_">maxProfit</span>(prices3);<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(profit3);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="123-买卖股票的最佳时机-III（线性DP）困难">123 买卖股票的最佳时机 III（线性DP）困难</h3>
<blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。<br>
设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。<br>
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>
示例 1:<br>
输入：prices = [3,3,5,0,0,3,1,4]<br>
输出：6<br>
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br>
随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。<br>
示例 2：<br>
输入：prices = [1,2,3,4,5]<br>
输出：4<br>
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>
注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>
因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br>
示例 3：<br>
输入：prices = [7,6,4,3,1]<br>
输出：0<br>
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。<br>
示例 4：<br>
输入：prices = [1]<br>
输出：0<br>
提示：<br>
1 &lt;= prices.length &lt;= 105<br>
0 &lt;= prices[i] &lt;= 105</p>
</blockquote>
<p><strong>解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript">#include &lt;vector&gt;<br>#include &lt;algorithm&gt;<br><span class="hljs-keyword">using</span> namespace std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-attr">public</span>:<br>    int <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">vector&lt;int&gt;&amp; prices</span>) &#123;<br>        <span class="hljs-keyword">if</span> (prices.<span class="hljs-title function_">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 初始化四个状态</span><br>        int first_buy = -prices[<span class="hljs-number">0</span>], first_sell = <span class="hljs-number">0</span>;<br>        int second_buy = -prices[<span class="hljs-number">0</span>], second_sell = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-title function_">size</span>(); ++i) &#123;<br>            <span class="hljs-comment">// 依次更新四个状态</span><br>            first_buy = <span class="hljs-title function_">max</span>(first_buy, -prices[i]);<br>            first_sell = <span class="hljs-title function_">max</span>(first_sell, first_buy + prices[i]);<br>            second_buy = <span class="hljs-title function_">max</span>(second_buy, first_sell - prices[i]);<br>            second_sell = <span class="hljs-title function_">max</span>(second_sell, second_buy + prices[i]);<br>        &#125;<br><br>        <span class="hljs-comment">// 返回最终状态的最大值</span><br>        <span class="hljs-keyword">return</span> second_sell;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h3 id="188-买卖股票的最佳时机-IV（线性DP）困难">188 买卖股票的最佳时机 IV（线性DP）困难</h3>
<blockquote>
<p>给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。<br>
设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。<br>
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>
示例 1：<br>
输入：k = 2, prices = [2,4,1]<br>
输出：2<br>
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。<br>
示例 2：<br>
输入：k = 2, prices = [3,2,6,5,0,3]<br>
输出：7<br>
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。<br>
随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。<br>
提示：<br>
1 &lt;= k &lt;= 100<br>
1 &lt;= prices.length &lt;= 1000<br>
0 &lt;= prices[i] &lt;= 1000</p>
</blockquote>
<p><strong>解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-attr">public</span>:<br>    int <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">int k, vector&lt;int&gt;&amp; prices</span>) &#123;<br>        int n = prices.<span class="hljs-title function_">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 当 k 大于等于 n/2 时，相当于可以进行无限次交易</span><br>        <span class="hljs-keyword">if</span> (k &gt;= n / <span class="hljs-number">2</span>) &#123;<br>            int max_profit = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (prices[i] &gt; prices[i - <span class="hljs-number">1</span>]) &#123;<br>                    max_profit += prices[i] - prices[i - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> max_profit;<br>        &#125;<br><br>        <span class="hljs-comment">// 初始化 dp 数组</span><br>        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; <span class="hljs-title function_">dp</span>(n, vector&lt;vector&lt;int&gt;&gt;(k + <span class="hljs-number">1</span>, vector&lt;int&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)));<br><br>        <span class="hljs-comment">// 初始化第一天的状态</span><br>        <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">1</span>; j &lt;= k; ++j) &#123;<br>            dp[<span class="hljs-number">0</span>][j][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-comment">// 动态规划状态转移</span><br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">1</span>; j &lt;= k; ++j) &#123;<br>                dp[i][j][<span class="hljs-number">0</span>] = <span class="hljs-title function_">max</span>(dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>] + prices[i]);<br>                dp[i][j][<span class="hljs-number">1</span>] = <span class="hljs-title function_">max</span>(dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 返回结果</span><br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h3 id="309-买卖股票的最佳时机含冷冻期（线性DP）中等">309 买卖股票的最佳时机含冷冻期（线性DP）中等</h3>
<blockquote>
<p>给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。​<br>
设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:<br>
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>
示例 1:<br>
输入: prices = [1,2,3,0,2]<br>
输出: 3<br>
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]<br>
示例 2:<br>
输入: prices = [1]<br>
输出: 0<br>
提示：<br>
1 &lt;= prices.length &lt;= 5000<br>
0 &lt;= prices[i] &lt;= 1000</p>
</blockquote>
<p><strong>解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript">#include &lt;vector&gt;<br>#include &lt;algorithm&gt;<br><span class="hljs-keyword">using</span> namespace std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-attr">public</span>:<br>    int <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">vector&lt;int&gt;&amp; prices</span>) &#123;<br>        <span class="hljs-keyword">if</span> (prices.<span class="hljs-title function_">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        int n = prices.<span class="hljs-title function_">size</span>();<br>        <span class="hljs-comment">// 初始化第0天的状态</span><br>        int hold = -prices[<span class="hljs-number">0</span>];<br>        int sell = <span class="hljs-number">0</span>;<br>        int cooldown = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-comment">// 更新状态</span><br>            int new_hold = <span class="hljs-title function_">max</span>(hold, sell - prices[i]);<br>            int new_cooldown = hold + prices[i];<br>            int new_sell = <span class="hljs-title function_">max</span>(sell, cooldown);<br><br>            <span class="hljs-comment">// 更新hold, cooldown, sell</span><br>            hold = new_hold;<br>            cooldown = new_cooldown;<br>            sell = new_sell;<br>        &#125;<br><br>        <span class="hljs-comment">// 返回sell和cooldown中的较大值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">max</span>(sell, cooldown);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h3 id="714-买卖股票的最佳时机含手续费（线性DP）中等">714 买卖股票的最佳时机含手续费（线性DP）中等</h3>
<blockquote>
<p>给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。<br>
你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。<br>
返回获得利润的最大值。<br>
注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。<br>
示例 1：<br>
输入：prices = [1, 3, 2, 8, 4, 9], fee = 2<br>
输出：8<br>
解释：能够达到的最大利润:<br>
在此处买入 prices[0] = 1<br>
在此处卖出 prices[3] = 8<br>
在此处买入 prices[4] = 4<br>
在此处卖出 prices[5] = 9<br>
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8<br>
示例 2：<br>
输入：prices = [1,3,7,5,10,3], fee = 3<br>
输出：6<br>
提示：<br>
1 &lt;= prices.length &lt;= 5 * 104<br>
1 &lt;= prices[i] &lt; 5 * 104<br>
0 &lt;= fee &lt; 5 * 104</p>
</blockquote>
<p><strong>解决方案</strong><br>
贪心算法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-attr">public</span>:<br>    int <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">vector&lt;int&gt;&amp; prices, int fee</span>) &#123;<br>        int n = prices.<span class="hljs-title function_">size</span>(); <span class="hljs-comment">// 获取价格数组的长度</span><br>        vector&lt;vector&lt;int&gt;&gt; <span class="hljs-title function_">dp</span>(n,vector&lt;int&gt;(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)); <span class="hljs-comment">// 创建二维数组dp，用于保存最大利润</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] -= prices[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 初始化第一天持有股票的最大利润</span><br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">1</span>;i&lt;n;i++) <span class="hljs-comment">// 遍历所有日期</span><br>        &#123;<br>            <span class="hljs-comment">// 在第i天不持有股票的最大利润为：昨天就没有持有股票的最大利润和昨天持有股票，今天卖掉的最大利润的较大值</span><br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-title function_">max</span>(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i]);<br>            <span class="hljs-comment">// 在第i天持有股票的最大利润为：昨天就持有股票的最大利润和昨天没有持有股票，今天买入股票的最大利润的较大值</span><br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-title function_">max</span>(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i] - fee);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 返回最后一天不持有股票的最大利润</span><br>        <span class="hljs-comment">// 可以返回最后一天持有股票的最大利润，两者取较大值即可</span><br>        <span class="hljs-comment">// return max(dp[n-1][0],dp[n-1][1]);</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>动态规划：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-attr">public</span>:<br>    int <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">vector&lt;int&gt;&amp; prices, int fee</span>) &#123;<br>        int n = prices.<span class="hljs-title function_">size</span>();<br>        int holdStock = (-<span class="hljs-number">1</span>) * prices[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 持股票</span><br>        int saleStock = <span class="hljs-number">0</span>; <span class="hljs-comment">// 卖出股票</span><br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            int previousHoldStock = holdStock;<br>            holdStock = <span class="hljs-title function_">max</span>(holdStock, saleStock - prices[i]);<br>            saleStock = <span class="hljs-title function_">max</span>(saleStock, previousHoldStock + prices[i] - fee);<br>        &#125;<br>        <span class="hljs-keyword">return</span> saleStock;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="补充类型">补充类型</h2>
<h3 id="294-翻转游戏-II（博弈型DP、记忆化递归）中等">294.翻转游戏 II（博弈型DP、记忆化递归）中等</h3>
<blockquote>
<p>你和朋友玩一个叫做「翻转游戏」的游戏。游戏规则如下：<br>
给你一个字符串 currentState ，其中只含 ‘+’ 和 ‘-’ 。你和朋友轮流将 连续 的两个 “++” 反转成 “–” 。当一方无法进行有效的翻转时便意味着游戏结束，则另一方获胜。默认每个人都会采取最优策略。<br>
请你写出一个函数来判定起始玩家 是否存在必胜的方案 ：如果存在，返回 true ；否则，返回 false 。<br>
示例 1：<br>
输入：currentState = “++++”<br>
输出：true<br>
解释：起始玩家可将中间的 “++” 翻转变为 “±-+” 从而得胜。<br>
示例 2：<br>
输入：currentState = “+”<br>
输出：false<br>
提示：<br>
1 &lt;= currentState.length &lt;= 60<br>
currentState[i] 不是 ‘+’ 就是 ‘-’</p>
</blockquote>
<p><strong>解决方案</strong><br>
记忆化搜索：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-attr">public</span>:<br>    bool <span class="hljs-title function_">canWin</span>(<span class="hljs-params">string s</span>) &#123;<br>        <span class="hljs-keyword">const</span> int N = s.<span class="hljs-title function_">size</span>();<br>        <span class="hljs-keyword">if</span> (N &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (win_.<span class="hljs-title function_">count</span>(s) &amp;&amp; win_[s]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; N - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;+&#x27;</span> &amp;&amp; s[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>                string flip = s.<span class="hljs-title function_">substr</span>(<span class="hljs-number">0</span>, i) + <span class="hljs-string">&quot;--&quot;</span> + s.<span class="hljs-title function_">substr</span>(i + <span class="hljs-number">2</span>);<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">canWin</span>(flip)) &#123;<br>                    win_[s] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><span class="hljs-attr">private</span>:<br>    unordered_map&lt;string, bool&gt; win_;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>回溯：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-attr">public</span>:<br>    bool <span class="hljs-title function_">canWin</span>(<span class="hljs-params">string currentState</span>) <br>    &#123;   <span class="hljs-comment">//回溯</span><br>        string s = currentState;       <br>        int n = s.<span class="hljs-title function_">size</span>();<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;+&#x27;</span> &amp;&amp; s[i+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;+&#x27;</span>)<br>            &#123;<br>                s[i] = <span class="hljs-string">&#x27;-&#x27;</span>;<br>                s[i+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;-&#x27;</span>;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-title function_">canWin</span> (s) == <span class="hljs-literal">false</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                s[i] = <span class="hljs-string">&#x27;+&#x27;</span>;             <br>                s[i+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;+&#x27;</span>;           <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h3 id="337-打家劫舍-III（树型DP）中等">337.打家劫舍 III（树型DP）中等</h3>
<blockquote>
<p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。<br>
除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。<br>
给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。<br>
示例 1:<br>
输入: root = [3,2,3,null,3,null,1]<br>
输出: 7<br>
解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7<br>
示例 2:<br>
输入: root = [3,4,5,1,3,null,1]<br>
输出: 9<br>
解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9<br>
提示：<br>
树的节点数在 [1, 104] 范围内<br>
0 &lt;= Node.val &lt;= 104</p>
</blockquote>
<p><strong>解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    public int <span class="hljs-title function_">rob</span>(<span class="hljs-params">TreeNode root</span>) &#123;<br>        int[] res = <span class="hljs-title function_">dp</span>(root);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res[<span class="hljs-number">0</span>], res[<span class="hljs-number">1</span>]);<br>    &#125;<br><br>    private int[] <span class="hljs-title function_">dp</span>(<span class="hljs-params">TreeNode root</span>) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> int[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        &#125;<br>        int[] left = <span class="hljs-title function_">dp</span>(root.<span class="hljs-property">left</span>);<br>        int[] right = <span class="hljs-title function_">dp</span>(root.<span class="hljs-property">right</span>);<br>        int selected = root.<span class="hljs-property">val</span> + left[<span class="hljs-number">1</span>] + right[<span class="hljs-number">1</span>];<br>        int notSelected = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>]) + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> int[]&#123;selected, notSelected&#125;;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="902-最大为-N-的数字组合（数位DP）困难">902 最大为 N 的数字组合（数位DP）困难</h3>
<blockquote>
<p>给定一个按 非递减顺序 排列的数字数组 digits 。你可以用任意次数 digits[i] 来写的数字。例如，如果 digits = [‘1’,‘3’,‘5’]，我们可以写数字，如 ‘13’, ‘551’, 和 ‘1351315’。<br>
返回 可以生成的小于或等于给定整数 n 的正整数的个数 。<br>
示例 1：<br>
输入：digits = [“1”,“3”,“5”,“7”], n = 100<br>
输出：20<br>
解释：<br>
可写出的 20 个数字是：<br>
1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.<br>
示例 2：<br>
输入：digits = [“1”,“4”,“9”], n = 1000000000<br>
输出：29523<br>
解释：<br>
我们可以写 3 个一位数字，9 个两位数字，27 个三位数字，<br>
81 个四位数字，243 个五位数字，729 个六位数字，<br>
2187 个七位数字，6561 个八位数字和 19683 个九位数字。<br>
总共，可以使用D中的数字写出 29523 个整数。<br>
示例 3:<br>
输入：digits = [“7”], n = 8<br>
输出：1<br>
提示：<br>
1 &lt;= digits.length &lt;= 9<br>
digits[i].length == 1<br>
digits[i] 是从 ‘1’ 到 ‘9’ 的数<br>
digits 中的所有值都 不同<br>
digits 按 非递减顺序 排列<br>
1 &lt;= n &lt;= 109</p>
</blockquote>
<p><strong>解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    public int <span class="hljs-title function_">atMostNGivenDigitSet</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] digits, int n</span>) &#123;<br>        char[] nc = <span class="hljs-title class_">String</span>.<span class="hljs-title function_">valueOf</span>(n).<span class="hljs-title function_">toCharArray</span>();<br>        int result = <span class="hljs-number">0</span>, ncl = nc.<span class="hljs-property">length</span>, dl = digits.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt; ncl; i++) result += <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(dl, i); <span class="hljs-comment">// 先对【非最高位】的其他位，可组装的数字进行统计</span><br>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; ncl; i++) &#123;<br>            boolean compareNext = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 是否需要对比下一个数字</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-title class_">String</span> digit : digits) &#123;<br>                char dc = digit.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 将String转换为char</span><br>                <span class="hljs-keyword">if</span> (dc &lt; nc[i]) result += <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(dl, ncl - i - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (dc == nc[i]) compareNext = <span class="hljs-literal">true</span>; <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!compareNext) <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ++result; <span class="hljs-comment">// 如果到最后1位依然满足compareNext，因为最后1位无法再向后对比了，所以最终结果+1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="233-数字-1-的个数（数位DP）困难">233 数字 1 的个数（数位DP）困难</h3>
<blockquote>
<p>给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。<br>
示例 1：<br>
输入：n = 13<br>
输出：6<br>
示例 2：<br>
输入：n = 0<br>
输出：0<br>
提示：<br>
0 &lt;= n &lt;= 109</p>
</blockquote>
<p><strong>解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    public int <span class="hljs-title function_">countDigitOne</span>(<span class="hljs-params">int n</span>) &#123;<br>        int high = n / <span class="hljs-number">10</span>, low = <span class="hljs-number">0</span>, digit = <span class="hljs-number">1</span>, cur = (n / digit) % <span class="hljs-number">10</span>, res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (high != <span class="hljs-number">0</span> || cur != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">0</span>) &#123;<br>                res += (high * digit);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span>) &#123;<br>                res += (high * digit + low + <span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res += (high + <span class="hljs-number">1</span>) * digit;<br>            &#125;<br>            low = cur * digit + low;<br>            cur = high % <span class="hljs-number">10</span>;<br>            digit *= <span class="hljs-number">10</span>;<br>            high /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="124-二叉树中的最大路径和（树形DP）困难">124 二叉树中的最大路径和（树形DP）困难</h3>
<blockquote>
<p>二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。<br>
路径和 是路径中各节点值的总和。<br>
给你一个二叉树的根节点 root ，返回其 最大路径和 。<br>
示例 1：<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5Cd7e03a69211f4d9aae9844312fe02ffc.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
输入：root = [1,2,3]<br>
输出：6<br>
解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6<br>
示例 2：<br>
输入：root = [-10,9,20,null,null,15,7]<br>
输出：42<br>
解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42<br>
提示：<br>
树中节点数目范围是 [1, 3 * 104]<br>
-1000 &lt;= Node.val &lt;= 1000</p>
</blockquote>
<p><strong>解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    private int res;<br>    <br>    public int <span class="hljs-title function_">maxPathSum</span>(<span class="hljs-params">TreeNode root</span>) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        res = <span class="hljs-title class_">Integer</span>.<span class="hljs-property">MIN_VALUE</span>;<br>        <span class="hljs-title function_">dp</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    private int <span class="hljs-title function_">dp</span>(<span class="hljs-params">TreeNode root</span>) &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 左边的最大路径</span><br>        int left = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-title function_">dp</span>(root.<span class="hljs-property">left</span>), <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 右边的最大路径</span><br>        int right = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-title function_">dp</span>(root.<span class="hljs-property">right</span>), <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 更新当前节点root的最大路径和</span><br>        res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, root.<span class="hljs-property">val</span> + left + right);<br>        <span class="hljs-comment">// 返回当前节点root到叶子节点的最大路径</span><br>        <span class="hljs-keyword">return</span> root.<span class="hljs-property">val</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(left, right);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="1349-参加考试的最大学生数（状态压缩DP）困难">1349 参加考试的最大学生数（状态压缩DP）困难</h3>
<blockquote>
<p>给你一个 m * n 的矩阵 seats 表示教室中的座位分布。如果座位是坏的（不可用），就用 ‘#’ 表示；否则，用 ‘.’ 表示。<br>
学生可以看到左侧、右侧、左上、右上这四个方向上紧邻他的学生的答卷，但是看不到直接坐在他前面或者后面的学生的答卷。请你计算并返回该考场可以容纳的同时参加考试且无法作弊的 最大 学生人数。<br>
学生必须坐在状况良好的座位上。<br>
示例 1：<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5Cdf104cc570584be081462e408e2e19dc.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
输入：seats = [[“#”,“.”,“#”,“#”,“.”,“#”],<br>
[“.”,“#”,“#”,“#”,“#”,“.”],<br>
[“#”,“.”,“#”,“#”,“.”,“#”]]<br>
输出：4<br>
解释：教师可以让 4 个学生坐在可用的座位上，这样他们就无法在考试中作弊。<br>
示例 2：<br>
输入：seats = [[“.”,“#”],<br>
[“#”,“#”],<br>
[“#”,“.”],<br>
[“#”,“#”],<br>
[“.”,“#”]]<br>
输出：3<br>
解释：让所有学生坐在可用的座位上。<br>
示例 3：<br>
输入：seats = [[“#”,“.”,“.”,“.”,“#”],<br>
[“.”,“#”,“.”,“#”,“.”],<br>
[“.”,“.”,“#”,“.”,“.”],<br>
[“.”,“#”,“.”,“#”,“.”],<br>
[“#”,“.”,“.”,“.”,“#”]]<br>
输出：10<br>
解释：让学生坐在第 1、3 和 5 列的可用座位上。<br>
提示：<br>
seats 只包含字符 ‘.’ 和’#’<br>
m == seats.length<br>
n == seats[i].length<br>
1 &lt;= m &lt;= 8<br>
1 &lt;= n &lt;= 8</p>
</blockquote>
<p><strong>解决方案</strong><br>
记忆化搜索</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-attr">public</span>:<br>int f[<span class="hljs-number">8</span>][<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">8</span>] , valid[<span class="hljs-number">8</span>];<br>    int <span class="hljs-title function_">dfs</span>(<span class="hljs-params">int x , int y</span>)&#123;<br>        int&amp; res = f[x][y];<br>        <span class="hljs-keyword">if</span>(~res) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-keyword">if</span>(!x)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!y) <span class="hljs-keyword">return</span> res = <span class="hljs-number">0</span>;<br>            int lb = y&amp;-y;<br>            <span class="hljs-keyword">return</span> res = <span class="hljs-title function_">dfs</span>(x , (y &amp; ~(lb*<span class="hljs-number">3</span>))) + <span class="hljs-number">1</span>;<br>        &#125;<br>        res = <span class="hljs-title function_">dfs</span>(x - <span class="hljs-number">1</span> , valid[x - <span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span>(int i = y ; i ; i = (i - <span class="hljs-number">1</span>) &amp; y)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!(i &amp; (i &gt;&gt; <span class="hljs-number">1</span>)))<br>            &#123;<br>                int t = valid[x - <span class="hljs-number">1</span>] &amp; ~((i &lt;&lt; <span class="hljs-number">1</span>) | (i &gt;&gt; <span class="hljs-number">1</span>));<br>                res = <span class="hljs-title function_">max</span>(res , <span class="hljs-title function_">dfs</span>(x - <span class="hljs-number">1</span>, t) + <span class="hljs-title function_">__builtin_popcount</span>(i));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    int <span class="hljs-title function_">maxStudents</span>(<span class="hljs-params">vector&lt;vector&lt;char&gt;&gt;&amp; seats</span>) &#123;<br>        int m = seats.<span class="hljs-title function_">size</span>() , n = seats[<span class="hljs-number">0</span>].<span class="hljs-title function_">size</span>();<br>        <span class="hljs-title function_">memset</span>(f , -<span class="hljs-number">1</span> , <span class="hljs-title function_">sizeof</span>(f));<br>        <span class="hljs-title function_">memset</span>(valid , <span class="hljs-number">0</span> , <span class="hljs-title function_">sizeof</span>(valid));<br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span> ; i &lt; m ; i++)<br>            <span class="hljs-keyword">for</span>(int j = <span class="hljs-number">0</span> ; j &lt; n ; j++)<br>                <span class="hljs-keyword">if</span>(seats[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) valid[i] |= (<span class="hljs-number">1</span> &lt;&lt; j);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">dfs</span>(m - <span class="hljs-number">1</span> , valid[m - <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>递推：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-attr">public</span>:<br>int f[<span class="hljs-number">8</span>][<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">8</span>] , valid[<span class="hljs-number">8</span>];<br>    int <span class="hljs-title function_">maxStudents</span>(<span class="hljs-params">vector&lt;vector&lt;char&gt;&gt;&amp; seats</span>) &#123;<br>        int m = seats.<span class="hljs-title function_">size</span>() , n = seats[<span class="hljs-number">0</span>].<span class="hljs-title function_">size</span>();<br>        <span class="hljs-title function_">memset</span>(f , <span class="hljs-number">0</span> , <span class="hljs-title function_">sizeof</span>(f));<br>        <span class="hljs-title function_">memset</span>(valid , <span class="hljs-number">0</span> , <span class="hljs-title function_">sizeof</span>(valid));<br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span> ; i &lt; m ; i++)<br>            <span class="hljs-keyword">for</span>(int j = <span class="hljs-number">0</span> ; j &lt; n ; j++)<br>                <span class="hljs-keyword">if</span>(seats[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) valid[i] |= (<span class="hljs-number">1</span> &lt;&lt; j);<br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">1</span> ; i &lt; (<span class="hljs-number">1</span> &lt;&lt; n) ; i++)<br>        &#123;<br>            int lb = i&amp;-i;<br>            f[<span class="hljs-number">0</span>][i] = f[<span class="hljs-number">0</span>][i &amp; ~(lb * <span class="hljs-number">3</span>)] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">1</span> ; i &lt; m ; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(int j = valid[i] ; j ; j = (j - <span class="hljs-number">1</span>) &amp; valid[i])&#123;<br>                f[i][j] = f[i - <span class="hljs-number">1</span>][valid[i - <span class="hljs-number">1</span>]];<br>                <span class="hljs-keyword">for</span>(int k = j ; k ; k = (k - <span class="hljs-number">1</span>) &amp; j)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(!(k &amp; (k &gt;&gt; <span class="hljs-number">1</span>)))&#123;<br>                        int t = valid[i - <span class="hljs-number">1</span>] &amp; ~(k &lt;&lt; <span class="hljs-number">1</span> | k &gt;&gt; <span class="hljs-number">1</span>);<br>                        f[i][j] = <span class="hljs-title function_">max</span>(f[i][j] , f[i - <span class="hljs-number">1</span>][t] + f[<span class="hljs-number">0</span>][k]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            f[i][<span class="hljs-number">0</span>] = f[i - <span class="hljs-number">1</span>][valid[i - <span class="hljs-number">1</span>]];<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[m - <span class="hljs-number">1</span>][valid[m - <span class="hljs-number">1</span>]];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="1259-不相交的握手（计数型DP）困难">1259 不相交的握手（计数型DP）困难</h3>
<blockquote>
<p>偶数 个人站成一个圆，总人数为 num_people 。每个人与除自己外的一个人握手，所以总共会有 num_people / 2 次握手。<br>
将握手的人之间连线，请你返回连线不会相交的握手方案数。<br>
由于结果可能会很大，请你返回答案 模 10^9+7 后的结果。<br>
示例 1：<br>
输入：num_people = 2<br>
输出：1<br>
示例 2：<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5C2b447e87799c4c82aa5397f93f9a7f4e.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
输入：num_people = 4<br>
输出：2<br>
解释：总共有两种方案，第一种方案是 [(1,2),(3,4)] ，第二种方案是 [(2,3),(4,1)] 。<br>
示例 3：<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E4%B9%8B%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA+%E5%8A%9B%E6%89%A3%E9%A2%98%EF%BC%89image%5C4a0764721d984343817fb18a3af8106e.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
输入：num_people = 6<br>
输出：5<br>
示例 4：<br>
输入：num_people = 8<br>
输出：14<br>
提示：<br>
2 &lt;= num_people &lt;= 1000<br>
num_people % 2 == 0</p>
</blockquote>
<p><strong>解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>        public int <span class="hljs-title function_">numberOfWays</span>(<span class="hljs-params">int numPeople</span>) &#123;<br>            int half = numPeople/<span class="hljs-number">2</span>;<br>            long[] dp = <span class="hljs-keyword">new</span> long[half+<span class="hljs-number">1</span>];<br>            long <span class="hljs-variable constant_">MOD</span> = (long) (<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>);<br>            dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">1</span>; i &lt;= half; i++)&#123;<br>                <span class="hljs-keyword">for</span>(int j = <span class="hljs-number">0</span>; j &lt; i-j-<span class="hljs-number">1</span>; j++)&#123;<br>                    dp[i]+=dp[j]*dp[i-j-<span class="hljs-number">1</span>]*<span class="hljs-number">2</span>;<br>                    dp[i] = dp[i]%<span class="hljs-variable constant_">MOD</span>;<br>                &#125;<br> <br>                <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)&#123;<br>                    dp[i]+=dp[i/<span class="hljs-number">2</span>]*dp[i-i/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>];<br>                    dp[i] = dp[i]%<span class="hljs-variable constant_">MOD</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> (int) dp[half];<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="664-奇怪的打印机（区间DP）困难">664 奇怪的打印机（区间DP）困难</h3>
<blockquote>
<p>有台奇怪的打印机有以下两个特殊要求：<br>
打印机每次只能打印由 同一个字符 组成的序列。<br>
每次可以在从起始到结束的任意位置打印新字符，并且会覆盖掉原来已有的字符。<br>
给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。<br>
示例 1：<br>
输入：s = “aaabbb”<br>
输出：2<br>
解释：首先打印 “aaa” 然后打印 “bbb”。<br>
示例 2：<br>
输入：s = “aba”<br>
输出：2<br>
解释：首先打印 “aaa” 然后在第二个位置打印 “b” 覆盖掉原来的字符 ‘a’。<br>
提示：<br>
1 &lt;= s.length &lt;= 100<br>
s 由小写英文字母组成</p>
</blockquote>
<p><strong>解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-attr">public</span>:<br>    int <span class="hljs-title function_">strangePrinter</span>(<span class="hljs-params">string s</span>) &#123;<br>        int n = s.<span class="hljs-title function_">length</span>();<br>        vector&lt;vector&lt;int&gt;&gt; <span class="hljs-title function_">f</span>(n, vector&lt;int&gt;(n));<br>        <span class="hljs-keyword">for</span> (int i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            f[i][i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (int j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                    f[i][j] = f[i][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    int minn = <span class="hljs-variable constant_">INT_MAX</span>;<br>                    <span class="hljs-keyword">for</span> (int k = i; k &lt; j; k++) &#123;<br>                        minn = <span class="hljs-title function_">min</span>(minn, f[i][k] + f[k + <span class="hljs-number">1</span>][j]);<br>                    &#125;<br>                    f[i][j] = minn;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="730-统计不同回文子字符串（区间DP）困难">730 统计不同回文子字符串（区间DP）困难</h3>
<blockquote>
<p>给你一个字符串 s ，返回 s 中不同的非空回文子序列个数 。由于答案可能很大，请返回对 109 + 7 取余 的结果。<br>
字符串的子序列可以经由字符串删除 0 个或多个字符获得。<br>
如果一个序列与它反转后的序列一致，那么它是回文序列。<br>
如果存在某个 i , 满足 ai != bi ，则两个序列 a1, a2, … 和 b1, b2, … 不同。<br>
示例 1：<br>
输入：s = ‘bccb’<br>
输出：6<br>
解释：6 个不同的非空回文子字符序列分别为：‘b’, ‘c’, ‘bb’, ‘cc’, ‘bcb’, ‘bccb’。<br>
注意：‘bcb’ 虽然出现两次但仅计数一次。<br>
示例 2：<br>
输入：s = ‘abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba’<br>
输出：104860361<br>
解释：共有 3104860382 个不同的非空回文子序列，104860361 是对 109 + 7 取余后的值。<br>
提示：<br>
1 &lt;= s.length &lt;= 1000<br>
s[i] 仅包含 ‘a’, ‘b’, ‘c’ 或 ‘d’</p>
</blockquote>
<p><strong>解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 需求</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> 给定一个字符串 S，找出 S 中不同的非空回文子序列个数，并返回该数字与 10^9 + 7 的模。 </span><br><span class="hljs-comment"> 通过从 S 中删除 0 个或多个字符来获得子字符序列。 </span><br><span class="hljs-comment"> 如果一个字符序列与它反转后的字符序列一致，那么它是回文字符序列。 </span><br><span class="hljs-comment"> 如果对于某个  i，A_i != B_i，那么 A_1, A_2, ... 和 B_1, B_2, ... 这两个字符序列是不同的。</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment"> 示例 1：</span><br><span class="hljs-comment"> 输入：</span><br><span class="hljs-comment"> S = &#x27;bccb&#x27;</span><br><span class="hljs-comment"> 输出：6</span><br><span class="hljs-comment"> 解释：</span><br><span class="hljs-comment"> 6 个不同的非空回文子字符序列分别为：&#x27;b&#x27;, &#x27;c&#x27;, &#x27;bb&#x27;, &#x27;cc&#x27;, &#x27;bcb&#x27;, &#x27;bccb&#x27;。</span><br><span class="hljs-comment"> 注意：&#x27;bcb&#x27; 虽然出现两次但仅计数一次。</span><br><span class="hljs-comment"> 示例 2： </span><br><span class="hljs-comment"> 输入：</span><br><span class="hljs-comment"> S = &#x27;abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba&#x27;</span><br><span class="hljs-comment"> 输出：104860361</span><br><span class="hljs-comment"> 解释：</span><br><span class="hljs-comment"> 共有 3104860382 个不同的非空回文子字符序列，对 10^9 + 7 取模为 104860361。</span><br><span class="hljs-comment">  </span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> 提示： </span><br><span class="hljs-comment"> 字符串 S 的长度将在[1, 1000]范围内。</span><br><span class="hljs-comment"> 每个字符 S[i] 将会是集合 &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;&#125; 中的某一个。</span><br><span class="hljs-comment">     </span><br><span class="hljs-comment"> gcc countPalindromicSubsequences.c -g -o a.exe -DDEBUG</span><br><span class="hljs-comment"> */</span><br>#include &lt;stdio.<span class="hljs-property">h</span>&gt;<br>#include &lt;assert.<span class="hljs-property">h</span>&gt;<br>#include &lt;stdlib.<span class="hljs-property">h</span>&gt;<br>#include &lt;stdbool.<span class="hljs-property">h</span>&gt;<br>#include &lt;string.<span class="hljs-property">h</span>&gt;<br> <br>#ifdef <span class="hljs-variable constant_">DEBUG</span><br>#define <span class="hljs-title function_">LOG</span>(fmt, args...) <span class="hljs-title function_">fprintf</span>(stdout, fmt, ##args)<br>#define <span class="hljs-title function_">BREAKER</span>(a, b, c) <span class="hljs-title function_">breaker</span>(a, b, c)<br>#<span class="hljs-keyword">else</span><br>#define <span class="hljs-title function_">LOG</span>(fmt,...)<br>#define <span class="hljs-title function_">BREAKER</span>(a, b, c)<br>#endif<br> <br>#define <span class="hljs-variable constant_">TRUE</span>        <span class="hljs-number">1</span><br>#define <span class="hljs-variable constant_">FALSE</span>       <span class="hljs-number">0</span><br> <br>#define <span class="hljs-title function_">MAX</span>(a, b) ((a) &gt; (b) ? (a) : (b))<br>#define <span class="hljs-title function_">MIN</span>(a, b) ((a) &gt; (b) ? (b) : (a))<br> <br> <br>int <span class="hljs-title function_">countPalindromicSubsequences</span>(<span class="hljs-params">char * S</span>)&#123;<br> <br>  <span class="hljs-keyword">if</span>(<span class="hljs-variable constant_">NULL</span> == S)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br> <br>  int ** dp = <span class="hljs-variable constant_">NULL</span>;<br>  int i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>  int size = <span class="hljs-title function_">strlen</span>(S);<br>  int left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>  int ret = <span class="hljs-number">0</span>;<br>    int M = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br> <br>  dp = (int ** )<span class="hljs-title function_">malloc</span>(size * (<span class="hljs-title function_">sizeof</span>(int *)));<br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>    dp[i] = (int *)<span class="hljs-title function_">malloc</span>(size * <span class="hljs-title function_">sizeof</span>(int)); <br>  &#125;	<br> <br>    <span class="hljs-comment">/*数组初始化都是0，这步骤很重要，因为dp算法，后面的计算要依赖前面的值和初始值*/</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; size; j++)&#123;<br>            dp[i][j] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br> <br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; size; i++)&#123;<br>    dp[i][i] = <span class="hljs-number">1</span>;<br>  &#125;<br> <br>  <span class="hljs-keyword">for</span>(i = size - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>    <span class="hljs-keyword">for</span>(j = i + <span class="hljs-number">1</span>; j &lt; size; j++)&#123;<br>      <span class="hljs-keyword">if</span>(S[i] == S[j]) &#123;<br>        left = i + <span class="hljs-number">1</span>;<br>        right = j - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right &amp;&amp; S[left] != S[i])&#123;<br>          left++;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(left &lt;= right &amp;&amp; S[right] != S[i])&#123;<br>          right--;<br>        &#125;<br> <br>        <span class="hljs-keyword">if</span>(left &gt; right) &#123; <span class="hljs-comment">/*不包含s[i]*/</span><br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == right)&#123; <span class="hljs-comment">/*包含1个s[i]*/</span><br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/*包含2个以上s[i]*/</span><br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] * <span class="hljs-number">2</span> - dp[left + <span class="hljs-number">1</span>][right - <span class="hljs-number">1</span>];<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = dp[i][j - <span class="hljs-number">1</span>] + dp[i + <span class="hljs-number">1</span>][j] - dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>      &#125;<br>            dp[i][j] = (dp[i][j] &lt; <span class="hljs-number">0</span>) ? dp[i][j] + M : dp[i][j] % M;<br>    &#125;<br>  &#125;<br>  <br>  ret = dp[<span class="hljs-number">0</span>][size - <span class="hljs-number">1</span>];<br>  <span class="hljs-title function_">free</span>(dp);<br>  dp = <span class="hljs-variable constant_">NULL</span>;<br>  <br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br> <br> <br> <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testcountPalindromicSubsequences</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)&#123;<br>  <br>  <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;\n************  testcountPalindromicSubsequences ************ \n&quot;</span>);<br>  int ret = <span class="hljs-number">0</span>;<br>  <br>#<span class="hljs-keyword">if</span> <span class="hljs-number">1</span><br> <br>  char * str1 = <span class="hljs-string">&quot;bccb&quot;</span>;<br>  ret = <span class="hljs-title function_">countPalindromicSubsequences</span>(str1);<br>  <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;The Palindromic Subsequences of str %s is %d\n&quot;</span>, str1, ret);<br> <br>  char * str2 = <span class="hljs-string">&quot;abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba&quot;</span>;<br>  ret = <span class="hljs-title function_">countPalindromicSubsequences</span>(str2);<br>  <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;The Palindromic Subsequences of str %s is %d\n&quot;</span>, str2, ret);<br> <br>#endif<br> <br>  <span class="hljs-keyword">return</span>; <br> <br> &#125;<br> <br> <br> int <span class="hljs-title function_">main</span>(<span class="hljs-params">int argc, char ** argv</span>)&#123;<br>  <span class="hljs-title function_">testcountPalindromicSubsequences</span>();<br> &#125;<br> <br> <br> <br> <br> <br></code></pre></td></tr></table></figure>
<h1>引用和参考文献</h1>
<p>1.《算法导论》<br>
2. 力扣</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/" class="category-chain-item">数据结构与算法分析</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>数据结构与算法分析：专题内容——动态规划2之例题讲解（代码详解+万字长文+算法导论+力扣题）</div>
      <div>https://mounthuangshan.github.io/数据结构与算法分析/数据结构与算法分析/数据结构与算法分析：专题内容——动态规划2之例题讲解（代码详解+万字长文+算法导论+力扣题）/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>黄山</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年3月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E5%9B%BE%E7%AE%97%E6%B3%95%E5%90%97%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%EF%BC%89/" title="数据结构与算法分析：你真的理解图算法吗——最小生成树算法（代码详解+万字长文）">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">数据结构与算法分析：你真的理解图算法吗——最小生成树算法（代码详解+万字长文）</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E5%9B%BE%E7%AE%97%E6%B3%95%E5%90%97%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%EF%BC%89/" title="数据结构与算法分析：你真的理解图算法吗——深度优先搜索（代码详解+万字长文）">
                        <span class="hidden-mobile">数据结构与算法分析：你真的理解图算法吗——深度优先搜索（代码详解+万字长文）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
