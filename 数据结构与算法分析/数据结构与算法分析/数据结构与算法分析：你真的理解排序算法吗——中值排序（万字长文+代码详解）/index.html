

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="黄山">
  <meta name="keywords" content="C/C++,Python,C#,Go,Web,AI,游戏开发,网络安全">
  
    <meta name="description" content="一、算法描述 在计算机科学中，分治是一种非常常见的方法，它将一个问题分成两个独立的子问题，每个子问题的规模是原始问题规模的一般。将两个原始数组细分成两个不同的子数组，每个子数组的大小是原始大小的一半，这两个子数组也同样需要排序。中值排序就这样递归的应用在每一个子数组上。值得注意的是， 中值排序并不是一个标准的排序算法名称，但我们可以基于“中值”这个概念来讨论可能相关的排序方法。在计算机科学和数学中">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法分析：你真的理解排序算法吗——中值排序（万字长文+代码详解）">
<meta property="og:url" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%90%97%E2%80%94%E2%80%94%E4%B8%AD%E5%80%BC%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%89/">
<meta property="og:site_name" content="钺不言">
<meta property="og:description" content="一、算法描述 在计算机科学中，分治是一种非常常见的方法，它将一个问题分成两个独立的子问题，每个子问题的规模是原始问题规模的一般。将两个原始数组细分成两个不同的子数组，每个子数组的大小是原始大小的一半，这两个子数组也同样需要排序。中值排序就这样递归的应用在每一个子数组上。值得注意的是， 中值排序并不是一个标准的排序算法名称，但我们可以基于“中值”这个概念来讨论可能相关的排序方法。在计算机科学和数学中">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%90%97%E2%80%94%E2%80%94%E4%B8%AD%E5%80%BC%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%90%97%E2%80%94%E2%80%94%E4%B8%AD%E5%80%BC%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%89image%5Ca188dc05c13148188f5fe86da2f16028.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%90%97%E2%80%94%E2%80%94%E4%B8%AD%E5%80%BC%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%90%97%E2%80%94%E2%80%94%E4%B8%AD%E5%80%BC%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%89image%5Ce8d70cf38c904922a2a325935817f621.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%90%97%E2%80%94%E2%80%94%E4%B8%AD%E5%80%BC%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%90%97%E2%80%94%E2%80%94%E4%B8%AD%E5%80%BC%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%89image%5C830e12feb7714428bb899c0830f1d2ff.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%90%97%E2%80%94%E2%80%94%E4%B8%AD%E5%80%BC%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%90%97%E2%80%94%E2%80%94%E4%B8%AD%E5%80%BC%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%89image%5C6dd25c32707249c79d35241a4b437beb.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%90%97%E2%80%94%E2%80%94%E4%B8%AD%E5%80%BC%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%90%97%E2%80%94%E2%80%94%E4%B8%AD%E5%80%BC%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%89image%5C7754dc3d21c94ea68aca716cee31b196.png">
<meta property="article:published_time" content="2025-03-18T18:19:05.000Z">
<meta property="article:modified_time" content="2025-03-18T18:19:05.850Z">
<meta property="article:author" content="黄山">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="Web">
<meta property="article:tag" content="AI">
<meta property="article:tag" content="游戏开发">
<meta property="article:tag" content="网络安全">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%90%97%E2%80%94%E2%80%94%E4%B8%AD%E5%80%BC%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%90%97%E2%80%94%E2%80%94%E4%B8%AD%E5%80%BC%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%89image%5Ca188dc05c13148188f5fe86da2f16028.png">
  
  
  
  <title>数据结构与算法分析：你真的理解排序算法吗——中值排序（万字长文+代码详解） - 钺不言</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"mounthuangshan.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="数据结构与算法分析：你真的理解排序算法吗——中值排序（万字长文+代码详解）"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-03-19 02:19" pubdate>
          2025年3月19日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          8.7k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          73 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">数据结构与算法分析：你真的理解排序算法吗——中值排序（万字长文+代码详解）</h1>
            
            
              <div class="markdown-body">
                
                <h1>一、算法描述</h1>
<p>在计算机科学中，分治是一种非常常见的方法，它将一个问题分成两个独立的子问题，每个子问题的规模是原始问题规模的一般。将两个原始数组细分成两个不同的子数组，每个子数组的大小是原始大小的一半，这两个子数组也同样需要排序。中值排序就这样递归的应用在每一个子数组上。值得注意的是， 中值排序并不是一个标准的排序算法名称，但我们可以基于“中值”这个概念来讨论可能相关的排序方法。在计算机科学和数学中，“中值”是指一组数值中间的那个数。如果这组数有奇数个元素，那么中值就是正中间的那个数；如果有偶数个元素，中值通常是中间两个数的平均值。当我们提到与“中值”相关的排序方法时，可能指的是以下几种情况之一：<br>
<strong>1.选择中值作为枢纽点的快速排序（Quick Sort）变种：</strong><br>
在快速排序算法中，选择一个合适的枢纽点对于算法的效率至关重要。一种常见的优化方法是使用三数取中法（Median of Three），即从数组的第一个、最后一个和中间位置的三个数中选取中值作为枢纽点，以此来减少数据偏斜对快速排序性能的影响。<br>
<strong>2.中值过滤排序：</strong><br>
这不是一种通用的排序算法，但在某些特定的应用场景下，如图像处理中的噪声去除，会用到中值滤波器。中值滤波器通过计算邻域内的像素值的中值来代替中心像素的值，从而达到平滑图像的效果。虽然这不是一种排序算法，但涉及到寻找一组数的中值的过程。<br>
<strong>3.寻找中值的算法：</strong><br>
寻找一组数的中值本身可以视为一个特殊的问题，可以通过不同的算法实现，比如快速选择算法（Quickselect）。这是一种用于找到第k小元素的选择算法，当k等于数组长度的一半时，该算法可以用来找到中值。快速选择算法的时间复杂度平均为O(n)，最坏情况下为O(n^2)。<br>
<strong>以下是中值排序的详细过程：</strong></p>
<h2 id="一、选择中值作为枢轴">一、选择中值作为枢轴</h2>
<p>子数组划分：<br>
将待排序数组划分为若干个子数组，每个子数组包含固定数量的元素（例如5个）。<br>
对于每个子数组，找到其真实的中值元素（即排序后位于中间的元素）。<br>
中值选择：<br>
从所有子数组的中值元素中，再次找到中值作为整个数组的枢轴。这一步可以使用快速选择算法或任何高效的查找中值的方法。</p>
<h2 id="二、划分操作">二、划分操作</h2>
<p>初始枢轴位置：<br>
将选定的中值枢轴元素放置到数组的某个位置（通常是数组的末尾或某个空位），以便进行后续的划分操作。<br>
双向扫描：<br>
使用两个指针（通常称为“哨兵”）从数组的两端向中间扫描。<br>
一个指针用于查找小于枢轴的元素，另一个指针用于查找大于枢轴的元素。<br>
当两个指针相遇或交错时，划分操作完成。<br>
元素交换：<br>
在扫描过程中，将小于枢轴的元素与左侧指针所指向的元素交换，将大于枢轴的元素与右侧指针所指向的元素交换。<br>
确保枢轴元素最终位于其最终排序位置（即左侧所有元素都小于它，右侧所有元素都大于或等于它）。</p>
<h2 id="三、递归排序">三、递归排序</h2>
<p>子数组划分：<br>
根据枢轴元素的位置，将数组划分为两个子数组：左侧子数组（包含所有小于枢轴的元素）和右侧子数组（包含所有大于或等于枢轴的元素）。<br>
递归调用：<br>
对左侧子数组和右侧子数组分别进行递归排序。<br>
递归调用中值排序算法，直到子数组的大小减少到足够小（例如，小于某个阈值），此时可以使用其他排序算法（如插入排序）进行排序。</p>
<h2 id="四、合并结果">四、合并结果</h2>
<p>无需显式合并：<br>
与归并排序不同，中值排序在递归过程中直接对子数组进行排序，因此无需显式地合并结果。<br>
递归调用返回后，整个数组已经是有序的。</p>
<h2 id="五、优化与注意事项">五、优化与注意事项</h2>
<p>处理小数组：<br>
对于较小的子数组，可以使用其他排序算法（如插入排序）进行排序，以提高效率。<br>
避免最坏情况：<br>
通过选择中值作为枢轴，中值排序可以显著降低最坏情况（即划分极度不平衡）的发生概率。<br>
并行化：<br>
尽管中值排序的并行化相对复杂，但在硬件支持并行处理的情况下，可以考虑将排序任务分解为多个子任务，并在不同的处理器核心上并行执行。<br>
内存使用：<br>
中值排序通常是原地排序算法，即它不需要额外的内存空间来存储排序过程中的中间结果。<br>
综上可以看出，中值排序通过选择子数组的中值作为枢轴来确保划分后的两个子数组尽可能平衡，从而减少了最坏情况下的比较次数和移动次数。</p>
<h1>二、复杂度分析</h1>
<p><strong>快速排序（使用中值作为枢纽点）</strong><br>
1.快速排序的基本时间复杂度：<br>
最佳和平均情况下，快速排序的时间复杂度为 O(n log n)。<br>
最坏情况下，如果每次选择的枢纽点都是最小或最大值，时间复杂度为 O($n^2$)。<br>
2.使用中值作为枢纽点：<br>
如果使用三数取中法（Median of Three）选择枢纽点，可以显著提高快速排序的性能，尤其是在数据已经部分排序的情况下。使用中值作为枢纽点，可以保证每次划分都比较均衡，从而使得快速排序在大多数情况下接近最佳情况，时间复杂度为 O(n log n)。<br>
<strong>快速选择算法（用于寻找中值）</strong><br>
1.快速选择算法的基本时间复杂度：<br>
平均情况下，快速选择算法的时间复杂度为 O(n)。<br>
最坏情况下，时间复杂度为 O($n^2$)，但这在实践中很少发生。<br>
2.改进的快速选择算法：<br>
使用中值的中值（Median of Medians）作为枢纽点，可以保证快速选择算法在最坏情况下的时间复杂度为 O(n)。<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%90%97%E2%80%94%E2%80%94%E4%B8%AD%E5%80%BC%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%89image%5Ca188dc05c13148188f5fe86da2f16028.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h1>三、适用情况</h1>
<ol>
<li>快速排序（使用中值作为枢纽点）<br>
适用环境：<br>
数据分布不均匀：当数据已经部分排序或存在大量重复值时，使用中值作为枢纽点可以避免最坏情况的发生，提高算法的性能。<br>
大数据集：快速排序是一种高效的排序算法，适用于大规模数据集的排序任务。<br>
内存限制：快速排序是原地排序算法，不需要额外的存储空间，适合内存受限的环境。</li>
<li>快速选择算法（用于寻找中值）<br>
适用环境：<br>
寻找第 k 小元素：快速选择算法特别适用于需要找到数组中第 k 小元素的场景，例如寻找中值（k = n/2）。<br>
统计分析：在统计学和数据分析中，经常需要找到一组数据的中值，快速选择算法可以高效地完成这一任务。<br>
实时系统：由于快速选择算法的平均时间复杂度为 O(n)，它适合用于需要快速响应的实时系统。</li>
<li>中值滤波器（图像处理）<br>
适用环境：<br>
图像去噪：中值滤波器常用于去除图像中的椒盐噪声，因为它能够保留边缘信息，同时平滑噪声。<br>
信号处理：在信号处理中，中值滤波器可以用于去除脉冲噪声，保持信号的完整性。<br>
医学成像：在医学成像领域，中值滤波器可以用于改善图像质量，减少噪声干扰。</li>
<li>堆排序（使用中值优化）<br>
适用环境：<br>
需要稳定排序：堆排序是一种稳定的排序算法，适用于需要保持相等元素相对顺序的场景。<br>
多线程环境：堆排序可以并行化，适用于多线程或多处理器环境。<br>
外部排序：在处理大规模数据集时，可以结合外部排序技术，使用堆排序进行局部排序。<br>
总结<br>
快速排序（使用中值作为枢纽点）：适用于数据分布不均匀、大数据集和内存限制的环境。<br>
快速选择算法（用于寻找中值）：适用于需要快速找到第 k 小元素、统计分析和实时系统的场景。<br>
中值滤波器：适用于图像去噪、信号处理和医学成像等领域。<br>
堆排序（使用中值优化）：适用于需要稳定排序、多线程环境和外部排序的场景。</li>
</ol>
<h1>四、算法实现</h1>
<p>使用中值排序的关键在于高效地从无序数组中选择出中值元素。我们先不回答这个问题,我们来看看另一个在计算机科学中非常典型的问题,这个问题最终能够给我们的初始问题一个很好的解决方案。想象一下一个人给了你一个函数p=partition(left,right,  pivotIndex),这个函数将元素A[pivotlndex]作为一个特殊的中枢值,其将数组A[left,right]分成两半,其中一半中所有元素都小于等于中值元素,另一半的所有元素都大于等于中值元素。注意leftspivotlndexsright,返回值p是p在子序列A[left,righr]的最终位置。下面是这个partition函数的C实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs javascript">#include&lt;stdio.<span class="hljs-property">h</span>&gt;<br><br><span class="hljs-comment">/*在线性时间, 根据给定的中枢值重新组合子序列ar[left, right],</span><br><span class="hljs-comment">将中枢值存储在其正确的位置store, 确保所有在子序列ar[left, store)中的</span><br><span class="hljs-comment">元素 &lt;= pivot并且所有在ar[store + 1, right]中的元素 &gt; pivot。*/</span><br><br>int <span class="hljs-title function_">cmp</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* x, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* y</span>)<br>&#123;<br>  int standard;<br>  <span class="hljs-comment">//这里比较时也是需要做强制类型转换</span><br>  standard = *(int*)x - *(int*)y;<br><br>  <span class="hljs-keyword">return</span> standard;<br>&#125;<br><br>int <span class="hljs-title function_">partition</span>(<span class="hljs-params"><span class="hljs-keyword">void</span> **ar,int(*cmp)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *),int left,int right,int pivotIndex</span>)<br>&#123;<br>  int idx;<br>  int store;<br>  <span class="hljs-keyword">void</span>* pivot = ar[pivotIndex];<br>  <span class="hljs-comment">//将中枢值移动到数组结尾</span><br>  <span class="hljs-keyword">void</span>* tmp = ar[right];<br>  ar[right] = ar[pivotIndex];<br>  ar[pivotIndex] = tmp;<br>  <span class="hljs-comment">//将所有小于等于中枢值的元素都会移动到数组的前面，然后将中枢值插在它们后面</span><br>  store = left;<br>  <span class="hljs-keyword">for</span> (idx = left;idx &lt; right;idx++)<br>  &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-title function_">cmp</span>(ar[idx],pivot)&lt;=<span class="hljs-number">0</span>)<br>    &#123;<br>      tmp = ar[idx];<br>      ar[idx] = ar[store];<br>      ar[store] = tmp;<br>      store++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//又一次交换，中枢值插在后面</span><br>  tmp = ar[right];<br>  ar[right] = ar[store];<br>  ar[store] = tmp;<br>  <span class="hljs-keyword">return</span> store;<br>&#125;<br><br>int <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)<br>&#123;<br>  int a = <span class="hljs-number">5</span>;<br>  int b = <span class="hljs-number">7</span>;<br>  int c = <span class="hljs-number">4</span>;<br>  int d = <span class="hljs-number">6</span>;<br>  int e = <span class="hljs-number">3</span>;<br>  int f = <span class="hljs-number">8</span>;<br>  int g = <span class="hljs-number">1</span>;<br>  int h = <span class="hljs-number">0</span>;<br>  int i = <span class="hljs-number">9</span>;<br>  int j = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">void</span>* base[<span class="hljs-number">10</span>] = &#123; &amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f,&amp;g,&amp;h,&amp;i,&amp;j &#125;;<br>  int n = <span class="hljs-title function_">sizeof</span>(base) / <span class="hljs-title function_">sizeof</span>(base[<span class="hljs-number">0</span>]);<br>  <span class="hljs-title function_">partition</span>(base,cmp,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>,<span class="hljs-number">5</span>);<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;i++)<br>  &#123;<br>    <span class="hljs-comment">//printf(&quot;%d&quot;,*num[i]);这是错误的打印void数组方法，下面是正确的：</span><br>    <span class="hljs-comment">//将void*转换为int*并解引用  </span><br>    int* intPtr = (int*)base[i];<br>    <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;base[%d] = %d\n&quot;</span>, i, *intPtr);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">我们是如何通过使用partition更加高效地选择中值呢?首先,让我们看看这个方法的</span><br><span class="hljs-comment">结果,以一个16个元素的无序数组为例。首先第一步是将中枢值和最右边的元素交换。</span><br><span class="hljs-comment">在partition每一次执行循环的时候,关键的变量如下图所示。store这个值用来区分</span><br><span class="hljs-comment">执行的是哪一次循环.下图每一次执行partition的循环都挑选出来了一个A[idx],这</span><br><span class="hljs-comment">个元素小于或者等于中枢值(在这里是元素“06”)。一旦不再有元素小于或者等于中枢</span><br><span class="hljs-comment">值,store这个位置的元素将会和最右边的元素进行交换,这样安全地将中枢值放到了</span><br><span class="hljs-comment">适当的位置。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%90%97%E2%80%94%E2%80%94%E4%B8%AD%E5%80%BC%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%89image%5Ce8d70cf38c904922a2a325935817f621.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>partition(0,15,9)执行并且返回p=5,你能看到A[left.p)中的所有元素都小于等于中枢值,反之,A[p+1,right]中的元素都大于等于中枢值。选择出中值元素的过程是怎样的呢?注意到p是在中值在有序数组的最终位置的左侧(标记为“中值位置”的黑色元素)。因此,p的左边没有元素会是中值!我们只需要反复调用partition(这次是一个不同的在A[p+1,right]中的A[pivotlndex])知道其返回p等于中值位置。注意到partition高效地将数组组织成两个不同的子数组,但是并没有排序每一个元素。partition返回中枢值的位置p,p能够用来递归地在A[left,righn]中检查第k个元素,<br>
对于任何1&lt;=k&lt;=right-left+1,如下所示:<br>
如果k=p+1<br>
选择的中值元素是第k个值(回忆一下数组索引是从0开始的,但是这里的k却是从1开始)。<br>
如果k&lt;p+1<br>
A的第k个元素是A[left.p]的第k个元素。<br>
如果k&gt;p+1<br>
A的第k个元素是A[p+1,right]的第k-p个元素。<br>
上图的目标是确定A的中值位置,或者换句话说,第八大(k=8)的元素。得到了调用partition的返回值p=5,我们下一步递归地在A[p+1,righi]中寻找第二大的元素。这个定义反复地在递归中使用,不过它也能够选代地在一个循环而不是在一个尾递归函数中定义(可以参考代码库中的这个例子)。selectkth是一个平均时间为线性的函数,给定一个适当的pivotIndex,其返回了数组ar中的第k个元素,下面是它的一个实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs javascript">#include&lt;stdio.<span class="hljs-property">h</span>&gt;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">在ar中寻找第k大元素的位置的算法,其在平均情况下为线性时间。</span><br><span class="hljs-comment">A随着计算的进行不断被修改更新。注意1kright-left+1。</span><br><span class="hljs-comment">比较函数cmp将会严格地比较元素。最坏情况下性能为二次方,即o(n2)。</span><br><span class="hljs-comment">*/</span><br><br>int <span class="hljs-title function_">cmp</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* x, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* y</span>)<br>&#123;<br>  int standard;<br>  <span class="hljs-comment">//这里比较时也是需要做强制类型转换</span><br>  standard = *(int*)x - *(int*)y;<br><br>  <span class="hljs-keyword">return</span> standard;<br>&#125;<br><br>int <span class="hljs-title function_">partition</span>(<span class="hljs-params"><span class="hljs-keyword">void</span>** ar, int(*cmp)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*), int left, int right, int pivotIndex</span>)<br>&#123;<br>  int idx;<br>  int store;<br>  <span class="hljs-keyword">void</span>* pivot = ar[pivotIndex];<br>  <span class="hljs-comment">//将中枢值移动到数组结尾</span><br>  <span class="hljs-keyword">void</span>* tmp = ar[right];<br>  ar[right] = ar[pivotIndex];<br>  ar[pivotIndex] = tmp;<br>  <span class="hljs-comment">//将所有小于等于中枢值的元素都会移动到数组的前面，然后将中枢值插在它们后面</span><br>  store = left;<br>  <span class="hljs-keyword">for</span> (idx = left;idx &lt; right;idx++)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">cmp</span>(ar[idx], pivot) &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>      tmp = ar[idx];<br>      ar[idx] = ar[store];<br>      ar[store] = tmp;<br>      store++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//又一次交换，中枢值插在后面</span><br>  tmp = ar[right];<br>  ar[right] = ar[store];<br>  ar[store] = tmp;<br>  <span class="hljs-comment">//返回中值的位置</span><br>  <span class="hljs-keyword">return</span> store;<br>&#125;<br><br>int <span class="hljs-title function_">selectpivotIndex</span>(<span class="hljs-params"><span class="hljs-keyword">void</span>** ar, int left, int right</span>) <br>&#123;<br>  <span class="hljs-comment">// 计算中间位置的索引</span><br>  int mid = (left + right) / <span class="hljs-number">2</span>;<br><br>  <span class="hljs-comment">// 获取左端、中间和右端的值</span><br>  int left_val = *((int*)ar[left]);<br>  int mid_val = *((int*)ar[mid]);<br>  int right_val = *((int*)ar[right]);<br><br>  <span class="hljs-comment">// 找出这三个值的中值</span><br>  <span class="hljs-keyword">if</span> ((left_val &lt; mid_val &amp;&amp; mid_val &lt; right_val) || (right_val &lt; mid_val &amp;&amp; mid_val &lt; left_val))<br>  &#123;<br>    <span class="hljs-keyword">return</span> mid;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((mid_val &lt; left_val &amp;&amp; left_val &lt; right_val) || (right_val &lt; left_val &amp;&amp; left_val &lt; mid_val)) <br>  &#123;<br>    <span class="hljs-keyword">return</span> left;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> right;<br>  &#125;<br>&#125;<br><br>int <span class="hljs-title function_">selectKth</span>(<span class="hljs-params"><span class="hljs-keyword">void</span>** ar, int(*cmp)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*),int k,int left,int right</span>)<br>&#123;<br>  <span class="hljs-comment">//找出中值</span><br>  int idx = <span class="hljs-title function_">selectpivotIndex</span>(ar, left, right);<br>  <span class="hljs-comment">//进行排序</span><br>  int pivotIndex = <span class="hljs-title function_">partition</span>(ar, cmp, left, right, idx);<br>  <span class="hljs-keyword">if</span> (left + k - <span class="hljs-number">1</span> == pivotIndex)<br>  &#123;<br>    <span class="hljs-keyword">return</span> pivotIndex;<br>  &#125;<br>  <span class="hljs-comment">//继续循环，并缩小范围，如果我们在中值的左边，那么k将不变。</span><br>  <span class="hljs-keyword">if</span> (left + k - <span class="hljs-number">1</span> &lt; pivotIndex)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">selectKth</span>(ar, cmp, k, left, pivotIndex - <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">selectKth</span>(ar, cmp, k - (pivotIndex - left + <span class="hljs-number">1</span>), pivotIndex + <span class="hljs-number">1</span>, right);<br>  &#125;<br><br>&#125;<br><br>int <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)<br>&#123;<br>  int a = <span class="hljs-number">5</span>;<br>  int b = <span class="hljs-number">7</span>;<br>  int c = <span class="hljs-number">4</span>;<br>  int d = <span class="hljs-number">6</span>;<br>  int e = <span class="hljs-number">3</span>;<br>  int f = <span class="hljs-number">8</span>;<br>  int g = <span class="hljs-number">1</span>;<br>  int h = <span class="hljs-number">0</span>;<br>  int i = <span class="hljs-number">9</span>;<br>  int j = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">void</span>* base[<span class="hljs-number">10</span>] = &#123; &amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f,&amp;g,&amp;h,&amp;i,&amp;j &#125;;<br>  int n = <span class="hljs-title function_">sizeof</span>(base) / <span class="hljs-title function_">sizeof</span>(base[<span class="hljs-number">0</span>]);<br>  int z=<span class="hljs-title function_">selectKth</span>(base, cmp,<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>  <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;base[%d] = %d\n&quot;</span>,z, *(int*)base[z]);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>由于selectKth的特殊尾递归结构，一个非递归的实现会更直接一点。现在将讨论回到中值排序上来,你也许会非常惊讶,因为注意到无论pivotlndex的值是多少,selectkth都能很好地运行。当selectkth返回的时候,切分已经完成了。也就是说,左半部的元素都是小于或者等于中值的,反之,右半部的元素都是大于等于中值的。<br>
下面的中值排序函数将要对A[0,n-1]进行排序,也是结合上面的函数的完整排序实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs javascript">#include&lt;stdio.<span class="hljs-property">h</span>&gt;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">在ar中寻找第k大元素的位置的算法,其在平均情况下为线性时间。</span><br><span class="hljs-comment">A随着计算的进行不断被修改更新。注意1kright-left+1。</span><br><span class="hljs-comment">比较函数cmp将会严格地比较元素。最坏情况下性能为二次方,即o(n2)。</span><br><span class="hljs-comment">*/</span><br><br>int <span class="hljs-title function_">cmp</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* x, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* y</span>)<br>&#123;<br>  int standard;<br>  <span class="hljs-comment">//这里比较时也是需要做强制类型转换</span><br>  standard = *(int*)x - *(int*)y;<br><br>  <span class="hljs-keyword">return</span> standard;<br>&#125;<br><br>int <span class="hljs-title function_">partition</span>(<span class="hljs-params"><span class="hljs-keyword">void</span>** ar, int(*cmp)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*), int left, int right, int pivotIndex</span>)<br>&#123;<br>  int idx;<br>  int store;<br>  <span class="hljs-keyword">void</span>* pivot = ar[pivotIndex];<br>  <span class="hljs-comment">//将中枢值移动到数组结尾</span><br>  <span class="hljs-keyword">void</span>* tmp = ar[right];<br>  ar[right] = ar[pivotIndex];<br>  ar[pivotIndex] = tmp;<br>  <span class="hljs-comment">//将所有小于等于中枢值的元素都会移动到数组的前面，然后将中枢值插在它们后面</span><br>  store = left;<br>  <span class="hljs-keyword">for</span> (idx = left;idx &lt; right;idx++)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">cmp</span>(ar[idx], pivot) &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>      tmp = ar[idx];<br>      ar[idx] = ar[store];<br>      ar[store] = tmp;<br>      store++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//又一次交换，中枢值插在后面</span><br>  tmp = ar[right];<br>  ar[right] = ar[store];<br>  ar[store] = tmp;<br>  <span class="hljs-comment">//返回中值的位置</span><br>  <span class="hljs-keyword">return</span> store;<br>&#125;<br><br>int <span class="hljs-title function_">selectpivotIndex</span>(<span class="hljs-params"><span class="hljs-keyword">void</span>** ar, int left, int right</span>)<br>&#123;<br>  <span class="hljs-comment">// 计算中间位置的索引</span><br>  int mid = (left + right) / <span class="hljs-number">2</span>;<br><br>  <span class="hljs-comment">// 获取左端、中间和右端的值</span><br>  int left_val = *((int*)ar[left]);<br>  int mid_val = *((int*)ar[mid]);<br>  int right_val = *((int*)ar[right]);<br><br>  <span class="hljs-comment">// 找出这三个值的中值</span><br>  <span class="hljs-keyword">if</span> ((left_val &lt; mid_val &amp;&amp; mid_val &lt; right_val) || (right_val &lt; mid_val &amp;&amp; mid_val &lt; left_val))<br>  &#123;<br>    <span class="hljs-keyword">return</span> mid;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((mid_val &lt; left_val &amp;&amp; left_val &lt; right_val) || (right_val &lt; left_val &amp;&amp; left_val &lt; mid_val))<br>  &#123;<br>    <span class="hljs-keyword">return</span> left;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> right;<br>  &#125;<br>&#125;<br><br>int <span class="hljs-title function_">selectKth</span>(<span class="hljs-params"><span class="hljs-keyword">void</span>** ar, int(*cmp)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*), int k, int left, int right</span>)<br>&#123;<br>  <span class="hljs-comment">//三数取中法找出中值</span><br>  int idx = <span class="hljs-title function_">selectpivotIndex</span>(ar, left, right);<br>  <span class="hljs-comment">//进行排序，返回排序好的数组的中间值位置</span><br>  int pivotIndex = <span class="hljs-title function_">partition</span>(ar, cmp, left, right, idx);<br>  <span class="hljs-comment">//这里的比较很巧妙，排序好的数组的中间值的位置就是第几大，通过这种方法无需将数组完全排序完成就能找到第k大的元素</span><br>  <span class="hljs-keyword">if</span> (left + k - <span class="hljs-number">1</span> == pivotIndex)<br>  &#123;<br>    <span class="hljs-keyword">return</span> pivotIndex;<br>  &#125;<br>  <span class="hljs-comment">//继续循环，并缩小范围，如果我们在中值的左边，那么k将不变。</span><br>  <span class="hljs-keyword">if</span> (left + k - <span class="hljs-number">1</span> &lt; pivotIndex)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">selectKth</span>(ar, cmp, k, left, pivotIndex - <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">selectKth</span>(ar, cmp, k - (pivotIndex - left + <span class="hljs-number">1</span>), pivotIndex + <span class="hljs-number">1</span>, right);<br>  &#125;<br><br>&#125;<br><br><span class="hljs-comment">//使用medianSort方法排序ar[left,right]。比较函数cmp将会严格的比较元素。</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">mediansort</span>(<span class="hljs-params"><span class="hljs-keyword">void</span>** ar, int(*cmp)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*), int left, int right</span>)<br>&#123;<br>  <span class="hljs-comment">//如果待排序的子数组只有一个（或者更少）元素，返回。</span><br>  <span class="hljs-keyword">if</span> (right &lt;= left)<br>  &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">//得到中点和中值元素位置k，(1&lt;=k&lt;=right-left-1)</span><br>  int mid = (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>  int me = <span class="hljs-title function_">selectKth</span>(ar, cmp, mid + <span class="hljs-number">1</span>, left, right);<br>  <span class="hljs-title function_">mediansort</span>(ar, cmp, left, left + mid - <span class="hljs-number">1</span>);<br>  <span class="hljs-title function_">mediansort</span>(ar, cmp, left + mid + <span class="hljs-number">1</span>, right);<br>&#125;<br><br>int <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)<br>&#123;<br>  int a = <span class="hljs-number">5</span>;<br>  int b = <span class="hljs-number">7</span>;<br>  int c = <span class="hljs-number">4</span>;<br>  int d = <span class="hljs-number">6</span>;<br>  int e = <span class="hljs-number">3</span>;<br>  int f = <span class="hljs-number">8</span>;<br>  int g = <span class="hljs-number">1</span>;<br>  int h = <span class="hljs-number">0</span>;<br>  int i = <span class="hljs-number">9</span>;<br>  int j = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">void</span>* base[<span class="hljs-number">10</span>] = &#123; &amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f,&amp;g,&amp;h,&amp;i,&amp;j &#125;;<br>  int n = <span class="hljs-title function_">sizeof</span>(base) / <span class="hljs-title function_">sizeof</span>(base[<span class="hljs-number">0</span>]);<br>  int z = <span class="hljs-title function_">selectKth</span>(base, cmp, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>  <span class="hljs-title function_">mediansort</span>(base, cmp, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;i++)<br>  &#123;<br>    <span class="hljs-comment">//printf(&quot;%d&quot;,*num[i]);这是错误的打印void数组方法，下面是正确的：</span><br>    <span class="hljs-comment">// 将void*转换为int*并解引用  </span><br>    int* intPtr = (int*)base[i];<br>    <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;base[%d] = %d\n&quot;</span>, i, *intPtr);<br>  &#125;<br>  <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;中值为base[%d] = % d\n&quot;</span>, z, *(int*)base[z]);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>五、算法优化</h1>
<p>中值排序做了很多不需要做的事。虽然生成的子问题是最优的（因为它们都是原始问题规模的一半左右），但产生子问题的额外开销应该考虑。在快速排序中可以看到，随机的选择pivotlndex就足够了，这样就能够避免退化的情况（如果原始数组是有序的，这种情况很可能会发生）。<br>
中值排序保证递归子问题的规模都大致一样。这就意味着中值排序的平均性能是O(n  log  n)。但是,在最坏情况下,partition函数执行时间为0(n2),这样就使得中值排序的性能退化到O(n2)。因此,当n个元素几乎有序的时候,即使待递归排序的子问题是非常理想化的,总体性能也会受到影响。我们在中值排序中使用一个随机化的selectPivotIndex函数,来对最坏情况的数据进行测试,在这些数据上,selectPivotIndex总是返回最左边的位置。我们进行了10次试验,最好和最坏的结果都被排除,剩余8次实验的平均结果见下表。注意观察在最坏情况下,随着问题规模的加倍,中值排序的时间增加了4倍多,这就是经典的二次方算法的标志。<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%90%97%E2%80%94%E2%80%94%E4%B8%AD%E5%80%BC%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%89image%5C830e12feb7714428bb899c0830f1d2ff.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
因此,看起来,任何依赖于切分的排序算法的最坏情况都会退化到O(n2)。幸运的是,有一个线性时间的选择算法,能够确保最坏情况仍然是O(n  log  n)。这个选择算法被称为BFPRT(Blum-Floyd-Pratt-Rivest-Tarjan)算法(Blum等,1973),其性能见上表的最后一列。在统一生成的随机化数据上执行10次试验,最好和最坏的结果都被舍弃。下表给出了使用不同的切分子数组方法的中值排序的性能。<br>
平均情况下,使用随机中枢选择算法的计算趋势线(见下表)是:<br>
$1.82<em>10^{-7}n</em>\mathrm{log} (n)$<br>
而BFPRT的趋势线是:<br>
$2.35<em>10^{-6}<em>n</em>log(n)$<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%90%97%E2%80%94%E2%80%94%E4%B8%AD%E5%80%BC%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%89image%5C6dd25c32707249c79d35241a4b437beb.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
因为复杂的BFPRT算法的常数更高,所以10次运行都比较缓慢,即便如此其平均情况下的执行时间为O(nlogn)。<br>
BFPRT选择算法能够保证性能稳定,因为这个算法在一个无序数组中选择的是一个可接受的近似中值。简单来说,BFPRT将含有n个元素的数组聚集成n/4个集合,每个集合有4个元素(忽略不能组成一个大小为4的集合的元素,)。BFPRT然后寻找到每一个4元集合的中值,这一步的开销是多少?从早前的下图的二叉决策树中,你能够回忆起来只需要5次比较就能给排序4个元素,所以这一步的开销最多是(n/4)<em>5=1.25</em>n,仍然是O(n)。得到这些4元集合,每一个中值是其第三个元素。我们将这些集合的中值作为集合M,M的中值(me)和原始集合A的中值非常近似。BFPRT算法用到的一个小技巧是递归地在集合M上使用BFPRT算法。编码这个算法是非常有意思的(例4-6是我们的实现,在这里我们通过递归地寻找固定距离、间隔的元素,最少化了元素交换操作)。注意到A中元素的3</em>n/8个是显而易见的小于或者等于me,2*n/8个也是显而易见的大于或者等于me。因此我们能够保证切分的递归调用在左子数组不会坏于37.5%,在右子数组不会坏于75%。这样就保证了BFPRT的总体最坏性能是O(n)。<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%90%97%E2%80%94%E2%80%94%E4%B8%AD%E5%80%BC%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87+%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%89image%5C7754dc3d21c94ea68aca716cee31b196.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
下面是BFPRT算法的C语言实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br></pre></td><td class="code"><pre><code class="hljs javascript">#include&lt;stdio.<span class="hljs-property">h</span>&gt;<br>#include&lt;stdlib.<span class="hljs-property">h</span>&gt;<br><br>#define <span class="hljs-title function_">SWAP</span>(<span class="hljs-params">a,p1,p2,type</span>)&#123;\<br>  type tmp_=a[p1];\<br>    a[p1]=a[p2];\<br>    a[p2] = tmp_;\<br>&#125;<br><br>int <span class="hljs-title function_">cmp</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* x, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* y</span>)<br>&#123;<br>    int standard;<br>    <span class="hljs-comment">//这里比较时也是需要做强制类型转换</span><br>    standard = *(int*)x - *(int*)y;<br><br>    <span class="hljs-keyword">return</span> standard;<br>&#125;<br><br>int <span class="hljs-title function_">partition</span>(<span class="hljs-params"><span class="hljs-keyword">void</span>** ar, int(*cmp)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*), int left, int right, int pivotIndex</span>)<br>&#123;<br>    int idx;<br>    int store;<br>    <span class="hljs-keyword">void</span>* pivot = ar[pivotIndex];<br>    <span class="hljs-comment">//将中枢值移动到数组结尾</span><br>    <span class="hljs-keyword">void</span>* tmp = ar[right];<br>    ar[right] = ar[pivotIndex];<br>    ar[pivotIndex] = tmp;<br>    <span class="hljs-comment">//将所有小于等于中枢值的元素都会移动到数组的前面，然后将中枢值插在它们后面</span><br>    store = left;<br>    <span class="hljs-keyword">for</span> (idx = left;idx &lt; right;idx++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">cmp</span>(ar[idx], pivot) &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            tmp = ar[idx];<br>            ar[idx] = ar[store];<br>            ar[store] = tmp;<br>            store++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//又一次交换，中枢值插在后面</span><br>    tmp = ar[right];<br>    ar[right] = ar[store];<br>    ar[store] = tmp;<br>    <span class="hljs-comment">//返回中值的位置</span><br>    <span class="hljs-keyword">return</span> store;<br>&#125;<br><br><span class="hljs-comment">//寻找在数组ar[left]、ar[left + gap]、ar[left + gap * 2]、ar[left + gap * 3]的4个元素的中值, 在结束的时候确保ar[left + gap * 2]包含有中值。</span><br><span class="hljs-comment">/*原书代码：</span><br><span class="hljs-comment"> static void medianOffour(void** ar, int left, int gap, int(*cmp)(const void*, const void*))</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  int pos1 = left;</span><br><span class="hljs-comment">  int pos2;</span><br><span class="hljs-comment">  int pos3;</span><br><span class="hljs-comment">  int pos4;</span><br><span class="hljs-comment">  void* a1 = ar[pos1];</span><br><span class="hljs-comment">  void* a2 = ar[pos2 = pos1 + gap];</span><br><span class="hljs-comment">  void* a3 = ar[pos3 = pos2 + gap];</span><br><span class="hljs-comment">  void* a4 = ar[pos4 = pos3 + gap];</span><br><span class="hljs-comment">  if (cmp(a1, a2) &lt;= 0)</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">    if (cmp(a2, a3) &lt;= 0)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">      if (cmp(a3, a4) &gt; 0)</span><br><span class="hljs-comment">      &#123;</span><br><span class="hljs-comment">        SWAP(ar, pos3, pos4, void *);</span><br><span class="hljs-comment">      &#125;</span><br><span class="hljs-comment">      else</span><br><span class="hljs-comment">      &#123;</span><br><span class="hljs-comment">        SWAP(ar, pos2, pos3, void*);</span><br><span class="hljs-comment">      &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    else</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">      if (cmp(a1, a4) &lt;= 0)</span><br><span class="hljs-comment">      &#123;</span><br><span class="hljs-comment">        if (cmp(a2, a4) &lt;= 0)</span><br><span class="hljs-comment">        &#123;</span><br><span class="hljs-comment">          SWAP(ar, pos2, pos3, void*);</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        else</span><br><span class="hljs-comment">        &#123;</span><br><span class="hljs-comment">          SWAP(ar, pos3, pos4, void*);</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">      &#125;</span><br><span class="hljs-comment">      else</span><br><span class="hljs-comment">      &#123;</span><br><span class="hljs-comment">        if (cmp(a1, a3) &lt;= 0)</span><br><span class="hljs-comment">        &#123;</span><br><span class="hljs-comment">          if (cmp(a3, a4) &lt;= 0)</span><br><span class="hljs-comment">          &#123;</span><br><span class="hljs-comment">            if (cmp(a2, a4) &lt;= 0)</span><br><span class="hljs-comment">            &#123;</span><br><span class="hljs-comment">              SWAP(ar, pos2, pos3, void*);</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">            else</span><br><span class="hljs-comment">            &#123;</span><br><span class="hljs-comment">              SWAP(ar, pos3, pos4, void*);</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">          &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        else</span><br><span class="hljs-comment">        &#123;</span><br><span class="hljs-comment">          if (cmp(a1, a4) &lt;= 0)</span><br><span class="hljs-comment">          &#123;</span><br><span class="hljs-comment">            if (cmp(a2, a4) &lt;= 0)</span><br><span class="hljs-comment">            &#123;</span><br><span class="hljs-comment">              SWAP(ar, pos2, pos3, void*);</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">            else</span><br><span class="hljs-comment">            &#123;</span><br><span class="hljs-comment">              SWAP(ar, pos1, pos3, void*);</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">          &#125;</span><br><span class="hljs-comment">          else</span><br><span class="hljs-comment">          &#123;</span><br><span class="hljs-comment">            SWAP(ar, pos1, pos3, void*);</span><br><span class="hljs-comment">          &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">      &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">  else</span><br><span class="hljs-comment">  &#123;</span><br><span class="hljs-comment">    if (cmp(a1, a3) &lt;= 0)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">      if (cmp(a1, a4) &lt;= 0)</span><br><span class="hljs-comment">      &#123;</span><br><span class="hljs-comment">        if (cmp(a3, a4) &gt; 0)</span><br><span class="hljs-comment">        &#123;</span><br><span class="hljs-comment">          SWAP(ar, pos3, pos4, void*);</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">      &#125;</span><br><span class="hljs-comment">      else</span><br><span class="hljs-comment">      &#123;</span><br><span class="hljs-comment">        ;</span><br><span class="hljs-comment">      &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    else</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">      if (cmp(a2, a3) &lt;= 0)</span><br><span class="hljs-comment">      &#123;</span><br><span class="hljs-comment">        if (cmp(a3, a4) &lt;= 0)</span><br><span class="hljs-comment">        &#123;</span><br><span class="hljs-comment">          if (cmp(a1, a4) &lt;= 0)</span><br><span class="hljs-comment">          &#123;</span><br><span class="hljs-comment">            SWAP(ar, pos1, pos3, void*);</span><br><span class="hljs-comment">          &#125;</span><br><span class="hljs-comment">          else</span><br><span class="hljs-comment">          &#123;</span><br><span class="hljs-comment">            SWAP(ar, pos3, pos4, void*);</span><br><span class="hljs-comment">          &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        else</span><br><span class="hljs-comment">        &#123;</span><br><span class="hljs-comment">          SWAP(ar, pos2, pos3, void*);</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">      &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">//优化后的代码：</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">优化前的代码则采用了更加复杂的逻辑来减少不必要的比较和交换。它首先通过一系列的比较来确定元素之间的相对顺序，</span><br><span class="hljs-comment">然后根据这些比较的结果来决定是否进行交换。这种方法的优点是它试图通过最少的比较和交换次数来达到排序的目的；优化后的代码逻辑相对直接，</span><br><span class="hljs-comment">但包含了多个嵌套的条件语句，这可能导致在某些情况下性能不是最优的，因为即使已经确定了元素的相对顺序，代码仍然会继续执行不必要的比较。</span><br><span class="hljs-comment">两段代码在性能上可能存在差异，但这种差异可能并不总是显著的。在选择使用哪段代码时，需要权衡代码的可读性、可维护性和实际性能需求。</span><br><span class="hljs-comment">如果性能是关键因素，并且可以通过减少比较和交换次数来显著提高性能，那么可以考虑使用优化前的代码（或对其进行进一步的优化）。</span><br><span class="hljs-comment">然而，如果代码的可读性和可维护性更加重要，那么优化后的代码可能是一个更好的选择。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">medianOffour</span>(<span class="hljs-params"><span class="hljs-keyword">void</span>** ar, int left, int gap, int (*cmp)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*)</span>)<br>&#123;<br>  int pos1 = left;<br>  int pos2 = pos1 + gap;<br>  int pos3 = pos2 + gap;<br>  int pos4 = pos3 + gap;<br><br>  <span class="hljs-comment">// Compare and swap adjacent elements to sort in ascending order</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">cmp</span>(ar[pos1], ar[pos2]) &gt; <span class="hljs-number">0</span>) <span class="hljs-title function_">SWAP</span>(ar, pos1, pos2, <span class="hljs-keyword">void</span>*);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">cmp</span>(ar[pos3], ar[pos4]) &gt; <span class="hljs-number">0</span>) <span class="hljs-title function_">SWAP</span>(ar, pos3, pos4, <span class="hljs-keyword">void</span>*);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">cmp</span>(ar[pos1], ar[pos3]) &gt; <span class="hljs-number">0</span>) <span class="hljs-title function_">SWAP</span>(ar, pos1, pos3, <span class="hljs-keyword">void</span>*);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">cmp</span>(ar[pos2], ar[pos4]) &gt; <span class="hljs-number">0</span>) <span class="hljs-title function_">SWAP</span>(ar, pos2, pos4, <span class="hljs-keyword">void</span>*);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">cmp</span>(ar[pos2], ar[pos3]) &gt; <span class="hljs-number">0</span>) <span class="hljs-title function_">SWAP</span>(ar, pos2, pos3, <span class="hljs-keyword">void</span>*);<br>&#125;<br><br><span class="hljs-comment">//使用间隔距离，对元素进行特定的插入排序</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertion</span>(<span class="hljs-params"><span class="hljs-keyword">void</span>** ar, int(*cmp)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*), int low, int right, int gap</span>)<br>&#123;<br>    int loc;<br>    <span class="hljs-keyword">for</span> (loc = low + gap;loc &lt;= right;loc += gap)<br>    &#123;<br>        int i = loc - gap;<br>        <span class="hljs-keyword">void</span>* value = ar[loc];<br>        <span class="hljs-keyword">while</span> (i &gt;= low &amp;&amp; <span class="hljs-title function_">cmp</span>(ar[i], value) &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            ar[i + gap] = ar[i];<br>            i -= gap;<br>        &#125;<br>        ar[i + gap] = value;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">为ar[left,right]寻找合适的pivotIndex。考虑大小为b的集合,在这个代码中,b=4。</span><br><span class="hljs-comment">原始的BFPRT算法中b=5。</span><br><span class="hljs-comment">1.将元素分成floor(n/b)个集合,每个集合包含b个元素,在每一个集合中寻找中值元素。</span><br><span class="hljs-comment">然后将这些中值元素组成集合M。</span><br><span class="hljs-comment">2.如果|M|&gt;b,那么递归地执行上一步,直到分成少于或者等于b个集合。</span><br><span class="hljs-comment">3.在递归的基础情况中,简单地使用插入排序来排序小于等于b个中值,</span><br><span class="hljs-comment">然后选择出这些中值中的中值。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">static</span> int <span class="hljs-title function_">medianOfMedians</span>(<span class="hljs-params"><span class="hljs-keyword">void</span>** ar, int(*cmp)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*), int left, int right, int gap</span>)<br>&#123;<br>    int s;<br>    int num;<br>    int span = <span class="hljs-number">4</span> * gap;<br>    <span class="hljs-comment">//元素不够组成集合？对这些元素插入排序，然后返回中值</span><br>    num = (right - left + <span class="hljs-number">1</span>) / span;<br>    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-title function_">insertion</span>(ar, cmp, left, right, gap);<br>        num = (right - left + <span class="hljs-number">1</span>) / gap;<br>        <span class="hljs-keyword">return</span> left + gap * (num - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-comment">//得到所有集合的中值</span><br>    <span class="hljs-keyword">for</span> (s = left;s + span &lt; right;s += span)<br>    &#123;<br>        <span class="hljs-title function_">medianOffour</span>(ar, s, gap, cmp);<br>    &#125;<br>    <span class="hljs-comment">//如果仍然有足够的集合，那么增加gap的值，递归的应用在子数组[left,s-1]上，否则的话执行插入排序，返回中值</span><br>    <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">4</span>)<br>    &#123;<br>        <span class="hljs-comment">//基础情况</span><br>        <span class="hljs-title function_">insertion</span>(ar, cmp, left + span / <span class="hljs-number">2</span>, right, span);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">medianOfMedians</span>(ar, cmp, left + span / <span class="hljs-number">2</span>, s - <span class="hljs-number">1</span>,span);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">medianOfMedians</span>(ar, cmp, left + span / <span class="hljs-number">2</span>, s - <span class="hljs-number">1</span>, span);<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-comment">//在ar[left,right]中寻找中值的最坏情况为线性的算法，比较函数cmp用来比较元素。</span><br>int <span class="hljs-title function_">selectMedian</span>(<span class="hljs-params"><span class="hljs-keyword">void</span>** ar, int(*cmp)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*), int left, int right</span>)<br>&#123;<br>    int k = (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">//选择切分的时候应该根据元素的索引</span><br>        int idx = <span class="hljs-title function_">medianOfMedians</span>(ar, cmp, left, right, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">/*根据中值集合的中值x切分输入数组。如果能够找到第k大的元素,返回其素引,</span><br><span class="hljs-comment">          否则在A[left,pivotIndex-1]寻找第k大元素或者在A[pivotIndex+1,right]中</span><br><span class="hljs-comment">          寻找(k-p)大元素</span><br><span class="hljs-comment">          在A[Pivot  Index+1,  right]中。 */</span><br><br>        int pivotIndex = <span class="hljs-title function_">partition</span>(ar, cmp, left, right, idx);<br>        <span class="hljs-comment">//注意0&lt;=k&lt;=right-left,返回值pivotIndex是left&lt;=pivotIndex&lt;=right</span><br>        int p = left + k;<br>        <span class="hljs-keyword">if</span> (p == pivotIndex)<br>        &#123;<br>            <span class="hljs-keyword">return</span> pivotIndex;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p&lt;pivotIndex)<br>        &#123;<br>            right = pivotIndex - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            k = k - (pivotIndex - left + <span class="hljs-number">1</span>);<br>            left = pivotIndex + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//如果执行到这里，那么left=right，所以仅仅只需要返回两个中的一个作为中值。</span><br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><br><span class="hljs-comment">// 打印数组  </span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span>(<span class="hljs-params">int* ar, int size</span>) &#123;<br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, ar[i]);<br>    &#125;<br>    <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br>int <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) <br>&#123;<br>    <span class="hljs-comment">// 示例整数数组  </span><br>    int arr[] = &#123; <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span> &#125;;<br>    int size = <span class="hljs-title function_">sizeof</span>(arr) / <span class="hljs-title function_">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-comment">// 创建指向整数的指针数组  </span><br>    <span class="hljs-keyword">void</span>** ptrArr = (<span class="hljs-keyword">void</span>**)<span class="hljs-title function_">malloc</span>(size * <span class="hljs-title function_">sizeof</span>(<span class="hljs-keyword">void</span>*));<br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        ptrArr[i] = &amp;arr[i];<br>    &#125;<br><br>    <span class="hljs-comment">// 找到中值的索引  </span><br>    int medianIndex = <span class="hljs-title function_">selectMedian</span>(ptrArr, cmp, <span class="hljs-number">0</span>, size - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 打印结果  </span><br>    <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;中值索引: %d\n&quot;</span>, medianIndex);<br>    <span class="hljs-title function_">printf</span>(<span class="hljs-string">&quot;中值元素: %d\n&quot;</span>, arr[medianIndex]);<br><br>    <span class="hljs-comment">// 释放动态分配的内存  </span><br>    <span class="hljs-title function_">free</span>(ptrArr);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总而言之，中值排序的优化可以从以下几个方面入手：</p>
<h2 id="一、枢轴选择的优化">一、枢轴选择的优化</h2>
<p>三数取中法：<br>
在选择枢轴时，不直接选择子数组的第一个、最后一个或中间元素，而是从子数组的首部、尾部和中间位置各取一个元素，然后取这三个数的中值作为枢轴。这种方法可以减少最坏情况发生的概率，即避免划分后的两个子数组极度不平衡。<br>
随机选择枢轴：<br>
通过随机选择一个元素作为枢轴，可以进一步降低最坏情况发生的概率，使算法的平均性能更加稳定。随机选择枢轴可以通过生成一个随机数，然后将其映射到子数组的索引范围内来实现。</p>
<h2 id="二、划分过程的优化">二、划分过程的优化</h2>
<p>双向扫描法：<br>
在划分过程中，可以使用两个指针（哨兵）分别从数组的两端向中间扫描，一个指针寻找大于枢轴的元素，另一个指针寻找小于枢轴的元素，然后交换这两个元素的位置。这种方法可以减少不必要的元素移动，提高算法的效率。<br>
尾递归优化：<br>
在递归调用中，如果可能的话，优先对较小的子数组进行递归，而对较大的子数组进行迭代处理。这可以减少递归调用的深度，从而降低栈空间的使用。</p>
<h2 id="三、处理小数组的优化">三、处理小数组的优化</h2>
<p>切换到其他排序算法：<br>
当子数组的大小小于某个阈值时，可以切换到其他排序算法，如插入排序或选择排序。这些算法在处理小规模数据时具有较高的效率。<br>
使用内存块移动：<br>
在插入排序等算法中，可以通过使用内存块移动而不是单个元素的交换来改善性能。内存块移动可以减少内存访问的次数，从而提高算法的效率。</p>
<h2 id="四、并行化与分布式处理">四、并行化与分布式处理</h2>
<p>多线程/多进程并行：<br>
如果硬件支持多线程或多进程并行处理，可以将排序任务分解为多个子任务，并在不同的线程或进程中并行执行。这可以显著提高排序的速度，但需要注意线程或进程之间的同步和通信问题。<br>
分布式排序：<br>
在处理大规模数据集时，可以考虑使用分布式排序算法。这些算法将数据分布在多个节点上进行处理，然后通过网络通信来协调各个节点的操作。分布式排序可以充分利用集群的计算资源，提高排序的效率。</p>
<h2 id="五、其他优化策略">五、其他优化策略</h2>
<p>减少内存使用：<br>
在实现排序算法时，应尽量减少内存的使用。例如，可以通过原地排序的方式来减少额外的内存开销。<br>
优化比较函数：<br>
如果排序的对象是自定义的数据类型，应确保比较函数尽可能高效。比较函数的性能会直接影响排序算法的整体性能。<br>
避免不必要的元素复制：<br>
在排序过程中，应尽量避免不必要的元素复制。例如，在划分过程中，可以直接交换元素的位置，而不是先复制到一个临时数组中再交换回来。</p>
<h1>六、引用及参考文献</h1>
<p>《算法设计手册》<br>
0.1162<br>
0.1429<br>
0.1506<br>
0.1969<br>
0.2542<br>
0.3177<br>
0.439</p>
<p>0.1235<br>
0.1503<br>
0.1877<br>
0.1945<br>
0.1988<br>
0.2992<br>
1.1366</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/" class="category-chain-item">数据结构与算法分析</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>数据结构与算法分析：你真的理解排序算法吗——中值排序（万字长文+代码详解）</div>
      <div>https://mounthuangshan.github.io/数据结构与算法分析/数据结构与算法分析/数据结构与算法分析：你真的理解排序算法吗——中值排序（万字长文+代码详解）/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>黄山</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年3月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%90%97%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/" title="数据结构与算法分析：你真的理解排序算法吗——总结">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">数据结构与算法分析：你真的理解排序算法吗——总结</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%90%97%E2%80%94%E2%80%94%E6%A1%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%89/" title="数据结构与算法分析：你真的理解排序算法吗——桶排序（代码详解）">
                        <span class="hidden-mobile">数据结构与算法分析：你真的理解排序算法吗——桶排序（代码详解）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
