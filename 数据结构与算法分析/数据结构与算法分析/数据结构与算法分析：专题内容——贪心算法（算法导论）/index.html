

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="黄山">
  <meta name="keywords" content="C/C++,Python,C#,Go,Web,AI,游戏开发,网络安全">
  
    <meta name="description" content="一、前言 以下内容均来自算法导论： 求解最优化问题的算法通常需要经过一系列的步骤，在每个步骤都面临多种选择。对于许多最优化问题，使用动态规划算法来求最优解有些杀鸡用牛刀了，可以使用更简单、更高效的算法。贪心算法(greedy algorithm)就是这样的算法，它在每一步都做出当时看起来最佳的选择，也就是说，它总是做出局部最优的选择，寄希望这样的选择能导致全局最优解。 活动选择问题 我们的第一个例">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法分析：专题内容——贪心算法（算法导论）">
<meta property="og:url" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89/">
<meta property="og:site_name" content="钺不言">
<meta property="og:description" content="一、前言 以下内容均来自算法导论： 求解最优化问题的算法通常需要经过一系列的步骤，在每个步骤都面临多种选择。对于许多最优化问题，使用动态规划算法来求最优解有些杀鸡用牛刀了，可以使用更简单、更高效的算法。贪心算法(greedy algorithm)就是这样的算法，它在每一步都做出当时看起来最佳的选择，也就是说，它总是做出局部最优的选择，寄希望这样的选择能导致全局最优解。 活动选择问题 我们的第一个例">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89image%5Ca36b1798e09e43f5937bda9d0c346d3d.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89image%5C2e11e8ad776e4803a2630b625121b0e4.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89image%5Ce431589161c143bcb93d51570bc80f11.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89image%5C385fde45f7d541d58a3da3a9e21da77a.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89image%5C55dde6b529d449ba91c3d640bf0b40e4.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89image%5Cd8622b053fa64825886dd36c5c867545.png">
<meta property="og:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89image%5Cf5ebab4b230544c4af80b80ab108a14c.png">
<meta property="article:published_time" content="2025-03-18T18:19:05.000Z">
<meta property="article:modified_time" content="2025-03-18T18:19:05.850Z">
<meta property="article:author" content="黄山">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="Web">
<meta property="article:tag" content="AI">
<meta property="article:tag" content="游戏开发">
<meta property="article:tag" content="网络安全">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://mounthuangshan.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89image%5Ca36b1798e09e43f5937bda9d0c346d3d.png">
  
  
  
  <title>数据结构与算法分析：专题内容——贪心算法（算法导论） - 钺不言</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"mounthuangshan.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="数据结构与算法分析：专题内容——贪心算法（算法导论）"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-03-19 02:19" pubdate>
          2025年3月19日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          15k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          127 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">数据结构与算法分析：专题内容——贪心算法（算法导论）</h1>
            
            
              <div class="markdown-body">
                
                <h1>一、前言</h1>
<p><strong>以下内容均来自算法导论：</strong><br>
求解最优化问题的算法通常需要经过一系列的步骤，在每个步骤都面临多种选择。对于许多最优化问题，使用动态规划算法来求最优解有些杀鸡用牛刀了，可以使用更简单、更高效的算法。贪心算法(greedy algorithm)就是这样的算法，它在每一步都做出当时看起来最佳的选择，也就是说，它总是做出局部最优的选择，寄希望这样的选择能导致全局最优解。</p>
<h1>活动选择问题</h1>
<p>我们的第一个例子是一个调度竞争共享资源的多个活动的问题，目标是选出一个最大的互同一个资源(例如一个阶梯教室),而这个资源在某个时刻只能供一个活动使用。每个活动$a_i$都有一个开始时间$s_i$和一个结束时间$f_i$,其中$0\leqslant s_i&lt;f_i&lt;\infty$。如果被选中，任务$a_i$发生在半开时间区间$[s_i,f_i)$期间。如果两个活动 $a_i$ 和$a_j$ 满足$[s_i,f_i)$和$[s_j,f_j)$不重叠，则称它们是兼容的。也就是说，若 s$s_i\geqslant f_j$或$s_j\geqslant f_i$,则$a_i$和$a_j$是兼容的。在活动选择问题中，我们希望选出一个最大兼容活动集。假定活动已按结束时间的单调递增顺序排序：<br>
$$f_1\leqslant f_2\leqslant f_3\leqslant\cdots\leqslant f_{n-1}\leqslant f_n$$<br>
(16.1)<br>
(稍后，我们会看到这一假设的好处)。例如，考虑下面的活动集合 S:<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89image%5Ca36b1798e09e43f5937bda9d0c346d3d.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
对于这个例子，子集${a_{3}, a_{9}, a_{11}}$由相互兼容的活动组成。但它不是一个最大集，因为子集{$a_{1}$, $a_{4},a_{8},a_{11}}$更大。实际上，${a_1,a_4,a_8,a_{11}}$是一个最大兼容活动子集，另一个最大子集是${ a_2$, $a_4$, $a_9$, $a_{11}}$。<br>
下面分几个步骤来解决这个问题。我们可以通过动态规划方法将这个问题分为两个子问题， 然后将两个子问题的最优解整合成原问题的一个最优解。在确定该将哪些子问题用于最优解时， 要考虑几种选择。读者稍后会发现，贪心算法只需考虑一个选择(即贪心的选择),在做贪心选择时，子问题之一必是空的，因此，只留下一个非空子问题。基于这些观察，我们将找到一种递归贪心算法来解决活动调度问题，并将递归算法转化为迭代算法，以完成贪心方法的过程。虽然本节介绍的步骤比典型的贪心算法的设计过程更为复杂，但它们说明了贪心算法和动态规划之间的关系。</p>
<p><strong>活动选择问题的最优子结构</strong><br>
我们容易验证活动选择问题具有最优子结构性质。令 $S_{ij}$表示在$a_i$ 结束之后开始，且在 $a_{j}$ 开始之前结束的那些活动的集合。假定我们希望求$S_{ij}$的一个最大的相互兼容的活动子集，进一步假定$A_i$ 就 是 这 样 一 个 子 集 , 包 含 活 动 $a_k$。由于最优解包含活动$a_k$,我们得到两个子问题：寻找$S_{kk}$中的兼容活动(在$a_i$结束之后开始且$a_k$开始之前结束的那些活动)以及寻找$S_{kj}$中的兼容活动(在$a_k$结束之后开始且在$a_j$开始之前结束的那些活动)。令$A_ik=A_{ij}\cap S_{ik}$和$A_kj=A_{ij}\cap S_{kj}$,这样$A_{ik}$包含$A_{ij}$ 中那些在$a_k$ 开始之前结束的活动，$A_{kj}$包含$A_{ij}$ 中那些在$a_k$ 结束之后开始的活动。因此，我们有 $A_ij=A_{ik}\bigcup\left{a_k\right}\bigcup A_{kj}$,而且 S$<em>i$中 最 大 兼 容 任 务 子 集 $A</em>{i}$ 包含$\left|A_{i\ddot{v}}\right|=\left|A_{ik}\right|+\left|A_{kj}\right|+1$ 个活动。<br>
我们仍然用剪切一粘贴法证明最优解$A_{ij}$必然包含两个子问题$S_{ik}$和$S_{kj}$的最优解。否则，如果可以找到$S_kj$的一个兼容活动子集$A_kj^{\prime}$,满足$|A_kj^{\prime}|&gt;|A_kj|$,则可以将$A_kj^{\prime}$而不是$A_kj$作为$S_ij$的最优解的一部分。这样就构造出一个兼容活动集，其大小$|A_{ik}|+|A_{kj}^{\prime}|+1&gt;|A_{ik}|+|A_{kj}|+1=$ $|A_{ij}|$,与$A_{ij}$是最优解的假设矛盾。对子问题 S$<em>{ik}$类似可证。<br>
这样刻画活动选择问题的最优子结构，意味着我们可以用动态规划方法求解活动选择问题<br>
如果用$c[i,j]$表示集合$S</em>{ij}$的最优解的大小，则可得递归式<br>
$$c[i,j]=c[i,k]+c[k,j]+1$$<br>
当然，如果不知道 $S_{i_i}$的最优解包含活动$a_k$, 就 需 要 考 查 $S_{i_i}$中所有活动，寻找哪个活动可获</p>
<p>得最优解，于是<br>
$$c[i,j]=\begin{cases}0&amp;\text{若}S_{ij}=\varnothing\\max_{a_i\in S_i}{c[i,k]+c[k,j]+1}&amp;\text{若}S_{ij}\neq\varnothing\end{cases}$$<br>
(16.2)</p>
<p><strong>贪心选择</strong><br>
于是接下来可以设计一个带备忘机制的递归算法，或者使用自底向上法填写表项。但我们可能忽略了活动选择问题的另一个重要性质，而这一性质可以极大地提高问题求解速度。<br>
假如我们无需求解所有子问题就可以选择出一个活动加人到最优解，将会怎样？这将使我们省去递归式(16.2)中固有的考查所有选择的过程。实际上，对于活动选择问题，我们只需考虑一个选择：贪心选择。<br>
对于活动选择问题，什么是贪心选择？直观上，我们应该选择这样一个活动，选出它后剩下的资源应能被尽量多的其他任务所用。现在考虑可选的活动，其中必然有一个最先结束。因此， 直觉告诉我们，应该选择 S 中最早结束的活动，因为它剩下的资源可供它之后尽量多的活动使用。(如果 S 中最早结束的活动有多个，我们可以选择其中任意一个)。换句话说，由于活动已按结束时间单调递增的顺序排序，贪心选择就是活动$a_1$。选择最早结束的活动并不是本问题唯一的贪心选择方法，练习 16.1-3 要求设计其他贪心选择方法。<br>
当做出贪心选择后，只剩下一个子问题需要我们求解：寻找在$a_{1}$结束后开始的活动。为什么不需要考虑在$a_1$开始前结束的活动呢？因为 因为$s_1&lt;f_1$且$f_1$是最早结束的活动，所以不会有活动的结束时间早于$s_1$。因此，所有与$a_1$兼容的活动都必须在$a_1$结束之后开始。<br>
而且，我们已经证明活动选择问题具有最优子结构性质。令$S_k=\langle a_i\in S:s_i\geqslant f_k\rangle$为在$a_k$结束后开始的任务集合。当我们做出贪心选择，选择了$a_{1}$后，剩下的 $S_{1}$ 是唯一需要求解的子问题$^{\ominus}$。最优子结构性质告诉我们，如果$a_1$在最优解中，那么原问题的最优解由活动$a_{\mathrm{i}}$及子问题$S_1$中所有活动组成。<br>
现在还剩下一个大问题：我们的直觉是正确的吗？贪心选择——最早结束的活动——总是最优解的一部分吗？下面的定理证明了这一点。<br>
<strong>定理16.1：</strong><br>
考虑任意非空子问题$S_k$,令$a_m$是$S_k$ 中结束时间最早的活动，则$a_m$在$S_k$的某个<br>
最大兼容活动子集中。<br>
<strong>证明：</strong><br>
令$A_k$ 是$S_k$ 的一个最大兼容活动子集，且 $a_j$ 是$A_k$ 中结束时间最早的活动。若 $a_j=$ $a_m$,则已经证明$a_m$在 S$_k$ 的 某 个 最 大 兼 容 活 动 子 集 中 。若 $a_j\neq a_m$,令集合$A_k^\prime=A_k-\langle a_j\rangle\bigcup\left{a_m\right}$, 即将 $A_k$ 中的$a_j$ 替换为$a_m$。$A_k^\prime$中的活动都是不相交的，因为 $A_k$ 中的活动都是不相交的，$a_j$ 是$A_k$ 中结束时间最早的活动，而 $f_m\leqslant f_j$。由于$|A_k^\prime|=|A_k|$,因此得出结论 $A_k^{\prime}$也是$S_k$ 的一个最大兼容活动子集，且它包含$a_m$ 。<br>
因此，我们看到虽然可以用动态规划方法求解活动选择问题，但并不需要这样做(此外，我们并未检查活动选择问题是否具有重叠子问题性质)。相反，我们可以反复选择最早结束的活动， 保留与此活动兼容的活动，重复这一过程，直至不再有剩余活动。而且，因为我们总是选择最早结束的活动，所以选择的活动的结束时间必然是严格递增的。我们只需按结束时间的单调递增顺序处理所有活动，每个活动只考查一次。<br>
求解活动选择问题的算法不必像基于表格的动态规划算法那样自底向上进行计算。相反， 可以自顶向下进行计算，选择一个活动放入最优解，然后，对剩余的子问题(包含与已选择的活动兼容的活动)进行求解。贪心算法通常都是这种自顶向下的设计：做出一个选择，然后求解剩下的那个子问题，而不是自底向上地求解出很多子问题，然后再做出选择。</p>
<p><strong>递归贪心算法</strong><br>
我们已经看到如何绕过动态规划方法而使用自顶向下的贪心算法来求解活动选择问题，现在我们可以设计一个直接的递归过程来实现贪心算法。过程 RECURSIVE-ACTIVITYSELECTOR 的输人为两个数组 s 和$f^\mathrm{\Theta}$,表示活动的开始和结束时间，下标$k$指出要求解的子问题$\mathcal{S}<em>k$,以及问题规模$n$。它返回$S_k$的一个最大兼容活动集。我们假定输人的$n$个活动已经按结束时间的单调递增顺序排列好(公式(16.1))。如果未排好序，我们可以在 $O(n\lg n)$时间内对它们进行排序，结束时间相同的活动可以任意排列。为了方便算法初始化，我们添加一个虚拟活动$a_0$,其结束时间$f_0=0$,这样子问题 S$</em>{\mathrm{o}}$就是完整的活动集 S。求解原问题即可调用 RECURSIVEACTIVITY- SELECTOR$( s, f, 0, n)$。</p>
<p>RECURSIVE-ACTIVITY-SELECTOR(s, $f,k,n)$<br>
1 $m= k+ 1$<br>
2 $\textbf{while }m\leqslant n$ and $s[m]&lt;f[k]$<br>
// find the first activity in S_k to finish<br>
3 $m=m+1$<br>
4 if $m\leqslant n$<br>
5 return $\langle a_m\rangle\bigcup$RECURSIVE-ACTIVITY-SELECTOR(s,f,m,n)<br>
6 else return $\varnothing$</p>
<p>图 16-1 显示了算法的执行过程。在一次递归调用 RECURSIVE-ACTIVITY-SELECTOR(s,$f,k,n)$的过程中，第2~3 行 while 循环查找 S$<em>k$ 中最早结束的活动。循环检查 $a</em>{k+1},a_{k+2},\cdots$, $a_n$,直至找到第一个与$a_k$ 兼容的活动$a_m$,此活动满足 $s_m\geqslant f_k$。如果循环因为查找成功而结束， 第 5 行返回$\langle a_m\rangle$与 RECURSIVE-ACTIVITY-SELECTOR(s,f,m,n)返回的 S$_m$ 的最大子集的并集。循环也可能因为$m&gt;n$而终止，这意味着我们已经检查了$S_k$中所有活动，未找到与$a_k$兼容者。在此情况下，$S_k=\varnothing$,因此第6行返回$\varnothing$。<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89image%5C2e11e8ad776e4803a2630b625121b0e4.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
假定活动已经按结束时间排好序，则递归调用 RECURSIVE-ACTIVITY-SELECTOR(s,f, 0,$n$)的运行时间为$\Theta(n)$,我们稍后证明这个结论。在整个递归调用过程中，每个活动被且只被第 2 行的 while 循环检查一次。特别地，活动$a_i$在$k&lt;i$的最后一次调用中被检查。</p>
<p><strong>迭代贪心算法</strong><br>
我们可以很容易地将算法转换为迭代形式。过程 RECURSIVE-ACTIVITY-SELECTOR 几乎就是“尾递归”(参见思考题 7-4):它以一个对自身的递归调用再接一次并集操作结尾。将一个尾递归过程改为迭代形式通常是很直接的，实际上，某些特定语言的编译器可以自动完成这一工作。如前所述，RECURSIVE-ACTIVITY-SELECTOR 用来求解子问题$\mathcal{S}_k$,即由最后完成的任务组成的子问题。<br>
过程 GREEDY-ACTIVITY-SELECTOR 是过程 RECURSIVE-ACTIVITY-SELECTOR 的一个迭代版本。它也假定输人活动已按结束时间单调递增顺序排好序。它将选出的活动存入集合 A 中，并将 A 返回调用者。</p>
<p>GREEDY-ACTIVITY-SELECTOR(s, $f)$<br>
1 $n= s. length$<br>
2 $A= { a_1}$<br>
3 $k=1$<br>
4 $\textbf{for }m= 2$ to $n$<br>
5 $\textbf{if s}[ m] \geqslant f[ k]$<br>
6 $A=A\bigcup{a_m}$<br>
7 $k=m$<br>
8 return A</p>
<p>过程执行如下。变量$k$记录了最近加入集合$A$的活动的下标，它对应递归算法中的活动$a_k$。由于我们按结束时间的单调递增顺序处理活动，$f_k$总是$A$中活动的最大结束时间。也就是说，<br>
$$f_k=\max{f_i:a_i\in A}$$<br>
(16.3)</p>
<p>第 2~3 行选择活动$a_1$,将$A$的初值设置为只包含此活动，并将$k$的初值设为此活动的下标。第4~7 行的 for 循环查找$S_k$中最早结束的活动。循环依次处理每个活动$a_m,a_m$若与之前选出的活动兼容，则将其加入$A$,这样选出的$a_m$必然是$S_k$中最早结束的活动。为了检查活动$a_m$是否与$A$中所有活动都兼容，过程检查公式(16.3)是否成立，即检查活动的开始时间 s$_{m}$是否不早于最近加入到$A$中的活动的结束时间$f_k$。如果活动$a_m$是兼容的，第 6~7 行将其加人$A$中，并将$k$ 设置为$m$。GREEDY-ACTIVITY-SELECTOR(s,$f$)返回的集合$A$与 RECURSIVE-ACTIVITYSELECTOR$(s,f,0,n)$返回的集合完全相同。<br>
与递归版本类似，在输入活动已按结束时间排序的前提下，GREEDY-ACTIVITY-SELECTOR 的运行时间为$\Theta(n)$。</p>
<h1>贪心算法原理</h1>
<p>贪心算法通过做出一系列选择来求出问题的最优解。在每个决策点，它做出在当时看来最佳的选择。这种启发式策略并不保证总能找到最优解，但对有些问题确实有效，如活动选择问题。本节讨论贪心方法的一些一般性质。<br>
前面设计贪心算法的过程比通常的过程繁琐一些，我们当时经过了如下几个步骤<br>
1.确定问题的最优子结构。<br>
2.设计一个递归算法(对活动选择问题，我们给出了递归式(16.2),但跳过了基于此递归式<br>
设计递归算法的步骤)。<br>
3.证明如果我们做出一个贪心选择，则只剩下一个子问题。<br>
4.证明贪心选择总是安全的(步骤 3、4 的顺序可以调换)。<br>
5.设计一个递归算法实现贪心策略。<br>
6.将递归算法转换为迭代算法。<br>
在这个过程中，我们详细地看到了贪心算法是如何以动态规划方法为基础的。例如，在活动选择问题中，我们首先定义了子问题$S_{ij}$,其中$i$和$j$都是可变的。然后我们发现，如果总是做出贪心选择，则可以将子问题限定为$S_k$的形式。<br>
与这种繁琐的过程相反，我们可以通过贪心选择来改进最优子结构，使得选择后只留下一个子问题。在活动选择问题中，我们可以一开始就将第二个下标去掉，将子问题定义为$S_k$的形式。然后，我们可以证明，贪心选择($S_k$中最早结束的活动 $a_m$)与剩余兼容活动集的最优解组合在一起，就会得到 S$_k$的最优解。更一般地，我们可以按如下步骤设计贪心算法：<br>
1.将最优化问题转化为这样的形式：对其做出一次选择后，只剩下一个子问题需要求解。<br>
2.证明做出贪心选择后，原问题总是存在最优解，即贪心选择总是安全的。<br>
3.证明做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原向题的最优解，这样就得到了最优子结构。<br>
在本章剩余部分中，我们将使用这种更直接的设计方法。但我们应该知道，在每个贪心算法之下，几乎总有一个更繁琐的动态规划算法。<br>
我们如何证明一个贪心算法是否能求解一个最优化问题呢？并没有适合所有情况的方法， 但贪心选择性质和最优子结构是两个关键要素。如果我们能够证明问题具有这些性质，就向贪心算法迈出了重要一步。</p>
<p><strong>贪心选择性质</strong><br>
第一个关键要素是贪心选择性质(greedy-choice property):我们可以通过做出局部最优(贪心)选择来构造全局最优解。换句话说，当进行选择时，我们直接做出在当前问题中看来最优的选择，而不必考虑子问题的解。<br>
这也是贪心算法与动态规划的不同之处。在动态规划方法中，每个步骤都要进行一次选择， 但选择通常依赖于子问题的解。因此，我们通常以一种自底向上的方式求解动态规划问题，先求解较小的子问题，然后是较大的子问题(我们也可以自顶向下求解，但需要备忘机制。当然，即使算法是自顶向下进行计算，我们仍然需要先求解子问题再进行选择)。在贪心算法中，我们总是做出当时看来最佳的选择，然后求解剩下的唯一的子问题。贪心算法进行选择时可能依赖之前做出的选择，但不依赖任何将来的选择或是子问题的解。因此，与动态规划先求解子问题才能进行第一次选择不同，贪心算法在进行第一次选择之前不求解任何子问题。一个动态规划算法是自底向上进行计算的，而一个贪心算法通常是自顶向下的，进行一次又一次选择，将给定问题实例变得更小。<br>
当然，我们必须证明每个步骤做出贪心选择能生成全局最优解。如定理 16.1 所示，这种证明通常首先考查某个子问题的最优解，然后用贪心选择替换某个其他选择来修改此解，从而得到一个相似但更小的子问题。<br>
如果进行贪心选择时我们不得不考虑众多选择，通常意味着可以改进贪心选择，使其更为高效。例如，在活动选择问题中，假定我们已经将活动按结束时间单调递增顺序排好序，则对每个活动能够只需处理一次。通过对输人进行预处理或者使用适合的数据结构(通常是优先队列), 我们通常可以使贪心选择更快速，从而得到更高效的算法。</p>
<p><strong>最优子结构</strong><br>
如果一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质。此性质是能否应用动态规划和贪心方法的关键要素。我们还是以 16.1 节的活动选择问题为例，如果一个子问题 $\mathcal{S}<em>{ij}$ 的最优解包含活动$a_k$,那么它必然也包含子问题 $\mathcal{S}</em>{ik}$和 $\mathcal{S}<em>{kj}$的最优解。给定这样的最优子结构，我们可以得出结论，如果知道$S</em>{ij}$的最优解应该包含哪个活动$a_k$,就可以组合$a_k$以及$S_{ik}$和$S_{kj}$的最优解中所有活动来构造$S_{ij}$的最优解。基于对最优子结构的这种观察结果，我们就可以设计出递归式(16.2)来描述最优解值的计算方法。<br>
当应用于贪心算法时，我们通常使用更为直接的最优子结构。如前所述，我们可以假定，通<br>
过对原问题应用贪心选择即可得到子问题。我们真正要做的全部工作就是论证：将子问题的最优解与贪心选择组合在一起就能生成原问题的最优解。这种方法隐含地对子问题使用了数学归纳法，证明了在每个步骤进行贪心选择会生成原问题的最优解。</p>
<p><strong>贪心对动态规划</strong><br>
由于贪心和动态规划策略都利用了最优子结构性质，你可能会对一个可用贪心算法求解的问题设计一个动态规划算法，或者相反，对一个实际上需要用动态规划求解的问题使用了贪心方法。为了说明两种方法之间的细微差别，我们研究一个经典最优化问题的两个变形。<br>
0-1背包问题(0-1 knapsack problem) 是这样的：一个正在抢劫商店的小偷发现了个商品， 第$i$个商品价值$v_i$美元，重$w_i$磅，$v_i$和$w_i$都是整数。这个小偷希望拿走价值尽量高的商品，但他的背包最多能容纳$W$磅重的商品，$W$ 是一个整数。他应该拿哪些商品呢？(我们称这个问题是 0-1 背包问题，因为对每个商品，小偷要么把它完整拿走，要么把它留下；他不能只拿走一个商品的一部分，或者把一个商品拿走多次。)<br>
在分数背包问题(fractional knapsack problem)中，设定与 0-1 背包问题是一样的，但对每个商品，小偷可以拿走其一部分，而不是只能做出二元(0-1)选择。你可以将 0-1 背包问题中的商品想象为金锭，而分数背包问题中的商品更像金砂。<br>
两个背包问题都具有最优子结构性质。对 0-1 背包问题，考虑重量不超过$W$ 而价值最高的装包方案。如果我们将商品$j$从此方案中删除，则剩余商品必须是重量不超过$W-w_j$的价值最高的方案(小偷只能从不包括商品$j$的$n-1$个商品中选择拿走哪些)。<br>
虽然两个问题相似，但我们用贪心策略可以求解分数背包问题，而不能求解 0-1 背包问题。为了求解分数背包问题，我们首先计算每个商品的每磅价值$v_i/w_i$。遵循贪心策略，小偷首先尽量多地拿走每磅价值最高的商品。如果该商品已全部拿走而背包尚未满，他继续尽量多地拿走每磅价值第二高的商品，依此类推，直至达到重量上限$W$。因此，通过将商品按每磅价值排序， 贪心算法的运行时间为 O($n\lg n$)。我们将分数背包问题的贪心选择性质的证明留作练习 16. 2-1。<br>
为了说明这一贪心策略对 0-1 背包问题无效，考虑图 16-2(a)所示的问题实例。此例包含 3个商品和一个能容纳 50 磅重量的背包。商品 1重 10 磅，价值 60 美元。商品 2重 20 磅，价值100 美元。商品 3 重 30 磅，价值 120 美元。因此，商品 1 的每磅价值为 6 美元，高于商品 2 的每磅价值(5 美元)和商品 3 的每磅价值(4 美元)。因此，上述贪心策略会首先拿走商品 1。但是， 如图 16-2(b)的实例分析所示，最优解应该拿走商品 2 和商品 3,而留下商品 1。拿走商品 1 的两种方案都是次优的。<br>
但是，如图 16-2©所示，对于分数背句问题，上述贪心策略首先拿走商品 1,是可以生成最优解的。拿走商品1的策略对 0-1 背包问题无效是因为小偷无法装满背包，空闲空间降低了方案的有效每磅价值。在 0-1 背包问题中，当我们考虑是否将一个商品装人背包时，必须比较包含此商品的子问题的解与不包含它的子问题的解，然后才能做出选择。这会导致大量的重叠子问题——动态规划的标识。<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89image%5Ce431589161c143bcb93d51570bc80f11.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h1>赫夫曼编码</h1>
<p>赫夫曼编码可以很有效地压缩数据:通常可以节省20%~90%的空间,具体压缩率依赖于数据的特性。我们将待压缩数据看做字符序列。根据每个字符的出现频率,赫夫曼贪心算法构造出字符的最优二进制表示。<br>
假定我们希望压缩一个10万个字符的数据文件。图16-3给出了文件中所出现的字符和它们的出现频率。也就是说,文件中只出现了6个不同字符,其中字符a出现了45000次。<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89image%5C385fde45f7d541d58a3da3a9e21da77a.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
我们有很多方法可以表示这个文件的信息。在本节中，我们考虑一种二进制字符编码(或简称编码)的方法，每个字符用一个唯一的二进制串表示，称为码字。如果使用定长编码，需要用3位来表示 6 个字符：a=000, b=001, …, f=101。这种方法需要 300 000 个二进制位来编码文件。是否有更好的编码方案呢？<br>
变长编码(variable-length code)可以达到比定长编码好得多的压缩率，其思想是赋予高频字符短码字，赋予低频字符长码字。图16-3 显示了本例的一种变长编码：1位的串0表示 a,4位的串 1100 表示 f。因此，这种编码表示此文件共需$(45\cdot1+13\cdot3+12\cdot3+16\cdot3+9\cdot4+5\cdot4)\cdot1000=224$ 000 位与定长编码相比节约了25%的空间。实际上，我们将看到，这是此文件的最优字符编码。</p>
<p><strong>前缀码</strong><br>
我们这里只考虑所谓前缀码(prefix code)$^{\ominus}$,即没有任何码字是其他码字的前缀。虽然我们这里不会证明，但与任何字符编码相比，前缀码确实可以保证达到最优数据压缩率，因此我们只关注前缀码，不会丧失一般性。<br>
任何二进制字符码的编码过程都很简单，只要将表示每个字符的码字连接起来即可完成文件压缩。例如，使用图 16-3 所示的变长前缀码，我们可以将 3 个字符的文件 abc编码为 0·101 · $100=0101100,“·”$表示连结操作。<br>
前缀码的作用是简化解码过程。由于没有码字是其他码字的前缀，编码文件的开始码字是无歧义的。我们可以简单地识别出开始码字，将其转换回原字符，然后对编码文件剩余部分重复这种解码过程。在我们的例子中，二进制串 001011101 可以唯一地解析为$0\cdot0\cdot101\cdot1101$,解码为 aabe。<br>
解码过程需要前缀码的一种方便的表示形式，以便我们可以容易地截取开始码字。一种二叉树表示可以满足这种需求，其叶结点为给定的字符。字符的二进制码字用从根结点到该字符叶结点的简单路径表示，其中 0 意味着“转向左孩子”,1 意味着“转向右孩子”。图 16-4 给出了两个编码示例的二叉树表示。注意，编码树并不是二叉搜索树，因为叶结点并未有序排列，而内部结点并不包含字符关键字。<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89image%5C55dde6b529d449ba91c3d640bf0b40e4.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
文件的最优编码方案总是对应一棵满(full)二叉树，即每个非叶结点都有两个孩子结点(参见练习 16.3-2)。前文给出的定长编码实例不是最优的，因为它的二叉树表示并非满二叉树，如图 16-4(a)所示：它包含以 10 开头的码字，但不包含以 11 开头的码字。现在我们可以只关注满二叉树了，因此可以说，若$C$ 为字母表且所有字符的出现频率均为正数，则最优前缀码对应的树恰有$|C|$个叶结点，每个叶结点对应字母表中一个字符，且恰有$|C|-1$ 个内部结点。<br>
给定一棵对应前缀码的树$T$,我们可以容易地计算出编码一个文件需要多少个二进制位。对于字母表$C$ 中的每个字符$c$,令属性 $c.freq$ 表示 $c$ 在文件中出现的频率，令$d_T©$表示 $c$ 的叶结点在树中的深度。注意，$d_T©$也是字符 c 的码字的长度。则编码文件需要<br>
$$B(T)=\sum_{c\in C}c.freq\bullet d_T©$$<br>
(16.4)<br>
个二进制位，我们将$B(T)$定义为$T$的代价。</p>
<p><strong>构造赫夫曼编码</strong><br>
赫夫曼设计了一个贪心算法来构造最优前缀码，被称为赫夫曼编码(Huffman code)。与16.2 节中我们的观察一致，它的正确性证明也依赖于贪心选择性质和最优子结构。接下来，我们并不是先证明这些性质成立然后再设计算法，而是先设计算法。这样做可以帮助我们明确算法是如何做出贪心选择的。<br>
在下面给出的伪代码中，我们假定$C$是一个$n$个字符的集合，而其中每个字符$c\in C$都是一个对象，其属性$c.freq$给出了字符的出现频率。算法自底向上地构造出对应最优编码的二叉树$T$。它从$|C|$个叶结点开始，执行$|C|-1$ 个“合并”操作创建出最终的二叉树。算法使用一个以属性 freq 为关键字最小优先队列$Q$,以识别两个最低频率的对象将其合并。当合并两个对象时， 得到的新对象的频率设置为原来两个对象的频率之和。</p>
<p>HUFFMAN$( C)$<br>
1 $n= | C|$<br>
2 $Q=C$<br>
3 for $i= 1\textbf{to }n- 1$<br>
4 allocate a new node $z$<br>
5 $z.left=x=$EXTRACT-MIN(Q)<br>
6 $z.right=y=$EXTRACT-MIN(Q)<br>
7 $z.freq=x.freq+y.freq$<br>
8 INSERT$(Q,z)$<br>
9 return EXTRACT-MIN(Q)<br>
// return the root of the tree</p>
<p>对前文给出的例子，赫夫曼算法的执行过程如图 16-5 所示。由于字母表包含 6 个字母，初始队列大小为$n=6$,需要 5 个合并步骤构造二叉树。最终的二叉树表示最优前缀码。一个字母的码字为根结点到该字母叶结点的简单路径上边标签的序列。<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89image%5Cd8622b053fa64825886dd36c5c867545.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
第 2 行用$C$ 中字符初始化最小优先队列$Q$。第 3~8 行的 for 循环反复从队列中提取两个频率最低的结点$x$和 y,将它们合并为一个新结点$z$,替代它们。$z$的频率为$x$和 y 的频率之和(第 7行)。结点$z$将$x$作为其左孩子，将 y 作为其右孩子(顺序是任意的，交换左右孩子会生成一个不同的编码，但代价完全一样)。经过$n-1$次合并后，第 9 行返回队列中剩下的唯一结点——编码树的根结点。<br>
如果我们不使用变量$x$和 y(第 5、6 行直接对$z.left$和$z.right$直接赋值，将第 7 行改为$z.freq=z.left.freq+z.right.freq)$,算法还是会生成相同的结果，但后面在证明算法正确性时，我们需要用到结点名$x$和 y。因此，保留$x$和 y 更方便。<br>
为了分析赫夫曼算法的运行时间，我们假定$\mathbb{Q}$是使用最小二叉堆实现的(参见第 6 章)。对一个 $n$ 个字符的集合$C$,我们在第 2 行用 BUILD-MIN-HEAP 过程(参见 6.3 节)将 $Q$初始化，花费时间为$O(n)$。第 3~8 行的 for 循环执行了 $n-1$ 次，且每个堆操作需要 O(lg$n$)的时间，所以循环对总时间的贡献为$O(n\lg n)$。因此，处理一个$n$个字符的集合，HUFFMAN 的总运行时间为$O(n\lg n)$。如果将最小二叉堆换为 van Emde Boas 树(参见第 20 章),我们可以将运行时间减少为$O(n\lg\lg n)$。</p>
<p><strong>赫夫曼算法的正确性</strong><br>
为了证明贪心算法 HUFFMAN 是正确的，我们证明确定最优前缀码的问题具有贪心选择和最优子结构性质。下面的引理证明问题具有贪心选择性质。<br>
<strong>引理 16.2</strong><br>
令 C为一个字母表，其中每个字符 c$\in C$都有一个频率 c. freq。令 x和y是C中频率最低的两个字符。那么存在$C$的一个最优前缀码，$x$和y的码字长度相同，且只有最后一个二进制位不同。<br>
<strong>证明</strong><br>
证明的思路是令$T$表示任意一个最优前缀码所对应的编码树，对其进行修改，得到表示另外一个最优前缀码的编码树，使得在新树中，$x$和 y 是深度最大的叶结点，且它们为兄弟结点。如果可以构造这样一棵树，那么$x$ 和 y 的码字将有相同长度，且只有最后一位不同。<br>
令$a$ 和$b$ 是$T$ 中深度最大的兄弟叶结点。不失一般性，假定 $a.freq\leqslant b.freq$ 且 $x.freq\leqslant$ $y.freq$。由于$x.freq$和 y.freq是叶结点中最低的两个频率，而$a.freq$和$b.freq$是两个任意频率，因此，我们有$x.freq\leqslant a.freq$且 y. $freq\leqslant b.freq$。<br>
在证明的剩余部分，有可能$x.freq=a.freq$或 y.$freq=b.freq$成立。但是，如果$x.freq=$ $b.freq,则有a.freq=b.freq=x.freq=y.freq(参见练习16.3-1),此时引理显然是成立的。因$ 此，我们假定$x.freq\neq b.freq$,这意味着$x\neq b$。<br>
如图 16-6 所示，我们在$T$中交换$x$和$a$生成一棵新树$T^{\prime}$,并在$T^{\prime}$中交换$b$和 y 生成一棵新树 $T^{\prime\prime}$,那么在 $T^{\prime\prime}$中 $x$ 和 y 是深度最深的两个兄弟叶结点(注意，如果 $x= b$但 y$\neq a$,那么 $T^{\prime\prime}$中$x$ 和 y 不是深度最深的兄弟叶结点)。由公式(16.4), $T$ 和 $T^{\prime}$的代价差为<br>
$$\begin{aligned}B(T)-B(T^{\prime})&amp;=\sum_{c\in C}c.:freq\bullet d_{T}©-\sum_{c\in C}c.:freq\bullet d_{T}©\&amp;=x.:freq\bullet d_{T}(x)+a.:freq\bullet d_{T}(a)-x.:freq\bullet d_{T}(x)-a.:freq\bullet d_{T}(a)\&amp;=x.:freq\bullet d_{T}(x)+a.:freq\bullet d_{T}(a)-x.:freq\bullet d_{T}(a)-a.:freq\bullet d_{T}(x)\&amp;=(a.:freq-x.:freq)(d_{T}(a)-d_{T}(x))\&amp;\geqslant0\end{aligned}$$<br>
因为 $a.freq-x.freq$ 和$d_T(a)-d_T(x)$都是非负的。更具体地，$a.freq-x.freq$ 是非负的，因为$x$ 是出现频率最低的叶结点；$d_T(a)-d_T(x)$是非负的，因为$a$ 是$T$ 中深度最深的叶结点。类似地，交换 y 和$b$也不能增加代价，所以$B(T^{\prime})-B(T^{\prime\prime})$也是非负的。因此$B(T^{\prime\prime})\leqslant B(T)$,由于$T$ 是最优的，我们有 $B(T)\leqslant B(T^{\prime\prime})$,这意味着 $B(T^\prime\prime)=B(T)$。因此，$T^\prime\prime$也是最优树，且$x$ 和$y$ 是其中深度最深的兄弟叶结点，引理成立。<br>
<img src="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%B8%93%E9%A2%98%E5%86%85%E5%AE%B9%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89image%5Cf5ebab4b230544c4af80b80ab108a14c.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>
引理 16.2 说明，不失一般性，通过合并来构造最优树的过程，可以从合并出现频率最低的两个字符这样一个贪心选择开始。为什么这是一个贪心选择？我们可以将一次合并操作的代价看做被合并的两项的频率之和。练习 16.3-4 要求证明编码树构造的总代价等于所有合并操作的代价之和。在每个步骤可选的所有合并操作中，HUFFMAN选择是代价最小的那个。<br>
下面的引理证明了构造最优前缀码的问题具有最优子结构性质。<br>
<strong>引理 16.3</strong><br>
令$C$为一个给定的字母表，其中每个字符 $c\in C$ 都定义了一个频率 $c.freq$。令 $x$ 和y是C 中频率最低的两个字符。令$C^\prime$为$C$去掉字符$x$ 和$y$,加入一个新字符$z$后得到的字母表，即$C^\prime=C-\left{x,y\right}\bigcup\left{z\right}$。类似$C$,也为$C^\prime$定义 freq,不同之处只是 $z.freq=x.freq+$ y. freq。令 $T^{\prime}$为字母表 $C^{\prime}$的任意一个最优前缀码对应的编码树。于是我们可以将 $T^{\prime}$中叶结点 $z$ 替换为一个以$x$ 和 y 为孩子的内部结点，得到树 $T$,而$T$表示字母表$C$ 的一个最优前缀码。<br>
<strong>证明</strong><br>
首先说明如何用树$T^{\prime}$的代价$B(T^{\prime})$来表示树$T$的代价$B(T)$,方法是考虑公式(16.4) 中每项的代价。对于每个字符$c\in C-{x,y}$,我们有$d_T©=d_{T^{\prime}}©$,因此$c.freq\bullet d_T©=$ $c.freq\bullet d_{T^{\prime}}©。由于d_{T}(x)=d_{T}(y)=d_{T^{\prime}}(z)+1,我们有$<br>
$$\begin{aligned}x.:freq\bullet d_{T}(x)+y.:freq\bullet d_{T}(y)&amp;=(x.:freq+y.:freq):(d_{T^{\prime}}(z)+1)\&amp;=z.:freq\bullet d_{T^{\prime}}(z)+(x.:freq+y.:freq)\end{aligned}$$<br>
于是可以得到结论</p>
<p>$$B(T)=B(T’)+x.:freq+y.:freq$$</p>
<h2 id="或者等价地">或者等价地</h2>
<p>$$B(T’)=B(T)-x.:freq-y.:freq$$<br>
现在用反证法来证明引理。假定$T$对应的前缀码并不是$C$ 的最优前缀码。存在最优编码树$T^{\prime\prime}$满足 $B(T^\prime\prime)&lt;B(T)$。不失一般性(由引理 16.2),$T^\prime\prime$包含兄弟结点 $x$ 和 y。令 $T^{\prime\prime}$为将 $T^\prime\prime$中 $x$、 $y$及它们的父结点替换为叶结点$z$得到的树，其中$z.freq=x.freq+y.freq$。于是<br>
$$B(T^{\prime\prime})=B(T^{\prime\prime})-x.freq-y.freq&lt;B(T)-x.freq-y.freq=B(T^{\prime})$$<br>
与 $T^{\prime}$对应$C^{\prime}$的一个最优前缀码的假设矛盾。因此，$T$ 必然表示字母表$C$ 的一个最优前缀码。 I<br>
<strong>定理 16.4</strong><br>
过程 HUFFMAN 会生成一个最优前缀码。<br>
<strong>证明</strong><br>
由引理 16.2 和引理 16.3 即可得。</p>
<h1>拟阵和贪心算法</h1>
<p>本节概略介绍一种与贪心算法相关的漂亮的理论。该理论描述了很多贪心方法生成最优解的情形，它涉及一种称为“拟阵”的组合结构。虽然这种理论不能涵盖贪心方法适用的所有情况(例如，它不能用于前面的活动选择问题以及赫夫曼编码问题),但它确实覆盖了很多有实际意义的情况。而且，这种理论的扩展还覆盖了其他很多应用，参见本章末尾的注记。</p>
<p><strong>拟阵</strong><br>
一个拟阵(matroid)就是一个满足如下条件的序偶$M=(S,I):$<br>
1.S 是一个有限集。<br>
2.$\mathcal{I}$是 S 的子集的一个非空族，这些子集称为 S 的独立子集，使得如果 $B\in\mathcal{I}$且 $A\subseteq B$,则<br>
$A{\in}\mathcal{I}$。如果$I$满足此性质，则称之为遗传的。注意，空集の必然是$I$的成员。<br>
3.若$A\in\mathcal{I}$、$B\in\mathcal{I}$且$|A|&lt;|B|$,那么存在某个元素$x\in B-A$,使得$A\cup\langle x\rangle\in\mathcal{I}$,则称$M$满足交换性质。<br>
“拟阵”一词最早是 Hassler Whitney 提出的。他当时在研究矩阵拟阵，其中 S 是一个给定矩阵的所有行，而行之间的独立性质与通常意义上的线性无关性质是等价的。练习 16.4-2 要求证明，这个结构定义了一个拟阵。<br>
另一个拟阵的例子是图拟阵(graphic matroid)$M_G=(S_G,I_G)$,它定义在一个给定的无向图<br>
$G{=}(V,E)$之上：<br>
$\cdot S_G$ 定义为$E$,即$G$的边集。<br>
·如果$A$是$E$的子集，则$A\in\mathcal{I}<em>G$当且仅当$A$是无圈的。也就是说，一组边$A$是独立的当<br>
且仅当子图$G</em>{A}=(V,A)$形成一个森林。<br>
图拟阵$M_G$与最小生成树问题是紧密相关的，第 23 章会详细讨论。<br>
定理 16.5 如果 $G=(V,E)$是一个无向图，则 $M_{\mathrm{G}}=(S_{\mathrm{G}},I_{\mathrm{G}})$是一个拟阵。<br>
证明 显然$S_G=E$是一个有限集。而且，$I_G$是遗传的，因为森林的子集还是森林。换句话<br>
说，从一个无圈的边集中删除边不会产生圈。<br>
因此，接下来只需证明$M_G$满足交换性质。假定$G_A=(V,A)$和$G_B=(V,B)$是$G$的森林，<br>
且$|B|&gt;|A|$。也就是说，$A$ 和$B$ 是无圈边集，且$B$包含更多的边<br>
我们有结论：$F=(V_F,E_F)$恰好包含$|V_F|-|E_F|$棵树。为了证明此结论，假定$F$包含$t$ 棵<br>
树，其中第$i$棵树包含$v_i$个顶点和$e_i$条边。于是有<br>
(由定理 B.2)<br>
$$\begin{aligned}&amp;\mid E_{F}\mid=\sum_{i=1}^{t}e_{i}=\sum_{i=1}^{t}(v_{i}-1)\&amp;=\sum_{i=1}^{t}v_{i}-t=\mid V_{F}\mid-t\\end{aligned}$$<br>
这意味着 $t=|V_F|-|E_F|$。因此，森林$G_{\mathrm{A}}$ 包含 $|V|-|A|$棵树，森林$G_B$ 包含$|V|-|B|$ 棵树。<br>
由于森林$G_\mathrm{B}$中树的数量比森林$G_\mathrm{A}$少，它必然包含某棵树$T$,其中两个顶点在森林$G_\mathrm{A}$中属于两棵不同的树。而且，由于$T$是连通的，它必然包含一条边($u$,$v$),使得顶点$u$ 和$\upsilon$在森林$G_{\mathrm{A}}$ 中属于两棵不同的树。由于边($u,v)$连接了森林$G_\mathrm{A}$ 中两棵不同的树中的顶点，可以将边$(u,v)$加入森林$G_A$,而不会产生圈。因此，$M_\mathrm{G}$ 满足交换性质。至此，已证明 $M_\mathrm{G}$ 是拟阵。<br>
给定一个拟阵$M=(\mathcal{S},\mathcal{I})$,如果对一个集合$A\in\mathcal{I}$和一个元素$x\notin\mathcal{A}$,将$x$加人$A$会保持独立性质，则称$x$是$A$的一个扩展。也就是说，如果$A\bigcup{x}\in\mathcal{I}$,则$x$是$A$的一个扩展。我们以图拟阵$M_G$为例，如果 $A$ 是一个边独立集，那么边 $e$ 是$A$ 的一个扩展当且仅当$e$ 不在$A$ 中且将$e$ 加入$A$ 中不会形成圈。<br>
对拟阵$M$中的一个独立子集$A$,如果它不存在扩展，则称它是最大的。也就是说，如果$A$不包含于任何更大的$M$的独立子集中，则$A$是最大的。下面的性质通常很有用。<br>
<strong>定理 16.6</strong><br>
拟阵中所有最大独立子集都具有相同大小。<br>
<strong>证明</strong><br>
假定命题不成立，拟阵$M$存在一个最大独立子集$A$ 和另一个更大的独立子集$B$。那么，交换性质意味着对于某个$x\in B-A$,我们可以将$A$扩展为一个更大的独立子集$A\cup{x}$,与$A$是最大独立子集的假设矛盾。<br>
作为此定理的一个示例，我们考虑一个连通无向图$G$的图拟阵$M_\mathrm{G}$。$M_\mathrm{G}$的每个最大独立子集必定是一棵边数为$\mid V\mid-1$,连接了$G$ 的所有顶点的自由树。这样一棵树称为$G$ 的生成树。<br>
如果一个拟阵$M=(\mathcal{S},\mathcal{I})$关联一个权重函数$w$,为每个元素$x\in S$赋予一个严格大于0 的权重$w(x)$,则称$M$是加权的。通过求和，可将权重函数$w$扩展到 S 的任意子集$A:$<br>
$$w(A)=\sum_{x\in A}w(x)$$<br>
例如，如果令$w(e)$表示图拟阵$M_{\mathrm{c}}$中边$e$的权重，那么$w$(A)就表示边集$A$中所有边的权重之和。</p>
<p><strong>加权拟阵上的贪心算法</strong><br>
很多可以用贪心算法得到最优解的问题都可以形式化为在一个加权拟阵中寻找最大权重独立子集的问题。也就是说，给定一个加权拟阵 $M=(\mathcal{S},\mathcal{I})$,我们希望寻找独立集 $A\in\mathcal{I}$使得$w(A)$最大。我们称这种独立且具有最大可能权重的子集为拟阵的最优子集。由于任何元素 $x\in S$ 的权重$w(x)$都是正的，则最优子集必然是最大独立子集——它总是有助于使 A 尽可能大。<br>
例如，在最小生成树问题中，给定一个连通无向图$G=(V,E)$和一个长度函数 $w$,使得$w(e)$表示边 e 的长度(正值)(这里我们用“长度”表示图中边的原始权重，用“权重”表示关联的拟阵的权重)。我们希望找到一个边的子集，能连接所有顶点，且具有最小总长度。为了将此问题描述为寻找拟阵最优子集的问题，考虑加权拟阵$M_G$,其权重函数为$w^{\prime}$,这里$w^{\prime}(e)=w_0-w$ (e),其中$w_{\mathrm{b}}$为大于最大边长度的值。在此加权拟阵中，所有权重均为正，且最优子集即为原图中的最小总长度生成树。更具体地，每个最大独立子集$A$都对应一棵$\mid V\mid-1$条边的生成树， 而且由于对所有最大独立子集 A,有<br>
$$w^{\prime}(A)=\sum_{\epsilon\in A}w^{\prime}(e)=\sum_{\epsilon\in A}(w_{b}-w(e))=(\mid V\mid-1)w_{0}-\sum_{\epsilon\in A}w(e)=(\mid V\mid-1)w_{0}-w(A)$$<br>
因此，最大化 $w^{\prime}(A)$必然最小化 $w(A)$。因此，任何能求得任意拟阵中最优子集 A 的算法，均可求解最小生成树问题。<br>
之后我们将给出最小生成树的算法，但现在我们给出适用于任何加权拟阵的算法。算法接受一个加权拟阵$M=(\mathcal{S},\mathcal{I})$及其关联的正加权函数$w$作为输人，返回最优子集$A$。在我们的伪代码中，我们用$M.S$ 和$M.I$表示 $M$ 的组成部分，加权函数表示为 $w$。这个算法是一个贪心算法， 因为它按权重单调递减的顺序考虑每个元素$x\in\mathcal{S}$,如果$\mathcal{AU}\left{x\right}$是独立的，就立即将$x$加人到累积集合A中。</p>
<p>$GREEDY(M,w)$<br>
1 $A= \varnothing$<br>
2 sort $M.S$ into monotonically decreasing order by weight $w$<br>
3 for each $x\in M.$ S,taken in monotonically decreasing order by weight $w(x)$<br>
4$\mathbf{if}A\bigcup{x}\in M.I$<br>
5 $A=A\bigcup{x}$<br>
6 return A</p>
<p>第 4 行检查加入$x$后$A$是否保持独立集性质，若是，则在第 5 行将$x$加人$A$,否则丢弃$x$。由于空集是独立的，且每步 for 循环都保持$A$的独立性，因此由归纳法可知，$A$始终是独立的。因此，GREEDY 总是返回一个独立子集$A$。稍后，我们将会看到$A$是具有最大可能权重的子集， 因而是一个最优子集。<br>
GREEDY 的运行时间很容易分析。令$n$表示$|S|$ ,则排序阶段花费时间为 O($n\lg n$)。第 4行严格执行了$n$次，每次处理 S 的一个元素。第 4 行每执行一次需检查一个集合 $A\bigcup\left{x\right}$是否独立。如果每次检查花费时间为$O(f(n))$,则算法运行时间为$O(n\lg n+nf(n))$。<br>
现在我们证明 GREEDY 返回一个最优子集。</p>
<p><strong>引理 16.7(拟阵具有贪心选择性质)</strong><br>
假定 $M=(\mathcal{S},\mathcal{I})$是一个加权拟阵，加权函数为 $w$,且$S$已按权重单调递减顺序排序。令$x$ 是S 中第一个满足{}x}独立的元素(如果存在)。如果存在这样的$x$,那么存在 S的一个最优子集$A$包含$x$。<br>
<strong>证明</strong><br>
如果不存在这样的$x$,唯一的独立子集是空集，引理显然成立。否则，令$B$为任意非空最优子集。假定$x\notin B$,因为否则的话，显然$B$就是我们要找的包含$x$的最优子集$A$ 。<br>
我们有结论$B$中元素的权重都不大于$w(x)$。原因在于，我们观察到 y$\in B$意味着{y}是独立的(因为 $B\in\mathcal{I}$且$\mathcal{I}$是遗传的),因此我们选择 $x$ 的方式(第一个形成独立集的元素)保证了对任意$y\in B$,有$w(x)\geqslant w(y)$。<br>
于是可以这样构造集合$A$。以$A=\left{x\right}$开始，由于$x$的性质，集合$A$保证是独立的。使用交换性质，反复寻找$B$中一个可以加人$A$中的新元素(同时保持$A$的独立性),直至$|A|=|B|$。此时，$A$和$B$的差别仅在于$A$包含$x$,而$B$包含另一个元素 y。也就是说，$A=B-\langle y\rangle\bigcup\langle x\rangle$,$y$为$B$ 中某个元素，且<br>
$$w(A)=w(B)-w(y)+w(x)\geqslant w(B)$$<br>
由于集合$B$是最优的，因此集合$A$必然也是最优的，且包含$x$。<br>
下面证明如果一个元素在初始时不是最优的选择，那么在随后也不会被选人最优集合中。<br>
<strong>引理 16.8</strong><br>
令 M=(S, I)是一个拟阵。如果$x$是S 中一个元素，而且是 S的某个独立子集<br>
$A$的一个扩展，则$x$也是Ø的一个扩展。<br>
<strong>证明</strong><br>
由于 $x$ 是$A$ 的一个扩展，可知 $A\bigcup\left{x\right}$是独立的。由于$\mathcal{I}$是遗传的，$\left{x\right}$必然是独立的。因此，$x$ 是$\varnothing$的一个扩展。<br>
<strong>推论 16.9</strong><br>
令$M=(S,I)$是一个拟阵。如果 $x$ 是$S$ 中一个元素，且它不是Ø的一个扩展，那么它也不是 S的任何独立子集 A 的扩展。<br>
<strong>证明</strong><br>
此推论为引理 16.8 的逆否命题。<br>
推论 16.9 表明，任何元素如果首次不能用于构造独立集，则之后永远也不可能被用到了。因此，GREEDY 跳过 S 中那些不是Ø的扩展的起始元素，不会导致错误结果，因为那些元素永远不会被用到。<br>
<strong>引理 16. 10(拟阵具有最优子结构性质)</strong><br>
令 $M=(S,I)$是一个加权拟阵，$x$ 是$S$ 中第一个被GREEDY算法选出的元素，则接下来寻找一个包含$x$的最大权重独立子集的问题归结为寻找加权拟阵$M^{\prime}=(S^{\prime},I^{\prime})$的一个最大权重独立子集的问题，其中<br>
$$\begin{aligned}&amp;S^{\prime}={y\in S{:}{x,y}\in\mathcal{I}}\&amp;\mathcal{I}^{\prime}={B\subseteq S-{x}:B\cup{x}\in\mathcal{I}}\end{aligned}$$<br>
$M^{\prime}$的权重函数就是$M$ 的权重函数，但只局限于 S’中元素。(我们称 $M^{\prime}$为 $M$ 在元素 $x$ 上的收缩<br>
(contraction)。)<br>
<strong>证明</strong><br>
若$A$是$M$的任意一个包含$x$的最大权重独立子集，则$A^\prime=A-{x}$是$M^{\prime}$的一个独立子集。相反，任何$M^{\prime}$的独立子集 $A^{\prime}$可生成$M$ 的独立子集 $A=A^{\prime}\bigcup{x}$。由于对两种情况均有$w(A)=w(A^{\prime})+w(x)$,因此$M$的包含$x$的最大权重独立子集必然生成$M^\prime$的最大权重独立子集，反之亦然。<br>
**定理 16. 11(拟阵上贪心算法的正确性) **<br>
若$M=(S,I)$是一个加权拟阵，权重函数是$w$,那么 GREEDY(M, w)返回一个最优子集。<br>
<strong>证明</strong><br>
由推论 16.9, GREEDY 跳过的任何不是Ø的扩展的起始元素可永远丢弃，因为这些元素永远不会被用到。一旦 GREEDY 算法选出第一个元素$x$,引理 16.7 表明算法将$x$加人$A$不会导致错误结果，因为必然存在包含$x$的最优子集。最终，引理 16.10 说明剩下的问题就是如何寻找拟阵$M^{\prime}$的最优子集了，$M^{\prime}$是$M$在$x$ 上的收缩。在 GREEDY将 A 设置为{x}后，我们可以将之后它的所有步骤解释为拟阵$M^{\prime}=(S^{\prime},\mathcal{I}^{\prime})$上的操作，因为对所有集合 $B\in\mathcal{I}^{\prime},B$ 在$M^{\prime}$中独立当且仅当 $B\bigcup\left{x\right}$在 $M$ 中独立。因此，GREEDY 随后的操作将会找到 $M^{\prime}$的一个最大权重独立子集，而其所有操作的总体效果就是找到$M$的一个最大权重独立子集。</p>
<h1>用拟阵求解任务调度问题</h1>
<p>一个可以用拟阵来求解的有趣问题是单处理器上的单位时间任务最优调度问题，其中每个任务有一个截止时间以及错过截止时间后的惩罚值。问题看起来很复杂，但我们可以用一个异常简单的方法求解它——将其转换为一个拟阵并用贪心算法求解。<br>
单位时间任务是严格需要一个时间单位来完成的作业，如运行于计算机上的一个程序。给定一个单位时间任务的有限集合 S,对 S 的一个调度是指 S 的一个排列，它指明了任务执行的顺序。第一个被调度的任务开始于时刻 0,终止于时刻 1,第二个任务开始于时刻 1,终止于时刻$2,依此类推$。<br>
单处理器上带截止时间和惩罚的单位时间任务调度问题有如下输人。<br>
$\bullet$ $n$个单位时间任务的集合 S=$\langle a_1$, $a_1, \cdots$, $a_n\rangle$。<br>
$\bullet n$ 个整数截止时间$d_1,d_1,…,d_n$,每个$d_i$ 满足 $1\leqslant d_i\leqslant n$,我们期望任务$a_i$ 在时间$d_i$之前完成。<br>
$\bullet n$ 个非负权重或惩罚$w_1,w_2,\cdotp\cdotp\cdotp,w_n$,若任务 $a_i$ 在时间$d_i$ 之前没有完成，我们就会受到$w_i$ 这么多的惩罚，如果任务在截止时间前完成，则不会受到惩罚。<br>
我们希望找到 S 的一个调度方案，能最小化超过截止时间导致的惩罚总和。<br>
考虑一个给定的调度方案。如果方案中一个任务在截止时间后完成，我们称它是延迟的(late);否则，我们称它是提前的(early)。对于任意调度方案，我们总是可以将其转换为提前优先形式(early-first form),即将提前的任务都置于延迟的任务之前。原因在于，如果某个提前任务$a_i$位于某个延迟任务$a_j$之后，我们可以交换它们的位置，显然$a_i$仍然是提前的，$a_j$仍然是延迟的。<br>
而且，我们总是可以将一个任意的调度方案转换为规范形式(canonical form)——提前任务都在延迟任务之前，且提前任务按截止时间单调递增的顺序排列。为了进行这种转换，我们首先将调度方案转换为提前优先形式。然后，只要调度方案中存在两个提前任务 $a_i$ 和$a_j$,分别在时刻$k$和$k+1$完成，使得$d_j&lt;d_i$,我们就交换$a_i$和$\alpha_j$的位置。由于交换前$a_j$是提前的，我们有$k+1\leqslant d$,因此$k+1&lt;d_i$,因而交换后$a_i$是提前的。由于$a_j$被移动到更靠前的时间，因此在交换后它保持提前。<br>
这样，寻找最优调度方案的问题就归结为寻找提前任务子集 A 的问题。确定$A$之后，我们可以将$A$中元素按截止时间递增的顺序排列，然后将延迟任务(即 S-A)以任意顺序排列其后， 就得到了最优调度方案的规范形式。<br>
对于一个任务集合$A$,如果存在一个调度方案，使$A$中所有任务都不延迟，则称$A$是独立的。显然，一个调度方案的提前任务集合构成一个独立任务集。令$I$表示所有独立任务集的集合。<br>
下面我们考虑如何确定一个给定集合$A$是否独立的问题。对$t=0,1,2,…,n,令N_{\iota}(A)$<br>
表示$A$中截止时间小于等于$t$的任务数。注意，对任意集合$A$ 均 有 $N_0( A) = 0$。<br>
<strong>引理 16. 12</strong><br>
对任意任务集合$A$,下面性质是等价的：<br>
$1.A$是独立的。<br>
2. 对 $t=0,1,2,…,n$,有$N_t(A)\leqslant t.$<br>
3.如果$A$ 中任务按截止时间单调递增的顺序调度，那么不会有任务延迟。<br>
<strong>证明</strong><br>
为了证明由(1)可得(2),我们证明逆否命题：如果对某个$t,N_t(A)&gt;t$,则集合$A$ 的任何调度方案都会有任务延迟的情况发生，因为超过$t$个任务必须在时刻$t$前完成(而每个任务都花费一个时间单位)。因此，由(1)可得到(2)。如果(2)成立，则(3)必然也成立：当按截止时间单调递增顺序调度任务时，不会发生“卡住”的现象，因为(2)成立意味着第$i$大的截止时间至少是$i$。最后，由(3)显然能推导出(1)。<br>
利用引理 16.12 的性质 2,我们可以简单地计算出一个给定任务集合是否独立。<br>
最小化延迟任务的惩罚之和的问题与最大化提前任务的惩罚之和是等价的。下面的定理确保我们可以使用贪心算法求出总惩罚最大的独立任务集$A$。<br>
<strong>定理 16. 13</strong><br>
如果 S是一个给定了截止时间的单位时间任务集合，I是所有独立任务集合的集合，则对应的系统(S,I)是一个拟阵。<br>
<strong>证明</strong><br>
每个独立任务集合的子集必然也是独立的。为了证明交换性质，假定$B$和$A$是独立任务集合，且$|B|&gt;|A|$。令$k$ 是满足$N_t(B)\leqslant N_t(A)$的最大的 $t$(这样 $t$ 肯定是存在的，因为$N_{0}(A)=N_{0}(B)=0)$。由于$N_n(B)=\mid B\mid$且$N_n(A)=\mid A\mid$,但$\mid B\mid&gt;\mid A\mid$,因此对$k+1\leqslant$ $j\leqslant n$间的所有$j$,必然有 $k&lt;n$ 及$N_j(B)&gt;N_j(A)$。因此，$B$ 比$A$ 包含更多截止时间为$k+1$ 的任务。令$a_i$为$B-A$ 中截止时间为$k+1$ 的任务，令$A^\prime=A\bigcup\left{a_i\right}.$<br>
下面利用引理16.12 的性质 2 证明$A^\prime$必然是独立的。因为$A$是独立的，对$0\leqslant t\leqslant k$,我们有$N_{t}(A^{\prime})=N_{t}(A)\leqslant t$。因为$B$ 是独立的，对 $k&lt;t\leqslant n$,我们有 $N_{t}(A^{\prime})\leqslant N_{t}(B)\leqslant t$。因此，$A^\prime$是独立的，从而得证(S,$\mathcal{I}$)是一个拟阵。<br>
由定理 16. 11, 我们可以用贪心算法求出一个最大权重的独立任务集$A$。然后可以创建一个最优调度方案，以$A$ 中任务为提前任务。这个算法是求解单处理器上带截止时间和惩罚的单位时间任务调度问题的一种高效算法。使用 GREEDY 的运行时间为$O(n^2)$,因为算法共进行了$O(n)$独立性检查，每次花费 O($n$)时间(参见练习 16.5-2)。思考题 16-4 给出了一个更快的实现。<br>
图 16-7 给出了单处理器上带截止时间和惩罚}\&amp;\text{的单位时间任务调度问题的一个例子。在此例中,贪心算法按顺序选择任务 $a_1,a_2,a_3$\和$a_4$,然后拒绝$a_5$（因为$N_4({a_1,a_2,a_3,a_4,a_5})=5)$和$a_6$(因为$N_4$$({a_1,a_2,a_3,a_4,a_6})=5)$,最后接受$a_7$。最终的最优调度为总惩罚为$w_5+w_6=50。$</p>
<h1>引用及参考文献</h1>
<p>1.《算法导论》</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/" class="category-chain-item">数据结构与算法分析</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>数据结构与算法分析：专题内容——贪心算法（算法导论）</div>
      <div>https://mounthuangshan.github.io/数据结构与算法分析/数据结构与算法分析/数据结构与算法分析：专题内容——贪心算法（算法导论）/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>黄山</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年3月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E5%9B%BE%E7%AE%97%E6%B3%95%E5%90%97%E2%80%94%E2%80%94%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3+%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%EF%BC%89/" title="数据结构与算法分析：你真的理解图算法吗——单源最短路径（代码详解+万字长文）">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">数据结构与算法分析：你真的理解图算法吗——单源最短路径（代码详解+万字长文）</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9A%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%E5%9B%BE%E7%AE%97%E6%B3%95%E5%90%97%E2%80%94%E2%80%94%E6%89%80%E6%9C%89%E7%82%B9%E5%AF%B9%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%88%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%EF%BC%89/" title="数据结构与算法分析：你真的理解图算法吗——所有点对最短路径（代码详解）">
                        <span class="hidden-mobile">数据结构与算法分析：你真的理解图算法吗——所有点对最短路径（代码详解）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
