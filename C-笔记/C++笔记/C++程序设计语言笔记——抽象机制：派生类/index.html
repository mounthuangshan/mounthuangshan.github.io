

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="黄山">
  <meta name="keywords" content="C/C++,Python,C#,Go,Web,AI,游戏开发,网络安全">
  
    <meta name="description" content="0 避免使用类型域。 避免使用类型域（Type Codes）是面向对象设计中的重要原则，因为类型域会导致代码耦合度高、难以维护，且违反开闭原则（对扩展开放，对修改关闭）。以下是替代类型域的常见方法及示例：  1. 使用多态（子类化） 通过继承和多态，将不同类型的行为封装到子类中，消除显式的类型判断。 重构前（使用类型域）： 1234567891011121314class Shape &#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="C++程序设计语言笔记——抽象机制：派生类">
<meta property="og:url" content="https://mounthuangshan.github.io/C-%E7%AC%94%E8%AE%B0/C++%E7%AC%94%E8%AE%B0/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%9A%E6%B4%BE%E7%94%9F%E7%B1%BB/">
<meta property="og:site_name" content="钺不言">
<meta property="og:description" content="0 避免使用类型域。 避免使用类型域（Type Codes）是面向对象设计中的重要原则，因为类型域会导致代码耦合度高、难以维护，且违反开闭原则（对扩展开放，对修改关闭）。以下是替代类型域的常见方法及示例：  1. 使用多态（子类化） 通过继承和多态，将不同类型的行为封装到子类中，消除显式的类型判断。 重构前（使用类型域）： 1234567891011121314class Shape &#123;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-03-18T18:19:05.000Z">
<meta property="article:modified_time" content="2025-03-18T18:19:05.849Z">
<meta property="article:author" content="黄山">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="Web">
<meta property="article:tag" content="AI">
<meta property="article:tag" content="游戏开发">
<meta property="article:tag" content="网络安全">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>C++程序设计语言笔记——抽象机制：派生类 - 钺不言</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"mounthuangshan.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++程序设计语言笔记——抽象机制：派生类"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-03-19 02:19" pubdate>
          2025年3月19日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          111 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">C++程序设计语言笔记——抽象机制：派生类</h1>
            
            
              <div class="markdown-body">
                
                <h1>0 避免使用类型域。</h1>
<p>避免使用类型域（Type Codes）是面向对象设计中的重要原则，因为类型域会导致代码耦合度高、难以维护，且违反开闭原则（对扩展开放，对修改关闭）。以下是替代类型域的常见方法及示例：</p>
<hr>
<h3 id="1-使用多态（子类化）"><strong>1. 使用多态（子类化）</strong></h3>
<p>通过继承和多态，将不同类型的行为封装到子类中，消除显式的类型判断。</p>
<h4 id="重构前（使用类型域）：">重构前（使用类型域）：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-type">int</span> type; <span class="hljs-comment">// 1=圆, 2=矩形</span><br>    <span class="hljs-type">double</span> radius;<br>    <span class="hljs-type">double</span> width, height;<br><br>    <span class="hljs-type">double</span> <span class="hljs-title function_">calculateArea</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> Math.PI * radius * radius;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> width * height;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;未知类型&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="重构后（使用多态）：">重构后（使用多态）：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateArea</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> radius;<br>    Circle(<span class="hljs-type">double</span> radius) &#123; <span class="hljs-built_in">this</span>.radius = radius; &#125;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateArea</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> Math.PI * radius * radius; &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> width, height;<br>    Rectangle(<span class="hljs-type">double</span> w, <span class="hljs-type">double</span> h) &#123; width = w; height = h; &#125;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateArea</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> width * height; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="2-使用策略模式（Strategy-Pattern）"><strong>2. 使用策略模式（Strategy Pattern）</strong></h3>
<p>将行为抽象为接口，通过组合动态切换策略。</p>
<h4 id="重构前（类型域控制行为）：">重构前（类型域控制行为）：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentProcessor</span> &#123;<br>    String paymentType; <span class="hljs-comment">// &quot;CreditCard&quot;, &quot;PayPal&quot;</span><br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">processPayment</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123;<br>        <span class="hljs-keyword">if</span> (paymentType.equals(<span class="hljs-string">&quot;CreditCard&quot;</span>)) &#123;<br>            processCreditCard(amount);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (paymentType.equals(<span class="hljs-string">&quot;PayPal&quot;</span>)) &#123;<br>            processPayPal(amount);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processCreditCard</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processPayPal</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="重构后（策略模式）：">重构后（策略模式）：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PaymentStrategy</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">processPayment</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CreditCardStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PaymentStrategy</span> &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processPayment</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PayPalStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PaymentStrategy</span> &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processPayment</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentProcessor</span> &#123;<br>    <span class="hljs-keyword">private</span> PaymentStrategy strategy;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStrategy</span><span class="hljs-params">(PaymentStrategy strategy)</span> &#123; <span class="hljs-built_in">this</span>.strategy = strategy; &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">processPayment</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> &#123; strategy.processPayment(amount); &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="3-使用状态模式（State-Pattern）"><strong>3. 使用状态模式（State Pattern）</strong></h3>
<p>当对象的行为随内部状态改变时，将状态抽象为独立类。</p>
<h4 id="重构前（类型域表示状态）：">重构前（类型域表示状态）：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    String state; <span class="hljs-comment">// &quot;New&quot;, &quot;Shipped&quot;, &quot;Canceled&quot;</span><br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (state.equals(<span class="hljs-string">&quot;New&quot;</span>)) &#123;<br>            shipOrder();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state.equals(<span class="hljs-string">&quot;Shipped&quot;</span>)) &#123;<br>            trackOrder();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state.equals(<span class="hljs-string">&quot;Canceled&quot;</span>)) &#123;<br>            refund();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="重构后（状态模式）：">重构后（状态模式）：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderState</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NewState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderState</span> &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123; shipOrder(); &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShippedState</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderState</span> &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123; trackOrder(); &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">private</span> OrderState state;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(OrderState state)</span> &#123; <span class="hljs-built_in">this</span>.state = state; &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> &#123; state.handle(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="4-使用工厂模式（Factory-Pattern）"><strong>4. 使用工厂模式（Factory Pattern）</strong></h3>
<p>通过工厂封装对象的创建逻辑，避免客户端代码依赖具体类型。</p>
<h4 id="重构前（显式类型判断创建对象）：">重构前（显式类型判断创建对象）：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Shape <span class="hljs-title function_">createShape</span><span class="hljs-params">(<span class="hljs-type">int</span> type)</span> &#123;<br>    <span class="hljs-keyword">if</span> (type == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">5.0</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(<span class="hljs-number">4.0</span>, <span class="hljs-number">6.0</span>);<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;未知类型&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="重构后（工厂模式）：">重构后（工厂模式）：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ShapeFactory</span> &#123;<br>    Shape <span class="hljs-title function_">create</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircleFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ShapeFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Shape <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(<span class="hljs-number">5.0</span>); &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RectangleFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ShapeFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Shape <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(<span class="hljs-number">4.0</span>, <span class="hljs-number">6.0</span>); &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用工厂</span><br><span class="hljs-type">ShapeFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CircleFactory</span>();<br><span class="hljs-type">Shape</span> <span class="hljs-variable">shape</span> <span class="hljs-operator">=</span> factory.create();<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="5-使用枚举（Enums）结合方法"><strong>5. 使用枚举（Enums）结合方法</strong></h3>
<p>如果必须使用类型标识符，可通过枚举类封装类型相关逻辑。</p>
<h4 id="重构前（松散的类型域）：">重构前（松散的类型域）：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">TYPE_CIRCLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">TYPE_RECTANGLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">drawShape</span><span class="hljs-params">(<span class="hljs-type">int</span> type)</span> &#123;<br>    <span class="hljs-keyword">if</span> (type == TYPE_CIRCLE) &#123;<br>        drawCircle();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == TYPE_RECTANGLE) &#123;<br>        drawRectangle();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="重构后（枚举类）：">重构后（枚举类）：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">ShapeType</span> &#123;<br>    CIRCLE &#123; <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">/* 画圆 */</span> &#125; &#125;,<br>    RECTANGLE &#123; <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">/* 画矩形 */</span> &#125; &#125;;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 使用枚举</span><br>ShapeType.CIRCLE.draw();<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="总结"><strong>总结</strong></h3>
<ul>
<li><strong>优点</strong>：消除条件分支、提高可扩展性、遵循开闭原则。</li>
<li><strong>适用场景</strong>：当对象行为依赖于类型域，或需要频繁新增类型时。</li>
<li><strong>关键原则</strong>：将“是什么”（类型）转化为“能做什么”（行为），通过多态和组合解耦代码。</li>
</ul>
<h1>1 通过指针和引用访问多态对象。</h1>
<p>在C++中，通过指针和引用访问多态对象是实现运行时多态的核心机制。以下是关键概念、示例及注意事项：</p>
<hr>
<h3 id="1-多态的基础：虚函数与动态绑定"><strong>1. 多态的基础：虚函数与动态绑定</strong></h3>
<ul>
<li><strong>虚函数（Virtual Functions）</strong>：基类中声明<code>virtual</code>的函数，派生类可重写（<code>override</code>）。</li>
<li><strong>动态绑定</strong>：通过基类指针或引用调用虚函数时，实际调用的是对象的<strong>运行时类型</strong>对应的函数。</li>
</ul>
<h4 id="示例代码：">示例代码：</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">makeSound</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Animal sound\n&quot;</span>; <br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Animal</span>() = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// 虚析构函数（避免对象切片和内存泄漏）</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeSound</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Woof!\n&quot;</span>; <br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeSound</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Meow!\n&quot;</span>; <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 通过基类指针访问派生类对象</span><br>    Animal* animal1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Dog</span>();<br>    animal1-&gt;<span class="hljs-built_in">makeSound</span>(); <span class="hljs-comment">// 输出 &quot;Woof!&quot;</span><br><br>    <span class="hljs-comment">// 通过基类引用访问派生类对象</span><br>    Cat cat;<br>    Animal&amp; animal2 = cat;<br>    animal<span class="hljs-number">2.</span><span class="hljs-built_in">makeSound</span>(); <span class="hljs-comment">// 输出 &quot;Meow!&quot;</span><br><br>    <span class="hljs-keyword">delete</span> animal1; <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="2-指针-vs-引用的区别"><strong>2. 指针 vs 引用的区别</strong></h3>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>指针</strong></th>
<th><strong>引用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>空值</td>
<td>可以指向<code>nullptr</code></td>
<td>必须绑定到有效对象（不能为空）</td>
</tr>
<tr>
<td>重新赋值</td>
<td>可以指向其他对象</td>
<td>绑定后不可更改</td>
</tr>
<tr>
<td>语法</td>
<td>使用<code>-&gt;</code>访问成员</td>
<td>使用<code>.</code>访问成员</td>
</tr>
<tr>
<td>适用场景</td>
<td>动态内存管理、可选参数</td>
<td>函数参数传递、明确对象必须存在时</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="3-关键注意事项"><strong>3. 关键注意事项</strong></h3>
<h4 id="（1）虚析构函数"><strong>（1）虚析构函数</strong></h4>
<ul>
<li><strong>问题</strong>：若基类析构函数非虚，通过基类指针删除派生类对象会导致<strong>未定义行为</strong>（仅调用基类析构函数）。</li>
<li><strong>解决</strong>：始终声明基类析构函数为<code>virtual</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// ✔️ 虚析构函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Derived</span>() <span class="hljs-keyword">override</span> &#123; <span class="hljs-comment">/* 清理派生类资源 */</span> &#125;<br>&#125;;<br><br>Base* obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br><span class="hljs-keyword">delete</span> obj; <span class="hljs-comment">// 正确调用派生类和基类的析构函数</span><br></code></pre></td></tr></table></figure>
<h4 id="（2）对象切片（Object-Slicing）"><strong>（2）对象切片（Object Slicing）</strong></h4>
<ul>
<li><strong>问题</strong>：将派生类对象<strong>按值传递</strong>给基类变量时，派生类特有部分会被“切掉”。</li>
<li><strong>解决</strong>：使用指针或引用传递。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processAnimal</span><span class="hljs-params">(Animal animal)</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125; <span class="hljs-comment">// 按值传递（导致切片）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processAnimal</span><span class="hljs-params">(Animal&amp; animal)</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125; <span class="hljs-comment">// ✔️ 按引用传递（避免切片）</span><br><br>Cat cat;<br><span class="hljs-built_in">processAnimal</span>(cat); <span class="hljs-comment">// 错误示例：按值传递导致派生类信息丢失</span><br></code></pre></td></tr></table></figure>
<h4 id="（3）智能指针管理多态对象"><strong>（3）智能指针管理多态对象</strong></h4>
<ul>
<li><strong>问题</strong>：裸指针需手动<code>delete</code>，易引发内存泄漏。</li>
<li><strong>解决</strong>：使用<code>std::unique_ptr</code>或<code>std::shared_ptr</code>自动管理内存。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br>std::unique_ptr&lt;Animal&gt; animal = std::<span class="hljs-built_in">make_unique</span>&lt;Dog&gt;();<br>animal-&gt;<span class="hljs-built_in">makeSound</span>(); <span class="hljs-comment">// 自动释放内存</span><br></code></pre></td></tr></table></figure>
<hr>
<h3 id="4-动态类型识别（dynamic-cast）"><strong>4. 动态类型识别（<code>dynamic_cast</code>）</strong></h3>
<ul>
<li><strong>用途</strong>：安全地将基类指针/引用转换为派生类类型。</li>
<li><strong>要求</strong>：基类必须有虚函数（启用RTTI）。</li>
<li><strong>失败时</strong>：指针返回<code>nullptr</code>，引用抛出<code>std::bad_cast</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Animal* animal = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Dog</span>();<br><br><span class="hljs-comment">// 安全向下转型</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span>* dog = <span class="hljs-built_in">dynamic_cast</span>&lt;Dog*&gt;(animal)) &#123;<br>    dog-&gt;<span class="hljs-built_in">bark</span>(); <span class="hljs-comment">// 调用Dog特有方法</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Not a Dog.\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="5-多态的应用场景"><strong>5. 多态的应用场景</strong></h3>
<ol>
<li><strong>工厂模式</strong>：返回基类指针的工厂函数。</li>
<li><strong>接口编程</strong>：客户端代码依赖抽象接口而非具体类。</li>
<li><strong>容器存储异构对象</strong>：用基类指针容器管理多种派生类对象。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;std::unique_ptr&lt;Animal&gt;&gt; animals;<br>animals.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_unique</span>&lt;Dog&gt;());<br>animals.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_unique</span>&lt;Cat&gt;());<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; animal : animals) &#123;<br>    animal-&gt;<span class="hljs-built_in">makeSound</span>(); <span class="hljs-comment">// 输出 &quot;Woof!&quot; 和 &quot;Meow!&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="总结-2"><strong>总结</strong></h3>
<ul>
<li><strong>多态的本质</strong>：通过基类指针/引用调用虚函数，实现<strong>运行时动态绑定</strong>。</li>
<li><strong>必须遵循</strong>：
<ul>
<li>基类声明虚析构函数。</li>
<li>使用指针或引用避免对象切片。</li>
<li>优先使用智能指针管理对象生命周期。</li>
</ul>
</li>
<li><strong>避免滥用</strong>：仅在需要运行时类型扩展时使用多态，否则可能增加复杂性。</li>
</ul>
<h1>2 使用抽象类，以便聚焦于清晰接口的设计应该提供什么。</h1>
<p>在设计抽象类以聚焦于清晰的接口时，需要遵循以下核心原则和设计要点，确保接口简洁、稳定且易于扩展：</p>
<hr>
<h3 id="1-抽象类的核心目标"><strong>1. 抽象类的核心目标</strong></h3>
<p>抽象类（Abstract Class）应<strong>仅定义接口契约</strong>，而不关心具体实现细节，其核心作用包括：</p>
<ul>
<li><strong>解耦</strong>：分离接口与实现，降低模块间的依赖。</li>
<li><strong>标准化</strong>：强制派生类遵循统一的接口规范。</li>
<li><strong>扩展性</strong>：允许新增实现类而不影响现有代码（符合开闭原则）。</li>
</ul>
<hr>
<h3 id="2-设计清晰接口的关键规则"><strong>2. 设计清晰接口的关键规则</strong></h3>
<h4 id="（1）仅暴露纯虚函数（Pure-Virtual-Functions）"><strong>（1）仅暴露纯虚函数（Pure Virtual Functions）</strong></h4>
<ul>
<li><strong>纯虚函数</strong>（<code>= 0</code>）强制派生类实现接口，避免基类提供默认实现干扰接口的明确性。</li>
<li><strong>避免混合虚函数与非虚函数</strong>：非虚函数应仅用于公共逻辑，而非接口定义。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 正确示例：抽象类仅定义纯虚接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseConnector</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">DatabaseConnector</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; url)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">disconnect</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">executeQuery</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; query)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 错误示例：混合虚函数与默认实现（可能模糊接口责任）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseConnector</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; url)</span> </span>&#123; <span class="hljs-comment">/* 默认实现 */</span> &#125;<br>    <span class="hljs-comment">// ❌ 接口不清晰，派生类可能依赖默认行为</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="（2）接口最小化（遵循接口隔离原则）"><strong>（2）接口最小化（遵循接口隔离原则）</strong></h4>
<ul>
<li><strong>单一职责</strong>：每个抽象类只定义一个特定领域的接口，避免“上帝接口”。</li>
<li><strong>按需拆分</strong>：若接口包含多个功能方向，应分解为多个抽象类。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 正确示例：拆分为读写接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Readable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Writable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 错误示例：混合读写接口（违反单一职责）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IODevice</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logError</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">// ❌ 日志功能不属于IO核心职责</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="（3）提供公共非虚接口（Non-Virtual-Interface-NVI）"><strong>（3）提供公共非虚接口（Non-Virtual Interface, NVI）</strong></h4>
<ul>
<li><strong>封装通用逻辑</strong>：公共方法设为非虚，内部调用保护的虚方法，确保接口行为的一致性。</li>
<li><strong>增强控制</strong>：允许基类在接口调用前后插入通用逻辑（如日志、参数校验）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sensor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 公共非虚接口</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getReading</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">validateState</span>();        <span class="hljs-comment">// 公共逻辑：状态校验</span><br>        <span class="hljs-keyword">auto</span> data = <span class="hljs-built_in">readData</span>(); <span class="hljs-comment">// 调用保护的虚函数</span><br>        <span class="hljs-built_in">log</span>(data);              <span class="hljs-comment">// 公共逻辑：记录数据</span><br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Sensor</span>() = <span class="hljs-keyword">default</span>;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// 派生类仅需实现具体数据读取</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">readData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">validateState</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">double</span> data)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="（4）支持可扩展性（模板方法模式）"><strong>（4）支持可扩展性（模板方法模式）</strong></h4>
<ul>
<li><strong>固定算法骨架</strong>：在抽象类中定义算法的步骤框架，允许派生类重写特定步骤。</li>
<li><strong>避免重复逻辑</strong>：将通用流程固化在基类中。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataProcessor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">loadData</span>();      <span class="hljs-comment">// 固定步骤1</span><br>        <span class="hljs-built_in">validate</span>();      <span class="hljs-comment">// 固定步骤2</span><br>        <span class="hljs-built_in">transform</span>();     <span class="hljs-comment">// 可扩展步骤（由派生类实现）</span><br>        <span class="hljs-built_in">saveResult</span>();    <span class="hljs-comment">// 固定步骤3</span><br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">transform</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 仅需派生类实现数据转换</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loadData</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">validate</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">saveResult</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="3-实现细节注意事项"><strong>3. 实现细节注意事项</strong></h3>
<h4 id="（1）虚析构函数-2"><strong>（1）虚析构函数</strong></h4>
<ul>
<li><strong>必须声明虚析构函数</strong>：确保通过基类指针删除派生类对象时，正确调用派生类析构函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AbstractClass</span>() = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// ✔️ 虚析构函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="（2）避免数据成员"><strong>（2）避免数据成员</strong></h4>
<ul>
<li><strong>保持接口纯粹</strong>：抽象类通常不应包含数据成员，数据应由实现类管理。</li>
<li><strong>例外</strong>：若多个派生类需要共享通用数据，可将其设为<code>protected</code>，但需谨慎设计。</li>
</ul>
<h4 id="（3）禁用拷贝与赋值（C-特定）"><strong>（3）禁用拷贝与赋值（C++特定）</strong></h4>
<ul>
<li><strong>防止对象切片</strong>：若抽象类不可拷贝，应删除拷贝构造函数和赋值运算符。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NonCopyable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NonCopyable</span>(<span class="hljs-type">const</span> NonCopyable&amp;) = <span class="hljs-keyword">delete</span>;<br>    NonCopyable&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> NonCopyable&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClass</span> : <span class="hljs-keyword">public</span> NonCopyable &#123;<br>    <span class="hljs-comment">// 接口定义...</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="4-示例：清晰的抽象接口设计"><strong>4. 示例：清晰的抽象接口设计</strong></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义网络请求的抽象接口（仅核心操作）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpClient</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">HttpClient</span>() = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-comment">// 纯虚接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; url)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">post</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; url, <span class="hljs-type">const</span> std::string&amp; data)</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 公共非虚方法（如超时设置）</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setTimeout</span><span class="hljs-params">(<span class="hljs-type">int</span> milliseconds)</span> </span>&#123;<br>        timeout_ = milliseconds;<br>        <span class="hljs-built_in">applyTimeout</span>(); <span class="hljs-comment">// 调用保护的虚方法</span><br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// 可选的扩展点（派生类可实现超时逻辑）</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">applyTimeout</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* 默认空实现 */</span> &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> timeout_ = <span class="hljs-number">5000</span>; <span class="hljs-comment">// 公共数据由基类管理</span><br>&#125;;<br><br><span class="hljs-comment">// 具体实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CurlHttpClient</span> : <span class="hljs-keyword">public</span> HttpClient &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; url)</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* CURL实现 */</span> &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">post</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; url, <span class="hljs-type">const</span> std::string&amp; data)</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* CURL实现 */</span> &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">applyTimeout</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* 设置CURL超时 */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="5-设计原则总结"><strong>5. 设计原则总结</strong></h3>
<table>
<thead>
<tr>
<th><strong>原则</strong></th>
<th><strong>实现方式</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>接口隔离原则</strong></td>
<td>每个抽象类仅定义单一职责的接口</td>
</tr>
<tr>
<td><strong>依赖倒置原则</strong></td>
<td>高层模块依赖抽象接口，而非具体实现</td>
</tr>
<tr>
<td><strong>开闭原则</strong></td>
<td>通过新增派生类扩展功能，而非修改抽象类</td>
</tr>
<tr>
<td><strong>里氏替换原则</strong></td>
<td>派生类必须完全实现抽象接口，且行为符合基类约定</td>
</tr>
<tr>
<td><strong>非虚接口模式（NVI）</strong></td>
<td>公共方法非虚，内部调用虚方法，确保接口行为可控</td>
</tr>
</tbody>
</table>
<p>通过以上设计，抽象类将成为系统架构中的稳定核心，使代码更易维护、测试和扩展。</p>
<h1>3 在大型类层次中用override显式说明覆盖。</h1>
<p>在大型类层次中使用 <code>override</code> 关键字显式标记虚函数覆盖，是提升代码健壮性、可读性和可维护性的关键实践。以下是具体原因、用法及注意事项：</p>
<hr>
<h3 id="1-为什么需要-override？"><strong>1. 为什么需要 <code>override</code>？</strong></h3>
<h4 id="（1）避免隐式错误"><strong>（1）避免隐式错误</strong></h4>
<ul>
<li><strong>问题</strong>：在多层继承中，可能因<strong>函数签名不匹配</strong>（参数类型、<code>const</code>修饰符等）或<strong>基类虚函数未正确声明</strong>，导致派生类函数未能真正覆盖基类虚函数。</li>
<li><strong>示例</strong>：基类函数签名被修改，但派生类未同步更新。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span>;  <span class="hljs-comment">// 基类函数参数为 int</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span></span>;  <span class="hljs-comment">// 参数类型不匹配，未覆盖基类函数！</span><br>                                 <span class="hljs-comment">// 本意是覆盖，但因无 `override` 编译通过，导致隐藏基类函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（2）增强代码意图表达"><strong>（2）增强代码意图表达</strong></h4>
<ul>
<li><strong>明确性</strong>：<code>override</code> 显式声明派生类函数旨在覆盖基类虚函数，提高代码可读性。</li>
<li><strong>可维护性</strong>：在大型项目中，帮助开发者快速识别继承关系中的重写行为。</li>
</ul>
<hr>
<h3 id="2-如何使用-override？"><strong>2. 如何使用 <code>override</code>？</strong></h3>
<h4 id="（1）语法规则"><strong>（1）语法规则</strong></h4>
<ul>
<li>仅在派生类的虚函数声明后添加 <code>override</code>。</li>
<li>基类必须有对应的虚函数（相同签名 + 虚函数）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;  <span class="hljs-comment">// ✔️ 正确覆盖</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="（2）结合-final-使用"><strong>（2）结合 <code>final</code> 使用</strong></h4>
<ul>
<li><code>final</code>：阻止派生类进一步覆盖该虚函数。</li>
<li><strong>适用场景</strong>：设计不允许再被修改的接口或实现。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">final</span></span>;  <span class="hljs-comment">// 禁止后续派生类覆盖</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubDerived</span> : <span class="hljs-keyword">public</span> Derived &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;  <span class="hljs-comment">// ❌ 编译错误：无法覆盖 `final` 函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="3-在大型类层次中的优势"><strong>3. 在大型类层次中的优势</strong></h3>
<h4 id="（1）及早发现接口不一致"><strong>（1）及早发现接口不一致</strong></h4>
<ul>
<li><strong>编译时检查</strong>：若基类虚函数签名或名称被修改，派生类的 <code>override</code> 标记会立即触发编译错误。</li>
<li><strong>示例</strong>：基类接口变更导致派生类覆盖失效。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 基类修改前</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// 派生类正确覆盖</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// 基类修改后（函数名拼写错误）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">calculat</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 错误拼写</span><br>&#125;;<br><br><span class="hljs-comment">// 派生类代码触发编译错误：</span><br><span class="hljs-comment">// error: &#x27;void Derived::calculate()&#x27; marked &#x27;override&#x27;, but does not override</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（2）简化重构与调试"><strong>（2）简化重构与调试</strong></h4>
<ul>
<li><strong>安全重构</strong>：修改基类虚函数时，编译器自动定位所有依赖的派生类覆盖。</li>
<li><strong>减少运行时错误</strong>：避免因未覆盖或隐藏基类函数导致的逻辑异常。</li>
</ul>
<hr>
<h3 id="4-注意事项"><strong>4. 注意事项</strong></h3>
<h4 id="（1）基类虚函数必须存在"><strong>（1）基类虚函数必须存在</strong></h4>
<ul>
<li>若基类无对应虚函数，<code>override</code> 会导致编译错误。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123; <span class="hljs-comment">/* 无虚函数 */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;  <span class="hljs-comment">// ❌ 错误：基类无虚函数可覆盖</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（2）与-virtual-关键字的配合"><strong>（2）与 <code>virtual</code> 关键字的配合</strong></h4>
<ul>
<li><strong>派生类无需重复 <code>virtual</code></strong>：<code>override</code> 已隐含虚函数特性。</li>
<li><strong>推荐写法</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;  <span class="hljs-comment">// ✔️ 简洁且明确</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（3）避免滥用-override"><strong>（3）避免滥用 <code>override</code></strong></h4>
<ul>
<li><strong>仅用于覆盖基类虚函数</strong>：非虚函数或新增函数不应使用 <code>override</code>。</li>
</ul>
<hr>
<h3 id="5-综合示例"><strong>5. 综合示例</strong></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 基类：抽象数据处理器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataProcessor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">DataProcessor</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">validate</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Base validation\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 派生类：CSV处理器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CsvProcessor</span> : <span class="hljs-keyword">public</span> DataProcessor &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 显式覆盖基类纯虚函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Processing CSV data\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 覆盖基类虚函数并标记 final，禁止进一步覆盖</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">validate</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">final</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;CSV-specific validation\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 二级派生类（尝试覆盖 final 函数）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AdvancedCsvProcessor</span> : <span class="hljs-keyword">public</span> CsvProcessor &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Advanced CSV processing\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// void validate(const std::string&amp; data) const override &#123; ... &#125;  // ❌ 编译错误：无法覆盖 final 函数</span><br>&#125;;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    CsvProcessor csv;<br>    csv.<span class="hljs-built_in">process</span>(<span class="hljs-string">&quot;data&quot;</span>);  <span class="hljs-comment">// 输出 &quot;Processing CSV data&quot;</span><br>    csv.<span class="hljs-built_in">validate</span>(<span class="hljs-string">&quot;data&quot;</span>); <span class="hljs-comment">// 输出 &quot;CSV-specific validation&quot;</span><br><br>    AdvancedCsvProcessor advCsv;<br>    advCsv.<span class="hljs-built_in">process</span>(<span class="hljs-string">&quot;data&quot;</span>); <span class="hljs-comment">// 输出 &quot;Advanced CSV processing&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="总结-3"><strong>总结</strong></h3>
<ul>
<li><strong>强制使用 <code>override</code></strong>：在大型项目中，通过编译选项（如 <code>-Wsuggest-override</code>）强制检查覆盖。</li>
<li><strong>代码规范</strong>：将 <code>override</code> 纳入团队编码规范，确保一致性。</li>
<li><strong>核心价值</strong>：通过编译器辅助，在复杂类层次中确保接口正确性，降低维护成本。</li>
</ul>
<h1>4 谨慎使用final。</h1>
<p>在C++中，<code>final</code>关键字用于禁止类被继承或虚函数被进一步覆盖。虽然它有助于增强代码的安全性和性能优化，但过度使用可能导致设计僵化，违反面向对象的开放-封闭原则（对扩展开放，对修改关闭）。以下是需要谨慎使用<code>final</code>的场景、替代方案及最佳实践：</p>
<hr>
<h3 id="1-final的合理使用场景"><strong>1. <code>final</code>的合理使用场景</strong></h3>
<h4 id="（1）明确禁止扩展的类"><strong>（1）明确禁止扩展的类</strong></h4>
<ul>
<li><strong>适用场景</strong>：工具类、单例类、包含敏感逻辑的类（如加密算法）。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EncryptionEngine</span> <span class="hljs-keyword">final</span> &#123; <span class="hljs-comment">// 禁止继承，确保算法不被篡改</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">encrypt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// 错误：尝试继承 final 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MaliciousEngine</span> : <span class="hljs-keyword">public</span> EncryptionEngine &#123; <span class="hljs-comment">/* ... */</span> &#125;; <span class="hljs-comment">// ❌ 编译错误</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（2）关键虚函数禁止覆盖"><strong>（2）关键虚函数禁止覆盖</strong></h4>
<ul>
<li><strong>适用场景</strong>：确保核心逻辑不可变（如状态机的关键状态处理）。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StateMachine</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onEnterState</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* 默认实现 */</span> &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onExitState</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span> </span>&#123; <span class="hljs-comment">/* 强制固定退出逻辑 */</span> &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomState</span> : <span class="hljs-keyword">public</span> StateMachine &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onEnterState</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* 允许自定义进入逻辑 */</span> &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onExitState</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* ❌ 编译错误：无法覆盖 final 函数 */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（3）性能优化"><strong>（3）性能优化</strong></h4>
<ul>
<li><strong>适用场景</strong>：虚函数调用频繁且确定不需要多态时，编译器可能内联调用。</li>
<li><strong>注意</strong>：仅在性能分析确认瓶颈后使用，避免过早优化。</li>
</ul>
<hr>
<h3 id="2-应避免使用final的场景"><strong>2. 应避免使用<code>final</code>的场景</strong></h3>
<h4 id="（1）基类或接口设计"><strong>（1）基类或接口设计</strong></h4>
<ul>
<li><strong>问题</strong>：标记基类为<code>final</code>会彻底禁止多态，失去面向对象的核心优势。</li>
<li><strong>反例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractDataSource</span> <span class="hljs-keyword">final</span> &#123; <span class="hljs-comment">// ❌ 错误：基类不应为 final</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">load</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（2）预期有扩展需求的类"><strong>（2）预期有扩展需求的类</strong></h4>
<ul>
<li><strong>示例</strong>：UI控件、插件系统、策略模式中的策略类。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">final</span> : <span class="hljs-keyword">public</span> Widget &#123; <span class="hljs-comment">/* ... */</span> &#125;; <span class="hljs-comment">// ❌ 若需未来支持不同按钮样式，应允许继承</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（3）框架或库的公共API"><strong>（3）框架或库的公共API</strong></h4>
<ul>
<li><strong>风险</strong>：用户无法通过继承定制行为，导致库的灵活性下降。</li>
<li><strong>替代方案</strong>：通过文档或设计模式（如策略模式）限制扩展方式，而非强制禁止。</li>
</ul>
<hr>
<h3 id="3-final的替代方案"><strong>3. <code>final</code>的替代方案</strong></h3>
<h4 id="（1）使用非虚接口模式（NVI）"><strong>（1）使用非虚接口模式（NVI）</strong></h4>
<ul>
<li><strong>原理</strong>：通过基类的非虚公共方法调用保护的虚方法，控制派生类的行为扩展范围。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Processor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 非虚方法</span><br>        <span class="hljs-built_in">validate</span>();<br>        <span class="hljs-built_in">doExecute</span>(); <span class="hljs-comment">// 派生类仅能重写此步骤</span><br>        <span class="hljs-built_in">logResult</span>();<br>    &#125;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doExecute</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 派生类实现</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">validate</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* 通用校验 */</span> &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logResult</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* 通用日志 */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（2）通过组合替代继承"><strong>（2）通过组合替代继承</strong></h4>
<ul>
<li><strong>场景</strong>：若某类的功能不需多态，但需复用代码，优先使用组合。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NetworkService</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    Logger logger; <span class="hljs-comment">// 组合而非继承</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendRequest</span><span class="hljs-params">()</span> </span>&#123;<br>        logger.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Sending request...&quot;</span>);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（3）文档约束"><strong>（3）文档约束</strong></h4>
<ul>
<li><strong>适用场景</strong>：通过注释或文档说明类/方法的扩展限制，而非强制使用<code>final</code>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 此类的核心算法不应被修改，若需定制，请通过参数配置实现。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Algorithm</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="4-错误使用final的后果"><strong>4. 错误使用<code>final</code>的后果</strong></h3>
<h4 id="（1）设计僵化"><strong>（1）设计僵化</strong></h4>
<ul>
<li><strong>案例</strong>：某网络库将<code>HttpClient</code>标记为<code>final</code>，导致用户无法实现自定义缓存逻辑，被迫复制库代码。</li>
</ul>
<h4 id="（2）违反开闭原则"><strong>（2）违反开闭原则</strong></h4>
<ul>
<li><strong>案例</strong>：某框架的<code>DatabaseConnection</code>类因标记为<code>final</code>，无法支持新的数据库类型，需框架本身修改代码。</li>
</ul>
<h4 id="（3）增加重构成本"><strong>（3）增加重构成本</strong></h4>
<ul>
<li><strong>案例</strong>：某类被错误标记为<code>final</code>，后续需求需要继承时，必须修改所有依赖该类的代码。</li>
</ul>
<hr>
<h3 id="5-最佳实践"><strong>5. 最佳实践</strong></h3>
<table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>是否使用<code>final</code></strong></th>
<th><strong>替代方案</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>工具类、单例类</td>
<td>✔️ 推荐</td>
<td>无</td>
</tr>
<tr>
<td>框架的关键核心逻辑</td>
<td>✔️ 谨慎使用</td>
<td>NVI模式、组合</td>
</tr>
<tr>
<td>基类或接口定义</td>
<td>❌ 禁止</td>
<td>抽象类、纯虚函数</td>
</tr>
<tr>
<td>预期会有扩展需求的模块</td>
<td>❌ 禁止</td>
<td>策略模式、模板方法模式</td>
</tr>
<tr>
<td>性能关键路径且确认无需多态</td>
<td>✔️ 优化后使用</td>
<td>测量性能收益后再决定</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="总结-4"><strong>总结</strong></h3>
<ul>
<li><strong>核心原则</strong>：默认不使用<code>final</code>，仅在明确需要禁止扩展时使用。</li>
<li><strong>决策流程</strong>：
<ol>
<li>确认类或方法是否真的不需要任何未来扩展。</li>
<li>评估是否可以通过设计模式（如NVI、策略模式）避免<code>final</code>。</li>
<li>若必须使用，添加详细注释说明原因。</li>
</ol>
</li>
<li><strong>团队规范</strong>：在代码审查中严格审核<code>final</code>的使用，确保其符合长期架构目标。</li>
</ul>
<h1>5 使用抽象类说明接口。</h1>
<p>在面向对象编程中，通过抽象类（Abstract Class）定义接口是一种关键设计实践，它强制派生类遵循统一的契约（Contract），同时实现多态性。以下是使用抽象类定义接口的核心原则、示例及注意事项：</p>
<hr>
<h3 id="1-抽象类作为接口的核心特征"><strong>1. 抽象类作为接口的核心特征</strong></h3>
<ul>
<li><strong>纯虚函数（Pure Virtual Functions）</strong>：抽象类通过声明纯虚函数（<code>= 0</code>）定义接口，要求派生类必须实现这些函数。</li>
<li><strong>不可实例化</strong>：抽象类不能直接创建对象，只能通过派生类实例化。</li>
<li><strong>接口与实现分离</strong>：抽象类定义“做什么”（接口），派生类定义“怎么做”（实现）。</li>
</ul>
<hr>
<h3 id="2-设计抽象类接口的最佳实践"><strong>2. 设计抽象类接口的最佳实践</strong></h3>
<h4 id="（1）仅定义必要的操作"><strong>（1）仅定义必要的操作</strong></h4>
<ul>
<li><strong>接口最小化</strong>：遵循<strong>接口隔离原则（ISP）</strong>，每个抽象类只定义一组紧密相关的操作。</li>
<li><strong>示例</strong>：文件操作的接口拆分。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ❌ 错误：混合读写接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">File</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">// 部分文件可能只读，强制实现违反 ISP</span><br>&#125;;<br><br><span class="hljs-comment">// ✔️ 正确：拆分为独立接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Readable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Writable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（2）避免数据成员-2"><strong>（2）避免数据成员</strong></h4>
<ul>
<li><strong>专注行为</strong>：抽象类应定义操作而非状态。若需要共享数据，通过参数传递或依赖注入。</li>
<li><strong>反例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> color;  <span class="hljs-comment">// ❌ 数据成员污染接口</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（3）提供公共非虚接口（NVI模式）"><strong>（3）提供公共非虚接口（NVI模式）</strong></h4>
<ul>
<li><strong>封装通用逻辑</strong>：非虚方法调用虚方法，确保接口行为一致。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSource</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 公共非虚接口</span><br>    <span class="hljs-function">std::string <span class="hljs-title">fetch</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">validateConnection</span>();<br>        <span class="hljs-keyword">auto</span> data = <span class="hljs-built_in">doFetch</span>(); <span class="hljs-comment">// 调用纯虚方法</span><br>        <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Data fetched&quot;</span>);<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">DataSource</span>() = <span class="hljs-keyword">default</span>;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">doFetch</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 派生类实现具体逻辑</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">validateConnection</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* 通用校验 */</span> &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> </span>&#123; <span class="hljs-comment">/* 通用日志 */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（4）声明虚析构函数"><strong>（4）声明虚析构函数</strong></h4>
<ul>
<li><strong>确保资源安全释放</strong>：基类指针指向派生类对象时，正确调用派生类析构函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractDevice</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AbstractDevice</span>() = <span class="hljs-keyword">default</span>;  <span class="hljs-comment">// ✔️ 虚析构函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="3-示例：抽象类定义网络请求接口"><strong>3. 示例：抽象类定义网络请求接口</strong></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 抽象类定义 HTTP 客户端接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpClient</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">HttpClient</span>() = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-comment">// 纯虚接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; url)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">post</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; url, <span class="hljs-type">const</span> std::string&amp; data)</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 公共非虚方法（如设置超时）</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setTimeout</span><span class="hljs-params">(<span class="hljs-type">int</span> milliseconds)</span> </span>&#123;<br>        timeout_ = milliseconds;<br>        <span class="hljs-built_in">applyTimeout</span>(); <span class="hljs-comment">// 调用派生类可能重写的逻辑</span><br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// 可选的扩展点（派生类可自定义超时逻辑）</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">applyTimeout</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* 默认空实现 */</span> &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> timeout_ = <span class="hljs-number">5000</span>; <span class="hljs-comment">// 公共配置由基类管理</span><br>&#125;;<br><br><span class="hljs-comment">// 具体实现类：CURL 客户端</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CurlHttpClient</span> : <span class="hljs-keyword">public</span> HttpClient &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; url)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 使用 CURL 库实现 GET 请求</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Response from CURL&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">post</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; url, <span class="hljs-type">const</span> std::string&amp; data)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 使用 CURL 库实现 POST 请求</span><br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">applyTimeout</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 设置 CURL 超时参数</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体实现类：Mock 客户端（用于测试）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MockHttpClient</span> : <span class="hljs-keyword">public</span> HttpClient &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; url)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Mock response&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">post</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; url, <span class="hljs-type">const</span> std::string&amp; data)</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="4-常见错误与规避"><strong>4. 常见错误与规避</strong></h3>
<h4 id="（1）接口过于庞大（胖接口）"><strong>（1）接口过于庞大（胖接口）</strong></h4>
<ul>
<li><strong>问题</strong>：抽象类包含过多方法，导致派生类被迫实现无关功能。</li>
<li><strong>解决</strong>：拆分接口，使用多个抽象类。</li>
</ul>
<h4 id="（2）泄露实现细节"><strong>（2）泄露实现细节</strong></h4>
<ul>
<li><strong>问题</strong>：抽象类中声明了与接口无关的受保护/私有方法。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Encryptor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">encrypt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">generateKey</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// ❌ 实现细节暴露</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><strong>解决</strong>：将实现细节移至具体派生类或工具类。</li>
</ul>
<h4 id="（3）默认实现滥用"><strong>（3）默认实现滥用</strong></h4>
<ul>
<li><strong>问题</strong>：为纯虚函数提供默认实现，导致接口模糊。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parser</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">parse</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> </span>= <span class="hljs-number">0</span> &#123; <br>        <span class="hljs-comment">// 默认实现（违反接口定义初衷）</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><strong>解决</strong>：默认实现应通过非虚方法或策略类提供。</li>
</ul>
<hr>
<h3 id="5-抽象类-vs-接口（其他语言对比）"><strong>5. 抽象类 vs. 接口（其他语言对比）</strong></h3>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>C++ 抽象类</strong></th>
<th><strong>Java/C# 接口</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>多重继承</td>
<td>支持</td>
<td>支持（接口可多继承）</td>
</tr>
<tr>
<td>数据成员</td>
<td>允许（但应避免）</td>
<td>不允许（Java 8+ 允许静态常量）</td>
</tr>
<tr>
<td>默认方法实现</td>
<td>可为虚函数提供默认实现</td>
<td>Java 8+ 允许 <code>default</code> 方法</td>
</tr>
<tr>
<td>设计目标</td>
<td>接口与部分实现的混合体</td>
<td>纯契约定义</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="6-总结"><strong>6. 总结</strong></h3>
<ul>
<li><strong>抽象类的核心价值</strong>：定义稳定、清晰的接口契约，隔离变化，支持多态。</li>
<li><strong>关键原则</strong>：
<ul>
<li>接口最小化（单一职责）。</li>
<li>依赖抽象而非具体实现（DIP）。</li>
<li>通过 NVI 模式控制行为扩展。</li>
</ul>
</li>
<li><strong>适用场景</strong>：插件系统、跨平台模块、策略模式、测试替身（Mock）。</li>
</ul>
<h1>6 使用抽象类保持实现细节和接口分离。</h1>
<p>在面向对象设计中，通过抽象类将<strong>接口</strong>与<strong>实现细节</strong>分离是降低耦合、提升代码可维护性的核心实践。以下是实现这一目标的详细原则、示例及注意事项：</p>
<hr>
<h3 id="1-核心设计原则"><strong>1. 核心设计原则</strong></h3>
<h4 id="（1）接口定义纯净化"><strong>（1）接口定义纯净化</strong></h4>
<ul>
<li><strong>抽象类仅声明操作</strong>：通过纯虚函数定义“做什么”（接口），<strong>不涉及“怎么做”</strong>（实现）。</li>
<li><strong>避免暴露数据成员</strong>：接口类不应包含与状态相关的字段，仅定义行为。</li>
</ul>
<h4 id="2）实现细节隐藏"><strong>2）实现细节隐藏</strong></h4>
<ul>
<li><strong>派生类负责具体实现</strong>：所有与平台、算法、第三方库相关的代码封装在具体子类中。</li>
<li><strong>客户端代码依赖接口</strong>：调用方仅通过抽象类指针或引用操作对象，无需知晓具体实现。</li>
</ul>
<hr>
<h3 id="2-实现步骤与示例"><strong>2. 实现步骤与示例</strong></h3>
<h4 id="步骤-1：定义纯抽象接口"><strong>步骤 1：定义纯抽象接口</strong></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 文件操作接口（仅声明操作）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileStorage</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">FileStorage</span>() = <span class="hljs-keyword">default</span>;<br>    <br>    <span class="hljs-comment">// 纯虚接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">save</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data, <span class="hljs-type">const</span> std::string&amp; path)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">load</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; path)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="步骤-2：实现具体子类（隐藏细节）"><strong>步骤 2：实现具体子类（隐藏细节）</strong></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 具体实现：本地磁盘存储（细节隐藏在派生类中）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalDiskStorage</span> : <span class="hljs-keyword">public</span> FileStorage &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">save</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data, <span class="hljs-type">const</span> std::string&amp; path)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 实现细节：使用操作系统API或文件库（如fstream）</span><br>        <span class="hljs-function">std::ofstream <span class="hljs-title">file</span><span class="hljs-params">(path)</span></span>;<br>        file &lt;&lt; data;<br>    &#125;<br><br>    <span class="hljs-function">std::string <span class="hljs-title">load</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; path)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-function">std::ifstream <span class="hljs-title">file</span><span class="hljs-params">(path)</span></span>;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(std::<span class="hljs-built_in">istreambuf_iterator</span>&lt;<span class="hljs-type">char</span>&gt;(file), <br>                          std::<span class="hljs-built_in">istreambuf_iterator</span>&lt;<span class="hljs-type">char</span>&gt;());<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体实现：云存储（如AWS S3）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CloudStorage</span> : <span class="hljs-keyword">public</span> FileStorage &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">save</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data, <span class="hljs-type">const</span> std::string&amp; path)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 实现细节：调用云服务SDK</span><br>        <span class="hljs-built_in">aws_sdk_upload</span>(path, data);<br>    &#125;<br><br>    <span class="hljs-function">std::string <span class="hljs-title">load</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; path)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">aws_sdk_download</span>(path);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="步骤-3：客户端代码通过接口操作"><strong>步骤 3：客户端代码通过接口操作</strong></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 客户端代码仅依赖抽象接口</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backupData</span><span class="hljs-params">(FileStorage* storage, <span class="hljs-type">const</span> std::string&amp; data)</span> </span>&#123;<br>    storage-&gt;<span class="hljs-built_in">save</span>(data, <span class="hljs-string">&quot;/backup/data.txt&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 根据配置动态选择实现（无需修改客户端代码）</span><br>    FileStorage* storage = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CloudStorage</span>(); <span class="hljs-comment">// 或 LocalDiskStorage()</span><br>    <span class="hljs-built_in">backupData</span>(storage, <span class="hljs-string">&quot;Critical data&quot;</span>);<br>    <span class="hljs-keyword">delete</span> storage;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="3-关键注意事项-2"><strong>3. 关键注意事项</strong></h3>
<h4 id="（1）禁止在接口中暴露实现痕迹"><strong>（1）禁止在接口中暴露实现痕迹</strong></h4>
<ul>
<li><strong>错误示例</strong>：接口类包含具体实现才需要的方法。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileStorage</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">save</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setAwsRegion</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; region)</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// ❌ AWS相关细节污染接口</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><strong>解决方案</strong>：将平台特定配置移至实现类构造函数或参数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CloudStorage</span> : <span class="hljs-keyword">public</span> FileStorage &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CloudStorage</span>(<span class="hljs-type">const</span> std::string&amp; awsRegion) &#123; <span class="hljs-comment">/* 初始化AWS区域 */</span> &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（2）使用工厂模式隐藏对象创建"><strong>（2）使用工厂模式隐藏对象创建</strong></h4>
<ul>
<li><strong>问题</strong>：客户端直接调用具体类构造函数（如 <code>new CloudStorage()</code>）仍会引入依赖。</li>
<li><strong>解决</strong>：通过工厂类或函数返回接口指针。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StorageFactory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> FileStorage* <span class="hljs-title">createStorage</span><span class="hljs-params">(StorageType type)</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span> (type) &#123;<br>            <span class="hljs-keyword">case</span> StorageType::Local: <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">LocalDiskStorage</span>();<br>            <span class="hljs-keyword">case</span> StorageType::Cloud: <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">CloudStorage</span>(<span class="hljs-string">&quot;us-west-1&quot;</span>);<br>            <span class="hljs-keyword">default</span>: <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Unknown storage type&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 客户端代码</span><br>FileStorage* storage = StorageFactory::<span class="hljs-built_in">createStorage</span>(StorageType::Cloud);<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（3）避免“接口膨胀”"><strong>（3）避免“接口膨胀”</strong></h4>
<ul>
<li><strong>问题</strong>：随着需求增加，抽象类逐渐包含无关方法。</li>
<li><strong>解决</strong>：遵循<strong>接口隔离原则</strong>，拆分为多个精细接口。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 拆分前：臃肿接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultimediaPlayer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">playVideo</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">playAudio</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">adjustBrightness</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// ❌ 视频播放特有方法</span><br>&#125;;<br><br><span class="hljs-comment">// 拆分后：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AudioPlayer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">playAudio</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VideoPlayer</span> : <span class="hljs-keyword">public</span> AudioPlayer &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">playVideo</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">adjustBrightness</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="4-高级技巧：非虚接口模式（NVI）"><strong>4. 高级技巧：非虚接口模式（NVI）</strong></h3>
<ul>
<li><strong>目标</strong>：在接口中固化通用逻辑（如日志、校验），同时允许派生类自定义核心操作。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataProcessor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 非虚公共接口</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>        <span class="hljs-built_in">validateInput</span>(input);    <span class="hljs-comment">// 通用校验</span><br>        <span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">doProcess</span>(input); <span class="hljs-comment">// 调用派生类实现</span><br>        <span class="hljs-built_in">logResult</span>(result);       <span class="hljs-comment">// 通用日志</span><br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">DataProcessor</span>() = <span class="hljs-keyword">default</span>;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// 派生类实现核心逻辑</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">doProcess</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">validateInput</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (input.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Empty input&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logResult</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; result)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Processed result: &quot;</span> &lt;&lt; result &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EncryptionProcessor</span> : <span class="hljs-keyword">public</span> DataProcessor &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">doProcess</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">encryptAES</span>(input); <span class="hljs-comment">// 具体加密算法</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="5-典型应用场景"><strong>5. 典型应用场景</strong></h3>
<table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>接口设计示例</strong></th>
<th><strong>实现类示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>跨平台文件操作</strong></td>
<td><code>FileStorage</code></td>
<td><code>WindowsFileStorage</code>, <code>LinuxFileStorage</code></td>
</tr>
<tr>
<td><strong>支付网关集成</strong></td>
<td><code>PaymentGateway</code></td>
<td><code>PayPalGateway</code>, <code>StripeGateway</code></td>
</tr>
<tr>
<td><strong>数据库访问</strong></td>
<td><code>DatabaseClient</code></td>
<td><code>MySQLClient</code>, <code>PostgreSQLClient</code></td>
</tr>
<tr>
<td><strong>日志系统</strong></td>
<td><code>Logger</code></td>
<td><code>FileLogger</code>, <code>NetworkLogger</code></td>
</tr>
<tr>
<td><strong>UI 渲染引擎</strong></td>
<td><code>Renderer</code></td>
<td><code>OpenGLRenderer</code>, <code>VulkanRenderer</code></td>
</tr>
</tbody>
</table>
<hr>
<h3 id="6-常见反模式与规避"><strong>6. 常见反模式与规避</strong></h3>
<table>
<thead>
<tr>
<th><strong>反模式</strong></th>
<th><strong>问题</strong></th>
<th><strong>规避方法</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>接口包含实现细节</strong></td>
<td>如接口中声明 <code>void setupAWS()</code></td>
<td>将平台相关代码移至实现类</td>
</tr>
<tr>
<td><strong>虚函数提供默认实现</strong></td>
<td>导致接口模糊</td>
<td>默认实现通过 NVI 模式封装</td>
</tr>
<tr>
<td><strong>客户端直接依赖具体类</strong></td>
<td>违反依赖倒置原则</td>
<td>使用工厂模式或依赖注入框架</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="总结-5"><strong>总结</strong></h3>
<p>通过抽象类分离接口与实现的核心价值在于：</p>
<ul>
<li><strong>降低耦合</strong>：模块间通过抽象接口通信，而非具体实现。</li>
<li><strong>提升扩展性</strong>：新增功能只需添加派生类，无需修改现有代码。</li>
<li><strong>增强可测试性</strong>：通过 Mock 实现类轻松进行单元测试。</li>
</ul>
<p>遵循“依赖抽象而非具体”的原则，结合工厂模式、策略模式等设计模式，可构建高度灵活且易于维护的系统架构。</p>
<h1>7 如果一个类有虚函数，那么它也应该有一个虚析构函数。</h1>
<p>在C++中，<strong>如果一个类有虚函数，那么它必须有一个虚析构函数</strong>。以下是详细解释和示例：</p>
<hr>
<h3 id="1-为什么需要虚析构函数？"><strong>1. 为什么需要虚析构函数？</strong></h3>
<ul>
<li><strong>多态销毁需求</strong>：当通过基类指针删除派生类对象时，如果基类析构函数非虚，只会调用基类的析构函数，导致派生类资源泄漏。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>&#123;&#125;  <span class="hljs-comment">// 虚函数</span><br>    ~<span class="hljs-built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base destroyed\n&quot;</span>; &#125;  <span class="hljs-comment">// 非虚析构函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Derived destroyed\n&quot;</span>; &#125; <span class="hljs-comment">// 不会被调用</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base* obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    <span class="hljs-keyword">delete</span> obj;  <span class="hljs-comment">// 仅输出 &quot;Base destroyed&quot;（派生类析构函数未调用）</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="2-虚析构函数的作用"><strong>2. 虚析构函数的作用</strong></h3>
<ul>
<li><strong>动态绑定析构过程</strong>：声明虚析构函数后，通过基类指针删除对象时，会先调用派生类析构函数，再调用基类析构函数。</li>
<li><strong>修正示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base destroyed\n&quot;</span>; &#125;  <span class="hljs-comment">// ✔️ 虚析构函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Derived</span>() <span class="hljs-keyword">override</span> &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Derived destroyed\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Base* obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    <span class="hljs-keyword">delete</span> obj;  <span class="hljs-comment">// 输出 &quot;Derived destroyed&quot; → &quot;Base destroyed&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="3-核心规则"><strong>3. 核心规则</strong></h3>
<ul>
<li><strong>类有虚函数 → 析构函数必须为虚</strong>：虚函数的存在意味着类可能被继承，需通过虚析构函数确保对象完整销毁。</li>
<li><strong>例外情况</strong>：若类明确标记为 <code>final</code>（禁止继承），且不通过基类指针操作对象，可省略虚析构函数。但这种情况极少见。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> <span class="hljs-keyword">final</span> &#123;  <span class="hljs-comment">// 禁止继承</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>&#123;&#125;  <span class="hljs-comment">// 虚函数</span><br>    ~<span class="hljs-built_in">Base</span>() &#123;&#125;  <span class="hljs-comment">// 允许非虚析构函数（因无法派生，无多态销毁需求）</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="4-设计原则"><strong>4. 设计原则</strong></h3>
<ol>
<li><strong>基类必须提供虚析构函数</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractBase</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">operation</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AbstractBase</span>() = <span class="hljs-keyword">default</span>;  <span class="hljs-comment">// ✔️ 虚析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><strong>派生类析构函数应标记 <code>override</code></strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Concrete</span> : <span class="hljs-keyword">public</span> AbstractBase &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Concrete</span>() <span class="hljs-keyword">override</span> &#123; <span class="hljs-comment">/* 清理派生类资源 */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><strong>优先使用智能指针</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::unique_ptr&lt;AbstractBase&gt; obj = std::<span class="hljs-built_in">make_unique</span>&lt;Concrete&gt;();<br></code></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="5-未使用虚析构函数的后果"><strong>5. 未使用虚析构函数的后果</strong></h3>
<ul>
<li><strong>资源泄漏</strong>：派生类独有的资源（如动态内存、文件句柄）无法释放。</li>
<li><strong>行为未定义</strong>：若派生类析构函数有副作用（如日志、状态更新），这些操作将不会执行。</li>
</ul>
<hr>
<h3 id="总结-6"><strong>总结</strong></h3>
<ul>
<li><strong>强制规则</strong>：只要类包含虚函数，其析构函数必须为虚。</li>
<li><strong>底层原理</strong>：虚析构函数启用动态绑定，确保多态对象的完整析构。</li>
<li><strong>最佳实践</strong>：
<ul>
<li>基类析构函数始终声明为虚。</li>
<li>派生类析构函数使用 <code>override</code> 明确意图。</li>
<li>避免手动管理内存，使用智能指针（如 <code>std::unique_ptr</code>）。</li>
</ul>
</li>
</ul>
<h1>8 抽象类通常不需要构造函数。</h1>
<p>在面向对象编程中，抽象类的主要目的是定义接口和规范派生类的行为，而不是直接实例化对象。关于抽象类是否需要构造函数，以下是一些关键点：</p>
<hr>
<h3 id="1-抽象类构造函数的必要性"><strong>1. 抽象类构造函数的必要性</strong></h3>
<ul>
<li><strong>是否需要构造函数？</strong><br>
抽象类是否需要构造函数取决于其<strong>是否包含需要初始化的成员变量或资源</strong>：
<ul>
<li><strong>无成员变量或默认初始化足够</strong>：若抽象类没有数据成员，或所有成员可默认初始化（如 <code>int</code>、指针等），则<strong>无需显式定义构造函数</strong>。</li>
<li><strong>需要初始化成员或逻辑</strong>：若抽象类包含需要明确初始化的成员（如引用、复杂对象），或需在构造时执行某些操作（如日志记录、资源预分配），则<strong>必须定义构造函数</strong>。</li>
</ul>
</li>
</ul>
<h4 id="示例：需要构造函数的场景"><strong>示例：需要构造函数的场景</strong></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractDevice</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    std::string deviceId;  <span class="hljs-comment">// 需要初始化</span><br>    <span class="hljs-built_in">AbstractDevice</span>(<span class="hljs-type">const</span> std::string&amp; id) : <span class="hljs-built_in">deviceId</span>(id) &#123;&#125;  <span class="hljs-comment">// 保护构造函数</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AbstractDevice</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Camera</span> : <span class="hljs-keyword">public</span> AbstractDevice &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Camera</span>(<span class="hljs-type">const</span> std::string&amp; id) : <span class="hljs-built_in">AbstractDevice</span>(id) &#123;&#125;  <span class="hljs-comment">// 初始化基类成员</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="2-抽象类构造函数的设计原则"><strong>2. 抽象类构造函数的设计原则</strong></h3>
<ul>
<li>
<p><strong>访问权限设为 <code>protected</code></strong>：<br>
抽象类的构造函数通常声明为 <code>protected</code>，以防止外部代码直接实例化抽象类（尽管编译器会阻止，但这是良好的设计习惯）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractService</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">AbstractService</span>() = <span class="hljs-keyword">default</span>;  <span class="hljs-comment">// 保护构造函数</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AbstractService</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>避免纯虚构造函数</strong>：<br>
C++ 不支持纯虚构造函数，因为构造函数用于对象初始化，而虚函数机制依赖已存在的对象。</p>
</li>
</ul>
<hr>
<h3 id="3-何时可以省略构造函数？"><strong>3. 何时可以省略构造函数？</strong></h3>
<ul>
<li><strong>无状态抽象类</strong>：若抽象类仅包含纯虚函数，不涉及数据成员或资源，则依赖编译器生成的默认构造函数即可。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractParser</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">parse</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AbstractParser</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-comment">// 无需显式构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="4-构造函数的用途"><strong>4. 构造函数的用途</strong></h3>
<ul>
<li><strong>初始化基类成员</strong>：确保派生类构造时，基类成员已正确初始化。</li>
<li><strong>执行公共逻辑</strong>：如注册实例到管理类、初始化日志系统等。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractSensor</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">AbstractSensor</span>() &#123;<br>        SensorManager::<span class="hljs-built_in">registerSensor</span>(<span class="hljs-keyword">this</span>);  <span class="hljs-comment">// 公共初始化逻辑</span><br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">readValue</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AbstractSensor</span>() &#123;<br>        SensorManager::<span class="hljs-built_in">unregisterSensor</span>(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="5-总结"><strong>5. 总结</strong></h3>
<table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>是否需要构造函数？</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>抽象类无数据成员</td>
<td>否（依赖默认构造函数）</td>
<td>仅包含纯虚函数的接口类</td>
</tr>
<tr>
<td>抽象类需初始化成员或资源</td>
<td>是（需显式定义）</td>
<td>基类包含 <code>std::string</code> 等成员</td>
</tr>
<tr>
<td>抽象类需执行构造期公共逻辑</td>
<td>是（如注册对象到全局管理器）</td>
<td>初始化日志、依赖注入等</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>核心原则</strong>：抽象类的构造函数应根据其职责定义，而非盲目添加或省略。优先通过设计避免抽象类持有具体数据，保持接口的纯粹性。</li>
</ul>
<h1>9 优先选择private成员用于类的细节实现。</h1>
<p>在面向对象编程中，优先将类的成员变量和实现细节声明为 <strong><code>private</code></strong> 是封装（Encapsulation）原则的核心实践。这种做法通过隐藏内部实现细节，仅暴露必要的接口，显著提升了代码的安全性、可维护性和灵活性。以下是详细说明及示例：</p>
<hr>
<h3 id="1-为什么优先选择-private-成员？"><strong>1. 为什么优先选择 <code>private</code> 成员？</strong></h3>
<h4 id="（1）保护数据完整性"><strong>（1）保护数据完整性</strong></h4>
<ul>
<li>
<p><strong>问题</strong>：若成员变量为 <code>public</code>，外部代码可直接修改数据，可能导致无效状态。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ❌ 错误示例：public 成员导致数据可能被破坏</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BankAccount</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">double</span> balance; <span class="hljs-comment">// 外部可直接修改</span><br>&#125;;<br><br>BankAccount acc;<br>acc.balance = <span class="hljs-number">-1000</span>; <span class="hljs-comment">// 余额为负数，逻辑错误</span><br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ✔️ 正确示例：private 成员 + 受控访问方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BankAccount</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> balance; <span class="hljs-comment">// 外部无法直接访问</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (amount &gt; <span class="hljs-number">0</span>) balance += amount;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (amount &gt; <span class="hljs-number">0</span> &amp;&amp; balance &gt;= amount) &#123;<br>            balance -= amount;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> balance; &#125;<br>&#125;;<br><br>BankAccount acc;<br>acc.<span class="hljs-built_in">withdraw</span>(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 通过方法控制，避免非法操作</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（2）降低耦合性"><strong>（2）降低耦合性</strong></h4>
<ul>
<li><strong>隐藏实现细节</strong>：外部代码仅依赖公共接口，当内部实现变化时（如数据结构优化），无需修改调用方代码。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TemperatureSensor</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 内部可能使用摄氏温度存储，未来可改为华氏温度</span><br>    <span class="hljs-type">double</span> celsius;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getFahrenheit</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> celsius * <span class="hljs-number">9</span> / <span class="hljs-number">5</span> + <span class="hljs-number">32</span>; <span class="hljs-comment">// 转换逻辑封装在类内</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCelsius</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span> </span>&#123; celsius = value; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 未来修改内部存储为华氏温度：</span><br><span class="hljs-comment">// class TemperatureSensor &#123; private: double fahrenheit; ... &#125;;</span><br><span class="hljs-comment">// 外部代码无需感知变化，getFahrenheit() 接口保持一致</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（3）支持不变式（Invariants）"><strong>（3）支持不变式（Invariants）</strong></h4>
<ul>
<li><strong>强制约束条件</strong>：通过 <code>private</code> 成员和方法，确保对象状态始终符合业务规则。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> day, month, year;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-comment">/* 检查日期合法性 */</span> &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> d, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> y) : <span class="hljs-built_in">day</span>(d), <span class="hljs-built_in">month</span>(m), <span class="hljs-built_in">year</span>(y) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isValid</span>()) <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid date&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setDay</span><span class="hljs-params">(<span class="hljs-type">int</span> d)</span> </span>&#123;<br>        <span class="hljs-type">int</span> oldDay = day;<br>        day = d;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isValid</span>()) &#123; <span class="hljs-comment">// 修改后校验不变式</span><br>            day = oldDay;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid day&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="2-如何设计-private-成员？"><strong>2. 如何设计 <code>private</code> 成员？</strong></h3>
<h4 id="（1）默认所有成员为-private"><strong>（1）默认所有成员为 <code>private</code></strong></h4>
<ul>
<li><strong>规则</strong>：除非明确需要暴露，否则所有数据成员和辅助方法均设为 <code>private</code>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string username;<br>    std::string hashedPassword; <span class="hljs-comment">// 敏感数据必须私有</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logActivity</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; action)</span> </span>&#123; <span class="hljs-comment">/* 内部日志方法 */</span> &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">authenticate</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; password)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（2）提供最小化的公共接口"><strong>（2）提供最小化的公共接口</strong></h4>
<ul>
<li><strong>仅暴露必要操作</strong>：通过公共方法（如 <code>getter</code>/<code>setter</code>）或函数式接口控制访问。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; elements;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123; elements.<span class="hljs-built_in">push_back</span>(value); &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (elements.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Stack empty&quot;</span>);<br>        <span class="hljs-type">int</span> top = elements.<span class="hljs-built_in">back</span>();<br>        elements.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-keyword">return</span> top;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> elements.<span class="hljs-built_in">empty</span>(); &#125;<br>    <span class="hljs-comment">// 不暴露 vector 的 size()，避免外部依赖具体实现</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（3）避免返回内部数据的引用-指针"><strong>（3）避免返回内部数据的引用/指针</strong></h4>
<ul>
<li><strong>防止外部修改</strong>：若需提供数据访问，返回副本或只读视图。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::map&lt;std::string, std::string&gt; settings;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 返回副本，避免外部修改内部数据</span><br>    <span class="hljs-function">std::string <span class="hljs-title">getValue</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; key)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> it = settings.<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">return</span> it != settings.<span class="hljs-built_in">end</span>() ? it-&gt;second : <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 返回 const 引用（仅当数据生命周期可控时）</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> std::map&lt;std::string, std::string&gt;&amp; <span class="hljs-title">getAllSettings</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> settings;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="3-何时使用-protected-或-public-成员？"><strong>3. 何时使用 <code>protected</code> 或 <code>public</code> 成员？</strong></h3>
<h4 id="（1）protected-成员"><strong>（1）<code>protected</code> 成员</strong></h4>
<ul>
<li><strong>适用场景</strong>：允许派生类访问基类实现细节，但需谨慎使用（仍可能破坏封装）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// 派生类可能需要直接访问颜色</span><br>    std::string color;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setColor</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; c)</span> </span>&#123; color = c; &#125; <span class="hljs-comment">// 访问基类 protected 成员</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（2）public-成员"><strong>（2）<code>public</code> 成员</strong></h4>
<ul>
<li><strong>适用场景</strong>：
<ul>
<li><strong>简单数据容器</strong>（类似 C 的结构体，无复杂行为）。</li>
<li><strong>性能关键代码</strong>（需直接访问数据，避免方法调用开销）。</li>
<li><strong>遵循特定设计模式</strong>（如数据传输对象 DTO）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-典型错误与规避"><strong>4. 典型错误与规避</strong></h3>
<table>
<thead>
<tr>
<th><strong>错误</strong></th>
<th><strong>后果</strong></th>
<th><strong>规避方法</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>将可变数据成员设为 <code>public</code></td>
<td>外部代码破坏对象状态</td>
<td>始终通过方法控制数据修改</td>
</tr>
<tr>
<td>返回内部数据的非 <code>const</code> 引用</td>
<td>外部绕过接口直接修改内部数据</td>
<td>返回副本或 <code>const</code> 引用</td>
</tr>
<tr>
<td>过度使用 <code>protected</code></td>
<td>派生类与基类过度耦合</td>
<td>优先组合而非继承，减少层级</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="5-总结-2"><strong>5. 总结</strong></h3>
<ul>
<li><strong>核心原则</strong>：默认所有成员为 <code>private</code>，仅在必要时提供受控的公共接口。</li>
<li><strong>优势</strong>：
<ul>
<li><strong>安全性</strong>：防止非法状态修改。</li>
<li><strong>可维护性</strong>：隔离变化，降低模块间依赖。</li>
<li><strong>灵活性</strong>：允许内部优化而不影响外部代码。</li>
</ul>
</li>
<li><strong>实践建议</strong>：
<ul>
<li>使用 <code>getter</code>/<code>setter</code> 方法控制数据访问。</li>
<li>避免暴露实现细节（如容器类型、算法）。</li>
<li>优先选择组合而非继承，减少 <code>protected</code> 的使用。</li>
</ul>
</li>
</ul>
<h1>10 优先选择public成员用于接口。</h1>
<p>在面向对象设计中，将 <strong><code>public</code> 成员作为类的接口</strong> 是封装与模块化设计的核心实践。以下是优先使用 <code>public</code> 成员定义接口的关键原则、示例及注意事项：</p>
<hr>
<h3 id="1-为什么优先选择-public-成员作为接口？"><strong>1. 为什么优先选择 <code>public</code> 成员作为接口？</strong></h3>
<h4 id="（1）明确类的职责"><strong>（1）明确类的职责</strong></h4>
<ul>
<li><strong>接口即契约</strong>：<code>public</code> 方法定义了类对外提供的功能，调用方仅需关注这些方法，无需关心内部实现。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReader</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 公共接口：明确职责为读取文件内容</span><br>    <span class="hljs-function">std::string <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; path)</span> </span>&#123;<br>        <span class="hljs-built_in">validatePath</span>(path);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">readFromDisk</span>(path); <span class="hljs-comment">// 内部实现隐藏</span><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">validatePath</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; path)</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">readFromDisk</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; path)</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（2）增强可维护性"><strong>（2）增强可维护性</strong></h4>
<ul>
<li><strong>修改不影响调用方</strong>：若内部实现（如缓存策略、算法）变更，只要 <code>public</code> 接口不变，客户端代码无需调整。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始实现：无缓存</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataFetcher</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">fetch</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123; <span class="hljs-comment">/* 直接查询数据库 */</span> &#125;<br>&#125;;<br><br><span class="hljs-comment">// 优化后：添加缓存，接口不变</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataFetcher</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">fetch</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123; <br>        <span class="hljs-keyword">if</span> (cache.<span class="hljs-built_in">has</span>(id)) <span class="hljs-keyword">return</span> cache.<span class="hljs-built_in">get</span>(id);<br>        <span class="hljs-keyword">auto</span> data = <span class="hljs-built_in">queryDatabase</span>(id);<br>        cache.<span class="hljs-built_in">add</span>(id, data);<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    DatabaseCache cache; <span class="hljs-comment">// 新增缓存实现</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（3）支持多态与扩展"><strong>（3）支持多态与扩展</strong></h4>
<ul>
<li><strong>虚函数公开</strong>：基类的 <code>public</code> 虚函数允许派生类重写，实现运行时多态。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 公共多态接口</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shape</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> π * radius * radius; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> radius;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="2-如何设计-public-接口？"><strong>2. 如何设计 <code>public</code> 接口？</strong></h3>
<h4 id="（1）最小化暴露原则"><strong>（1）最小化暴露原则</strong></h4>
<ul>
<li><strong>仅暴露必要操作</strong>：避免将内部辅助方法或数据设为 <code>public</code>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ❌ 错误示例：暴露过多细节</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NetworkClient</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connect</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disconnect</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logError</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// ❌ 日志应作为内部实现</span><br>&#125;;<br><br><span class="hljs-comment">// ✔️ 正确示例：接口聚焦核心功能</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NetworkClient</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendRequest</span><span class="hljs-params">(<span class="hljs-type">const</span> Request&amp; req)</span></span>;<br>    <span class="hljs-function">Response <span class="hljs-title">getResponse</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logError</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 日志逻辑隐藏</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（2）优先使用方法而非数据成员"><strong>（2）优先使用方法而非数据成员</strong></h4>
<ul>
<li><strong>封装数据访问</strong>：通过 <code>public</code> 方法（如 <code>getter</code>/<code>setter</code>）控制数据读写，而非直接暴露 <code>public</code> 数据成员。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ❌ 错误示例：public 数据成员</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::string name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">// ✔️ 正确示例：受控访问</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> name; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; newName)</span> </span>&#123; <br>        <span class="hljs-keyword">if</span> (!newName.<span class="hljs-built_in">empty</span>()) name = newName;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    std::string name;<br>    <span class="hljs-type">int</span> age;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（3）使用非虚接口模式（NVI）"><strong>（3）使用非虚接口模式（NVI）</strong></h4>
<ul>
<li><strong>公共接口非虚</strong>：在基类中定义非虚的 <code>public</code> 方法，内部调用 <code>protected</code> 虚方法，增强控制。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataProcessor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 非虚公共接口</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">validate</span>();<br>        <span class="hljs-built_in">doProcess</span>(); <span class="hljs-comment">// 调用派生类实现</span><br>        <span class="hljs-built_in">cleanup</span>();<br>    &#125;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doProcess</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 派生类重写此方法</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">validate</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* 通用校验 */</span> &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* 通用清理 */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="3-典型场景与示例"><strong>3. 典型场景与示例</strong></h3>
<h4 id="（1）接口类（抽象类）"><strong>（1）接口类（抽象类）</strong></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义抽象接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EncryptionAlgorithm</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">encrypt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">decrypt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; cipher)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">EncryptionAlgorithm</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-comment">// 具体实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AES</span> : <span class="hljs-keyword">public</span> EncryptionAlgorithm &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">encrypt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* AES加密 */</span> &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">decrypt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; cipher)</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* AES解密 */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="（2）工具类"><strong>（2）工具类</strong></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 公共静态方法作为工具接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MathUtils</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title">radiansToDegrees</span><span class="hljs-params">(<span class="hljs-type">double</span> rad)</span> </span>&#123; <span class="hljs-keyword">return</span> rad * <span class="hljs-number">180</span> / π; &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title">degreesToRadians</span><span class="hljs-params">(<span class="hljs-type">double</span> deg)</span> </span>&#123; <span class="hljs-keyword">return</span> deg * π / <span class="hljs-number">180</span>; &#125;<br>    <span class="hljs-comment">// 无需实例化，构造函数设为 delete</span><br>    <span class="hljs-built_in">MathUtils</span>() = <span class="hljs-keyword">delete</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="（3）工厂类"><strong>（3）工厂类</strong></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggerFactory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Logger <span class="hljs-title">createFileLogger</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; path)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">FileLogger</span>(path);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> Logger <span class="hljs-title">createConsoleLogger</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ConsoleLogger</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="4-避免的常见错误"><strong>4. 避免的常见错误</strong></h3>
<table>
<thead>
<tr>
<th><strong>错误</strong></th>
<th><strong>后果</strong></th>
<th><strong>正确做法</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>暴露内部数据结构（如 <code>vector</code>）</td>
<td>调用方依赖具体实现，难以重构</td>
<td>封装为 <code>getResults()</code> 返回副本</td>
</tr>
<tr>
<td>公共虚函数无默认实现</td>
<td>派生类被迫实现不相关逻辑</td>
<td>提供默认实现或拆分为更小接口</td>
</tr>
<tr>
<td>过度设计复杂接口</td>
<td>接口难以理解和使用</td>
<td>遵循单一职责原则拆分接口</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="5-总结-3"><strong>5. 总结</strong></h3>
<ul>
<li><strong><code>public</code> 接口的设计目标</strong>：
<ul>
<li><strong>清晰</strong>：明确类的核心职责。</li>
<li><strong>稳定</strong>：减少变更对调用方的影响。</li>
<li><strong>安全</strong>：通过封装防止非法操作。</li>
</ul>
</li>
<li><strong>关键实践</strong>：
<ul>
<li>使用 <code>public</code> 方法而非数据成员。</li>
<li>优先通过抽象类定义接口。</li>
<li>利用 NVI 模式控制派生类行为。</li>
</ul>
</li>
<li><strong>记住</strong>：好的接口设计是代码可维护性和扩展性的基石。</li>
</ul>
<h1>11 仅在确实需要时才使用protected成员，且务必小心使用。</h1>
<p>在面向对象编程中，<code>protected</code> 成员允许派生类访问基类的内部实现细节，但这种能力是一把双刃剑。过度或不当使用 <code>protected</code> 成员会导致代码耦合度高、可维护性差，甚至引发难以调试的问题。以下是关于 <strong>“仅在确实需要时才使用 <code>protected</code> 成员，且务必小心使用”</strong> 的详细解析：</p>
<hr>
<h3 id="1-为什么需要谨慎使用-protected-成员？"><strong>1. 为什么需要谨慎使用 <code>protected</code> 成员？</strong></h3>
<h4 id="（1）破坏封装性"><strong>（1）破坏封装性</strong></h4>
<ul>
<li><strong>问题</strong>：<code>protected</code> 成员暴露了基类的实现细节，导致派生类直接依赖这些细节。一旦基类修改，所有派生类都可能需要调整。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data;  <span class="hljs-comment">// 暴露内部数据结构</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>&#123;<br>        data.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">42</span>);  <span class="hljs-comment">// 直接操作基类成员</span><br>        <span class="hljs-comment">// 若基类将 data 改为链表，此代码将失效</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（2）增加维护成本"><strong>（2）增加维护成本</strong></h4>
<ul>
<li><strong>问题</strong>：基类的 <code>protected</code> 成员成为派生类的“隐式接口”，修改基类时需检查所有派生类的使用情况。</li>
<li><strong>反例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> counter;  <span class="hljs-comment">// 基类修改为 atomic&lt;int&gt;，派生类代码可能崩溃</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123; counter++; &#125;  <span class="hljs-comment">// 假设 counter 是普通 int</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（3）违反里氏替换原则（LSP）"><strong>（3）违反里氏替换原则（LSP）</strong></h4>
<ul>
<li><strong>风险</strong>：派生类可能以不符合基类预期的方式操作 <code>protected</code> 成员，导致行为不一致。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">double</span> balance;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (amount &lt;= balance) balance -= amount;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OverdraftAccount</span> : <span class="hljs-keyword">public</span> Account &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        balance -= amount;  <span class="hljs-comment">// 直接修改 balance，允许透支</span><br>        <span class="hljs-comment">// 违反基类对 balance 的不变性约束（余额非负）</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="2-何时确实需要使用-protected-成员？"><strong>2. 何时确实需要使用 <code>protected</code> 成员？</strong></h3>
<h4 id="（1）模板方法模式（Template-Method-Pattern）"><strong>（1）模板方法模式（Template Method Pattern）</strong></h4>
<ul>
<li><strong>场景</strong>：基类定义算法框架，派生类通过覆盖 <code>protected</code> 虚方法定制部分步骤。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataProcessor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 非虚公共接口</span><br>        <span class="hljs-built_in">validate</span>();<br>        <span class="hljs-built_in">transform</span>();  <span class="hljs-comment">// 调用派生类自定义逻辑</span><br>        <span class="hljs-built_in">save</span>();<br>    &#125;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">transform</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">// 派生类必须实现的步骤</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">validate</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* 通用校验 */</span> &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* 通用保存逻辑 */</span> &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSVProcessor</span> : <span class="hljs-keyword">public</span> DataProcessor &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">transform</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* CSV 转换逻辑 */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（2）为派生类提供工具方法"><strong>（2）为派生类提供工具方法</strong></h4>
<ul>
<li><strong>场景</strong>：基类提供辅助函数供派生类复用，但无需暴露给外部。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NetworkService</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendRequest</span><span class="hljs-params">(<span class="hljs-type">const</span> Request&amp; req)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">validate</span>(req)) <span class="hljs-built_in">encodeAndSend</span>(req);<br>    &#125;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validate</span><span class="hljs-params">(<span class="hljs-type">const</span> Request&amp; req)</span> </span>&#123; <span class="hljs-comment">/* 通用校验逻辑 */</span> &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">encodeAndSend</span><span class="hljs-params">(<span class="hljs-type">const</span> Request&amp; req)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpService</span> : <span class="hljs-keyword">public</span> NetworkService &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">encodeAndSend</span><span class="hljs-params">(<span class="hljs-type">const</span> Request&amp; req)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 复用基类的 validate 方法</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（3）允许派生类访问受限状态"><strong>（3）允许派生类访问受限状态</strong></h4>
<ul>
<li><strong>场景</strong>：派生类需要基于基类状态实现特定逻辑，但外部无需感知。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StateMachine</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">State</span> &#123; Idle, Running &#125;;<br>    State currentState = State::Idle;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (currentState == State::Idle) &#123;<br>            currentState = State::Running;<br>            <span class="hljs-built_in">onStart</span>();  <span class="hljs-comment">// 通知派生类</span><br>        &#125;<br>    &#125;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> </span>&#123;&#125;  <span class="hljs-comment">// 钩子方法</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomMachine</span> : <span class="hljs-keyword">public</span> StateMachine &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 基于 currentState 实现逻辑</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="3-安全使用-protected-成员的准则"><strong>3. 安全使用 <code>protected</code> 成员的准则</strong></h3>
<h4 id="（1）优先使用-private，仅在必要时升级为-protected"><strong>（1）优先使用 <code>private</code>，仅在必要时升级为 <code>protected</code></strong></h4>
<ul>
<li><strong>规则</strong>：默认所有成员为 <code>private</code>，仅当派生类确实需要访问且无法通过其他方式（如公有方法）实现时，才改为 <code>protected</code>。</li>
</ul>
<h4 id="（2）避免暴露数据成员"><strong>（2）避免暴露数据成员</strong></h4>
<ul>
<li><strong>推荐</strong>：尽量提供 <code>protected</code> 方法而非数据成员，封装状态操作。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ❌ 危险：暴露数据成员</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data;<br>&#125;;<br><br><span class="hljs-comment">// ✔️ 安全：封装数据访问</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addData</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123; data.<span class="hljs-built_in">push_back</span>(value); &#125;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">dataSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">size</span>(); &#125;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（3）通过文档明确契约"><strong>（3）通过文档明确契约</strong></h4>
<ul>
<li><strong>要求</strong>：在基类中通过注释或文档说明 <code>protected</code> 成员的预期用途和约束条件。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 派生类可重写此方法以实现自定义渲染逻辑。</span><br><span class="hljs-comment">     * 注意：此方法需在 10ms 内完成，否则会阻塞主线程。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">render</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（4）使用非虚接口模式（NVI）"><strong>（4）使用非虚接口模式（NVI）</strong></h4>
<ul>
<li><strong>技巧</strong>：将公共接口设为非虚，调用 <code>protected</code> 虚方法，增强控制。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 非虚公共方法</span><br>        <span class="hljs-built_in">preProcess</span>();<br>        <span class="hljs-built_in">doExecute</span>();  <span class="hljs-comment">// 派生类实现</span><br>        <span class="hljs-built_in">postProcess</span>();<br>    &#125;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doExecute</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">// 实际逻辑点</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preProcess</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* 通用预处理 */</span> &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postProcess</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* 通用后处理 */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="4-替代方案：优先组合而非继承"><strong>4. 替代方案：优先组合而非继承</strong></h3>
<ul>
<li><strong>场景</strong>：若功能可通过组合其他类实现，无需使用 <code>protected</code> 成员。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 通过组合策略对象替代继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentProcessor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">PaymentProcessor</span><span class="hljs-params">(std::unique_ptr&lt;PaymentStrategy&gt; strategy)</span></span><br><span class="hljs-function">        : strategy_(std::move(strategy)) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> </span>&#123; strategy_-&gt;<span class="hljs-built_in">execute</span>(amount); &#125;<br><span class="hljs-keyword">private</span>:<br>    std::unique_ptr&lt;PaymentStrategy&gt; strategy_;<br>&#125;;<br><br><span class="hljs-comment">// 策略接口无需暴露 protected 成员</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentStrategy</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">PaymentStrategy</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="5-总结-4"><strong>5. 总结</strong></h3>
<ul>
<li><strong>谨慎使用 <code>protected</code> 成员</strong>：仅在派生类必须访问基类实现细节时使用，且优先提供方法而非数据。</li>
<li><strong>核心原则</strong>：
<ul>
<li><strong>封装优先</strong>：通过 <code>private</code> 和公有接口隐藏实现。</li>
<li><strong>契约明确</strong>：确保 <code>protected</code> 成员的行为和约束清晰。</li>
<li><strong>减少耦合</strong>：优先组合、模板方法模式等设计降低依赖。</li>
</ul>
</li>
<li><strong>最终目标</strong>：在灵活性和封装性之间取得平衡，构建可维护、可扩展的代码结构。</li>
</ul>
<h1>12 不要将数据成员声明为protected。</h1>
<p>在面向对象编程中，避免将数据成员声明为 <code>protected</code> 是遵循封装原则的关键实践。以下是详细的理由及替代方案：</p>
<hr>
<h3 id="1-为什么不应将数据成员声明为-protected？"><strong>1. 为什么不应将数据成员声明为 <code>protected</code>？</strong></h3>
<h4 id="（1）破坏封装性-2"><strong>（1）破坏封装性</strong></h4>
<ul>
<li><strong>问题</strong>：<code>protected</code> 数据成员暴露了基类的实现细节，派生类可直接访问和修改这些数据，导致基类失去对数据一致性的控制。</li>
<li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> internalCounter;  <span class="hljs-comment">// 派生类可直接修改</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">manipulate</span><span class="hljs-params">()</span> </span>&#123;<br>        internalCounter = <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 非法操作，破坏基类状态</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（2）增加耦合性"><strong>（2）增加耦合性</strong></h4>
<ul>
<li><strong>风险</strong>：基类数据结构的修改（如字段类型、名称）会强制所有派生类同步调整，违反<strong>开放-封闭原则</strong>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 基类原设计</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data;  <span class="hljs-comment">// 暴露具体容器类型</span><br>&#125;;<br><br><span class="hljs-comment">// 若基类改为使用链表：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    std::list&lt;<span class="hljs-type">int</span>&gt; data;  <span class="hljs-comment">// 派生类中所有依赖 vector 的代码将失效</span><br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（3）难以维护不变式（Invariants）"><strong>（3）难以维护不变式（Invariants）</strong></h4>
<ul>
<li><strong>问题</strong>：基类无法确保派生类操作数据时遵守业务规则（如范围校验、状态同步）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">double</span> balance;  <span class="hljs-comment">// 派生类可能绕过校验直接修改</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (amount &lt;= balance) balance -= amount;  <span class="hljs-comment">// 规则可能被绕过</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="2-替代方案：通过方法封装数据访问"><strong>2. 替代方案：通过方法封装数据访问</strong></h3>
<h4 id="（1）提供-protected-方法操作数据"><strong>（1）提供 <code>protected</code> 方法操作数据</strong></h4>
<ul>
<li><strong>封装数据修改</strong>：派生类通过基类方法间接访问数据，确保操作合法。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> internalCounter;  <span class="hljs-comment">// 数据私有化</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// 受控的访问方法</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCounter</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-number">0</span>) internalCounter = value;  <span class="hljs-comment">// 强制校验</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCounter</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> internalCounter; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">safeManipulate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">setCounter</span>(<span class="hljs-number">42</span>);  <span class="hljs-comment">// 通过方法修改，避免非法状态</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（2）使用非虚接口模式（NVI）"><strong>（2）使用非虚接口模式（NVI）</strong></h4>
<ul>
<li><strong>固定算法骨架</strong>：基类定义非虚公共方法，内部调用虚方法实现扩展点。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataProcessor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 非虚方法，控制流程</span><br>        <span class="hljs-built_in">validate</span>();<br>        <span class="hljs-built_in">doProcess</span>();  <span class="hljs-comment">// 派生类实现细节</span><br>        <span class="hljs-built_in">logResult</span>();<br>    &#125;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doProcess</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">// 扩展点</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">validate</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* 通用校验 */</span> &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logResult</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* 通用日志 */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="3-例外场景（谨慎使用）"><strong>3. 例外场景（谨慎使用）</strong></h3>
<p>极少数情况下，若符合以下条件，可考虑 <code>protected</code> 数据成员：</p>
<ul>
<li><strong>性能关键路径</strong>：直接访问数据可避免方法调用开销（需严格性能分析）。</li>
<li><strong>模板元编程</strong>：基类与派生类协同设计，数据访问为设计核心（如 CRTP 模式）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Derived&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CuriouslyReusedTemplate</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// 派生类需直接访问 baseData</span><br>    <span class="hljs-type">int</span> baseData;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDerived</span> : <span class="hljs-keyword">public</span> CuriouslyReusedTemplate&lt;MyDerived&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useBaseData</span><span class="hljs-params">()</span> </span>&#123;<br>        baseData = <span class="hljs-number">42</span>;  <span class="hljs-comment">// 直接访问，因协同设计需要</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="4-最佳实践总结"><strong>4. 最佳实践总结</strong></h3>
<table>
<thead>
<tr>
<th><strong>实践</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数据成员始终私有化</strong></td>
<td>默认所有数据成员为 <code>private</code>，严格封装实现细节</td>
</tr>
<tr>
<td><strong>通过方法暴露受控操作</strong></td>
<td>提供 <code>protected</code> 方法供派生类调用，确保数据有效性</td>
</tr>
<tr>
<td><strong>优先组合而非继承</strong></td>
<td>使用组合和策略模式替代继承，减少对基类数据的依赖</td>
</tr>
<tr>
<td><strong>文档化不变式</strong></td>
<td>在基类中通过注释明确数据约束，指导派生类正确使用接口</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="5-示例：安全的数据访问设计"><strong>5. 示例：安全的数据访问设计</strong></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sensor</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> currentValue;  <span class="hljs-comment">// 私有数据</span><br>    <span class="hljs-type">time_t</span> lastUpdateTime;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// 派生类通过受控方法更新数据</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateValue</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isValid</span>(value)) &#123;<br>            currentValue = value;<br>            lastUpdateTime = <span class="hljs-built_in">time</span>(<span class="hljs-literal">nullptr</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value &gt;= <span class="hljs-number">-100.0</span> &amp;&amp; value &lt;= <span class="hljs-number">100.0</span>;  <span class="hljs-comment">// 校验规则</span><br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> currentValue; &#125;<br>    <span class="hljs-function"><span class="hljs-type">time_t</span> <span class="hljs-title">getLastUpdateTime</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> lastUpdateTime; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TemperatureSensor</span> : <span class="hljs-keyword">public</span> Sensor &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">readHardware</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">double</span> rawValue = <span class="hljs-built_in">readFromDevice</span>();  <span class="hljs-comment">// 读取硬件</span><br>        <span class="hljs-built_in">updateValue</span>(rawValue);  <span class="hljs-comment">// 通过基类方法更新，确保合法</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<hr>
<p>通过严格封装数据成员，代码将更健壮、易维护，且能有效隔离变化，降低系统复杂度。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/C-%E7%AC%94%E8%AE%B0/" class="category-chain-item">C++笔记</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++程序设计语言笔记——抽象机制：派生类</div>
      <div>https://mounthuangshan.github.io/C-笔记/C++笔记/C++程序设计语言笔记——抽象机制：派生类/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>黄山</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年3月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/C-%E7%AC%94%E8%AE%B0/C++%E7%AC%94%E8%AE%B0/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%92%8C%E7%B1%BB%E5%B1%82%E6%AC%A1/" title="C++程序设计语言笔记——抽象机制：模板和类层次">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">C++程序设计语言笔记——抽象机制：模板和类层次</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/C-%E7%AC%94%E8%AE%B0/C++%E7%AC%94%E8%AE%B0/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6%EF%BC%9A%E7%89%B9%E4%BE%8B%E5%8C%96/" title="C++程序设计语言笔记——抽象机制：特例化">
                        <span class="hidden-mobile">C++程序设计语言笔记——抽象机制：特例化</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
