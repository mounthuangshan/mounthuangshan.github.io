

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="黄山">
  <meta name="keywords" content="C/C++,Python,C#,Go,Web,AI,游戏开发,网络安全">
  
    <meta name="description" content="0 拷贝和移动 默认情况下，我们可以拷贝对象，不论用户自定义类型的对象还是内置类型的对象都是如此。拷贝的默认含义是逐成员的复制，即依次复制每个成员。例如，使用complex： 123456void test(complex z1)&#123;     complex z2&#123;z1&#125;;&#x2F;&#x2F;拷贝初始化     complex z3;     z3&#x3D;z2;&#x2F;&#x2F;拷贝赋值&#125; 因为">
<meta property="og:type" content="article">
<meta property="og:title" content="C++程序设计语言笔记——引言：第三章 C++概览之抽象机制3">
<meta property="og:url" content="https://mounthuangshan.github.io/C-%E7%AC%94%E8%AE%B0/C++%E7%AC%94%E8%AE%B0/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BC%95%E8%A8%80%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%20C++%E6%A6%82%E8%A7%88%E4%B9%8B%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B63/">
<meta property="og:site_name" content="钺不言">
<meta property="og:description" content="0 拷贝和移动 默认情况下，我们可以拷贝对象，不论用户自定义类型的对象还是内置类型的对象都是如此。拷贝的默认含义是逐成员的复制，即依次复制每个成员。例如，使用complex： 123456void test(complex z1)&#123;     complex z2&#123;z1&#125;;&#x2F;&#x2F;拷贝初始化     complex z3;     z3&#x3D;z2;&#x2F;&#x2F;拷贝赋值&#125; 因为">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-03-18T18:19:05.000Z">
<meta property="article:modified_time" content="2025-03-18T18:19:05.849Z">
<meta property="article:author" content="黄山">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="Web">
<meta property="article:tag" content="AI">
<meta property="article:tag" content="游戏开发">
<meta property="article:tag" content="网络安全">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>C++程序设计语言笔记——引言：第三章 C++概览之抽象机制3 - 钺不言</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"mounthuangshan.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++程序设计语言笔记——引言：第三章 C++概览之抽象机制3"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-03-19 02:19" pubdate>
          2025年3月19日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          95 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">C++程序设计语言笔记——引言：第三章 C++概览之抽象机制3</h1>
            
            
              <div class="markdown-body">
                
                <h1>0 拷贝和移动</h1>
<p>默认情况下，我们可以拷贝对象，不论用户自定义类型的对象还是内置类型的对象都是如此。拷贝的默认含义是逐成员的复制，即依次复制每个成员。例如，使用complex：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">complex z1</span>)<br>&#123;<br>     complex z2&#123;z1&#125;;<span class="hljs-comment">//拷贝初始化</span><br>     complex z3;<br>     z3=z2;<span class="hljs-comment">//拷贝赋值</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>因为复制和初始化操作都复制了complex的全部两个成员，所以在上述操作之后，z1、z2、z3的值变得完全一样。<br>
当我们设计一个类时，必须仔细考虑对象是否会被拷贝以及如何拷贝的问题。对于简单的具体类型来说，逐成员的复制通常符合拷贝操作的本来语义。然而对于某些像Vector一样的复杂具体类型，逐成员的复制常常时不正确的；抽象类型更是如此。</p>
<h2 id="拷贝容器">拷贝容器</h2>
<p>当一个类作为资源句柄时，换句话说，当这个类负责通过指针访问一个对象时，采用默认的逐成员复制方式通常意味着错误。逐成员复制将违反资源句柄的不变式。例如，下面所示的默认拷贝将产生Vector的一份拷贝，而这个拷贝所指向的元素与原来的元素是同一个：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">bad_copy</span>(<span class="hljs-params">Vector v1</span>)<br>&#123;<br>     <span class="hljs-title class_">Vector</span> v2 = v1;<span class="hljs-comment">//把v1的表现形式复制给了v2</span><br>     v1[<span class="hljs-number">0</span>]=<span class="hljs-number">2</span>;<span class="hljs-comment">//v2[0]现在是2</span><br>     v2[<span class="hljs-number">1</span>]=<span class="hljs-number">3</span>;<span class="hljs-comment">//v1[1]现在是3</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>假设v1包含四个元素，则结果如下图所示：<br>
![在这里插入图片描述](./C++程序设计语言笔记——引言：第三章 C++概览之抽象机制3image\8ed9a945076e413f88b89bcb2537ee2d.png)<br>
幸运的是，Vector的析构函数可以发现默认成员逐成员复制的语义错误从而引发编译器针对上述示例的报警。这提醒我们应该为其定义更好的拷贝语义。<br>
类对象的拷贝操作可以通过两个成员来定义：拷贝构造函数与拷贝赋值运算符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span><br>&#123;<br><span class="hljs-attr">private</span>:<br>    double* elem;<span class="hljs-comment">//elem指向含有sz个double的数组</span><br>    int sz;<br><span class="hljs-attr">public</span>:<br>    <span class="hljs-title class_">Vector</span>(int s);<span class="hljs-comment">//构造函数：建立不等式，请求资源</span><br>    ~<span class="hljs-title class_">Vector</span>() &#123; <span class="hljs-keyword">delete</span>[]elem;&#125;<span class="hljs-comment">//析构函数：释放资源</span><br><br>    <span class="hljs-title class_">Vector</span>(<span class="hljs-keyword">const</span> <span class="hljs-title class_">Vector</span>&amp; a);<span class="hljs-comment">//拷贝构造函数</span><br>    <span class="hljs-title class_">Vector</span>&amp; operator=(<span class="hljs-keyword">const</span> <span class="hljs-title class_">Vector</span>&amp; a);<span class="hljs-comment">//拷贝赋值运算符</span><br><br>    double&amp; ioerator[](int i);<br>    <span class="hljs-keyword">const</span> double&amp; operator[](int i)<span class="hljs-keyword">const</span>;<br><br>    int <span class="hljs-title function_">size</span>() <span class="hljs-keyword">const</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于Vector来说，拷贝构造函数的正确定义应该首先为指定数量的元素分配空间，然后把元素复制到空间中。这样在复制完成后，每个Vector就拥有自己的元素副本了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Vector</span>::<span class="hljs-title class_">Vector</span>(<span class="hljs-keyword">const</span> <span class="hljs-title class_">Vector</span>&amp; a) :elem&#123; <span class="hljs-keyword">new</span> double[sz] &#125;, sz&#123; a.<span class="hljs-property">sz</span> &#125;<span class="hljs-comment">//复制构造函数</span><br>&#123;<br>    <span class="hljs-comment">//复制元素</span><br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i != sz; ++i)<br>    &#123;<br>        elem[i] = a.<span class="hljs-property">elem</span>[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样，v1 和 v2 将拥有各自独立的内存区域，修改一个不会影响另一个。<br>
在新的示例中v2=v1可以表示成：<br>
![在这里插入图片描述](./C++程序设计语言笔记——引言：第三章 C++概览之抽象机制3image\1ad63ab937d74159979ee608055d882f.png)<br>
当然，在拷贝构造函数之外我们还需要一个拷贝赋值运算符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Vector</span>&amp; <span class="hljs-title class_">Vector</span>::operator=(<span class="hljs-keyword">const</span> <span class="hljs-title class_">Vector</span>&amp; a)<span class="hljs-comment">//拷贝赋值运算符</span><br>&#123;<br>    double* p = <span class="hljs-keyword">new</span> double[a.<span class="hljs-property">sz</span>];<br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i != a.<span class="hljs-property">sz</span>; ++i)<br>    &#123;<br>        p[i] = a.<span class="hljs-property">elem</span>[i];<span class="hljs-comment">//删除旧元素</span><br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] elem;<span class="hljs-comment">//删除旧元素</span><br>    elem = p;<br>    sz = a.<span class="hljs-property">sz</span>;<br>    <span class="hljs-keyword">return</span>*<span class="hljs-variable language_">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中，名字this预定义在成员函数中，它指向调用该成员函数的那个对象。<br>
类X的拷贝构造函数和拷贝赋值运算符接受的实参类型通常是const X&amp;。<br>
这里需要理解两个概念，即浅拷贝和深拷贝：</p>
<ul>
<li>浅拷贝：创建一个新的对象，但其成员变量（特别是指针或引用类型）仅仅复制了引用或指针的值，而不是它们所指向的数据。这意味着新对象和原对象共享同一块内存数据。</li>
<li>深拷贝：创建一个新的对象，并递归地复制所有成员变量（包括指针或引用类型所指向的数据），使得新对象和原对象完全独立。<br>
假设 Vector 类是这样实现的（简化示例）：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span> &#123;<br><span class="hljs-attr">public</span>:<br>    int* data; <span class="hljs-comment">// 指向动态分配数组的指针</span><br>    int size;<br> <br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-title class_">Vector</span>(int s) : <span class="hljs-title function_">size</span>(<span class="hljs-params">s</span>) &#123;<br>        data = <span class="hljs-keyword">new</span> int[s];<br>    &#125;<br> <br>    <span class="hljs-comment">// 拷贝构造函数（浅拷贝）</span><br>    <span class="hljs-title class_">Vector</span>(<span class="hljs-keyword">const</span> <span class="hljs-title class_">Vector</span>&amp; other) : <span class="hljs-title function_">size</span>(<span class="hljs-params">other.size</span>) &#123;<br>        data = other.<span class="hljs-property">data</span>; <span class="hljs-comment">// 这里只复制了指针的值</span><br>    &#125;<br> <br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-title class_">Vector</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] data;<br>    &#125;<br> <br>    <span class="hljs-comment">// 索引操作符重载</span><br>    int&amp; operator[](int index) &#123;<br>        <span class="hljs-keyword">return</span> data[index];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，Vector 类的拷贝构造函数只是复制了 data 指针的值，而不是它所指向的数组。因此，当你执行 Vector v2 = v1; 时，v1 和 v2 的 data 成员都指向同一块内存区域。这就是为什么当你修改 v1[0] 或 v2[1] 时，两者看起来都受到了影响：它们实际上在修改同一块内存中的数据。<br>
要实现深拷贝，你需要在拷贝构造函数中分配新的内存，并复制数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Vector</span>(<span class="hljs-keyword">const</span> <span class="hljs-title class_">Vector</span>&amp; other) : <span class="hljs-title function_">size</span>(<span class="hljs-params">other.size</span>) &#123;<br>    data = <span class="hljs-keyword">new</span> int[size]; <span class="hljs-comment">// 分配新的内存</span><br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        data[i] = other.<span class="hljs-property">data</span>[i]; <span class="hljs-comment">// 复制数据</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="移动容器">移动容器</h2>
<p>我们能通过定义拷贝构造函数和拷贝赋值运算符来控制拷贝过程，但是对于大容量的容器来说拷贝过程有可能耗费巨大。以下面的代码为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Vector</span> operator+(<span class="hljs-keyword">const</span> <span class="hljs-title class_">Vector</span>&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-title class_">Vector</span>&amp; b)<br>&#123;<br>  <span class="hljs-keyword">if</span> (a.<span class="hljs-title function_">size</span>() != b.<span class="hljs-title function_">size</span>())<br>  &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Vector</span>_size_mismatch&#123;&#125;;<br>  &#125;<br>  <span class="hljs-title class_">Vector</span> <span class="hljs-title function_">res</span>(a.<span class="hljs-title function_">size</span>());<br>  <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i != a.<span class="hljs-title function_">size</span>(); ++i)<br>  &#123;<br>    res[i] = a[i] + b[i];<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>要想从+运算符返回结果，需要把局部变量res的内容拷贝到调用者可以访问的地方。我们可能这样使用+：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> Vector&amp; x, <span class="hljs-keyword">const</span> Vector&amp; y, <span class="hljs-keyword">const</span> Vector&amp; z</span>)<br>&#123;<br>  <span class="hljs-title class_">Vector</span> r;<br>  r = x + y + z;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这时就需要拷贝Vector对象至少两次（每个+一次）。如果Vector容量比较大的话，比方说含有10000个double，那么显然上述过程会让人头疼不已。最不合理的地方是operator+()中的res在拷贝后就不再使用了。事实上我们并不真的想要一个副本；我们只想把计算结果从函数中取出来：相对于拷贝（copy）一个Vector对象，我们更希望移动（move）它。幸运的是，C++为我们的想法提供了支持：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span><br>&#123;<br>  <span class="hljs-title class_">Vector</span>(<span class="hljs-keyword">const</span> <span class="hljs-title class_">Vector</span>&amp; a);<span class="hljs-comment">//拷贝构造函数</span><br>  <span class="hljs-title class_">Vector</span>&amp; operator=(<span class="hljs-keyword">const</span> <span class="hljs-title class_">Vector</span>&amp; a);<span class="hljs-comment">//拷贝赋值运算符</span><br><br>  <span class="hljs-title class_">Vector</span>(<span class="hljs-title class_">Vector</span>&amp;&amp; a);<span class="hljs-comment">//移动构造函数</span><br>  <span class="hljs-title class_">Vector</span>&amp; operator=(<span class="hljs-title class_">Vector</span>&amp;&amp; a);<span class="hljs-comment">//移动赋值运算符</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>基于上述定义，编译器将选择移动构造函数（move constructor）来执行从函数中移出返回值的任务。这意味着r=x+y+z不需要再拷贝Vector，只是移动它就足够了。<br>
定义Vector移动构造函数的过程非常简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Vector</span>::<span class="hljs-title class_">Vector</span>(<span class="hljs-title class_">Vector</span>&amp;&amp; a) :elem&#123; a.<span class="hljs-property">elem</span> &#125;, sz&#123; a.<span class="hljs-property">sz</span> &#125;<span class="hljs-comment">//从a中&quot;夺取元素&quot;</span><br>&#123;<br>  a.<span class="hljs-property">elem</span> = nullptr;<span class="hljs-comment">//现在已经没有元素了</span><br>  a.<span class="hljs-property">sz</span> = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>符号&amp;&amp;的意思是“右值引用”,我们可以给该引用绑定一个右值。“右值”的含义与“左值”正好相反,左值的大致含义是“能出现在赋值运算符左侧的内容”,因此右值大致上就是我们无法为其赋值的值,比如函数调用返回的一个整数。进一步,右值引用的含义就是引用了一个别人无法赋值的内容。Vector的operator+()运算符的局部变量res就是一个示例。<br>
移动构造函数不接受const实参:毕竟移动构造函数最终要删除掉它实参中的值。移动赋值运算符(move  assignment)的定义与之类似。<br>
当右值引用被用作初始化器或者赋值操作的右侧运算对象时,程序将使用移动操作。移动之后,源对象所进入的状态应该能允许运行析构函数。通常,我们也应该允许为一个移动操作后的源对象赋值。<br>
程序员可以知道一个值在什么地方不再被使用,但是编译器做不到这一点,因此程序员最好在程序中写得明确一些:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Vector</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)<br>&#123;<br>  <span class="hljs-title class_">Vector</span> <span class="hljs-title function_">x</span>(<span class="hljs-number">1000</span>);<br>  <span class="hljs-title class_">Vector</span> <span class="hljs-title function_">y</span>(<span class="hljs-number">1000</span>);<br>  <span class="hljs-title class_">Vector</span> <span class="hljs-title function_">z</span>(<span class="hljs-number">1000</span>);<br>  <span class="hljs-comment">//...</span><br>  z = x;<span class="hljs-comment">//执行拷贝操作</span><br>  y = <span class="hljs-attr">std</span>::<span class="hljs-title function_">move</span>(x);<span class="hljs-comment">//执行移动操作</span><br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-keyword">return</span> z;<span class="hljs-comment">//执行移动操作</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中，标准库函数move（）负责返回实参的右值引用。<br>
在return语句执行之前的状态是：<br>
![在这里插入图片描述](./C++程序设计语言笔记——引言：第三章 C++概览之抽象机制3image\e1e09761570e460582f27630b93c8fa8.png)<br>
当z被销毁时，事实上它也被return语句移走了，因此和x一样它也变为空（没有任何元素）。<br>
这里需要解释两个概念，左值引用和右值引用：</p>
<ul>
<li>左值引用<br>
左值（lvalue）是一个表示数据的表达式，通常指的是具有持久状态的对象或函数返回值，它们有确定的存储位置（即内存地址），并且可以在程序中持续存在，直到它们的作用域结束。左值可以出现在赋值语句的左边，也可以被取地址。左值引用（lvalue reference）是通过在变量类型后加上&amp;符号来定义的，它引用了一个左值。左值引用通常用于避免不必要的对象拷贝，提高程序效率。<br>
左值引用可以分为非常量左值引用和常量左值引用。非常量左值引用只能绑定到非常量左值上，而常量左值引用则可以绑定到非常量左值、常量左值、非常量右值以及常量右值上。</li>
<li>右值引用<br>
右值（rvalue）也是一个表示数据的表达式，但它通常指的是临时对象或字面量等不具有持久状态的值。右值不能出现在赋值语句的左边，也不能被取地址。在C++11及以后的版本中，引入了右值引用的概念，它允许程序员引用右值，从而实现了移动语义（move semantics）和完美转发（perfect forwarding）等高级特性。<br>
右值引用是通过在变量类型后加上&amp;&amp;符号来定义的，它引用了一个右值。右值引用的主要目的是为了实现资源的有效转移，避免不必要的拷贝操作，从而提高程序的性能。例如，在移动构造函数和移动赋值运算符中，右值引用允许将资源（如动态分配的内存）从一个对象转移到另一个对象，而不是进行深拷贝。<br>
需要注意的是，虽然常量左值引用可以引用右值，但右值引用本身不能引用左值（除非使用std::move函数将左值强制转换为右值）。std::move函数是一个标准库函数，它告诉编译器将左值视为右值进行处理，从而允许右值引用绑定到左值上。然而，被std::move转换后的左值将不再可用，因为它的资源已经被转移或即将被转移。</li>
</ul>
<h2 id="资源管理">资源管理</h2>
<p>通过定义构造函数、拷贝操作、移动操作和析构函数,程序员就能对受控资源(比如容器中的元素)的全生命周期进行管理。而且移动构造函数还允许对象从一个作用域简单便捷地移动到另一个作用域。采取这种方式,我们不能或不希望拷贝到作用域之外的对象就能简单高效地移动出去了。不妨以表示并发活动的标准库thread和含有百万个double  的Vector为例,前者“不能”执行拷贝操作,而后者我们“不希望”拷贝它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">std</span>::vector&lt;thread&gt;my_threads;<br><span class="hljs-title class_">Vector</span>  <span class="hljs-title function_">init</span>(<span class="hljs-params">int  n</span>)<br>&#123;<br>  thread  <span class="hljs-title function_">t</span>(heartbeat); <span class="hljs-comment">//同时运行heartbeat(在它自己的线程上)</span><br>  my_threads.<span class="hljs-title function_">push_back</span>(<span class="hljs-title function_">move</span>(t));<span class="hljs-comment">//把t移动到my_threads</span><br>  <span class="hljs-comment">//…其他初始化部分…</span><br>  <span class="hljs-title class_">Vector</span>  <span class="hljs-title function_">vec</span>(n);<br>  <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; vec.<span class="hljs-title function_">size</span>();++i)<br>  &#123;<br>    vec[i] = <span class="hljs-number">777</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span>  vec; <span class="hljs-comment">//把vec移动到init()之外	</span><br>&#125;<br>auto  v = <span class="hljs-title function_">init</span>();<span class="hljs-comment">//启动heartbeat, 初始化v</span><br></code></pre></td></tr></table></figure>
<p>在很多情况下,用Vector和thread这样的资源句柄比用指针效果要好。事实上,以unique_ptr为代表的“智能指针”本身就是资源句柄。我们使用标准库vector存放thread的原因是,在原书的3.4.1节之前我们还接触不到用一种元素类型参数化Vector的方法。<br>
就像替换掉程序中的new和delete一样,我们也可以把指针转化为资源句柄。在这两种情况下,都将得到更简单也更易维护的代码,而且没什么额外的开销。特别是我们能实现强资源安全(strong  resource  safety),换句话说,对于一般概念上的资源,这种方法都可以消除资源泄漏。比如存放内存的vector、存放系统线程的thread和存放文件句柄的fstream。</p>
<h2 id="抑制操作">抑制操作</h2>
<p>对于层次中的类来说,使用默认的拷贝或移动操作常常意味着风险:因为只给出一个基类的指针,我们无法了解派生类有什么样的成员,当然也就不知道该如何操作它们。因此,最好的做法是删除掉默认的拷贝和移动操作,也就是说,我们应该尽量避免使用这两个操作的默认定义:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span>  <span class="hljs-title class_">Shape</span><br>&#123;<br><span class="hljs-attr">public</span>:<br>  <span class="hljs-title class_">Shape</span>(<span class="hljs-keyword">const</span>  <span class="hljs-title class_">Shape</span>&amp;) = <span class="hljs-keyword">delete</span>;<span class="hljs-comment">// 没有技贝操作</span><br>  <span class="hljs-title class_">Shape</span>&amp; operator=(<span class="hljs-keyword">const</span>  <span class="hljs-title class_">Shape</span>&amp;) = <span class="hljs-keyword">delete</span>;<br><br>  <span class="hljs-title class_">Shape</span>(<span class="hljs-title class_">Shape</span>&amp;&amp;) = <span class="hljs-keyword">delete</span>;<span class="hljs-comment">//没有移动操作</span><br>  <span class="hljs-title class_">Shape</span>&amp; operator=(<span class="hljs-title class_">Shape</span>&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br>  ~<span class="hljs-title class_">Shape</span>();<br>  <span class="hljs-comment">//...</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>现在编译器将捕获拷贝  Shape的意图。如果你确实希望技贝类层次中的某个对象,可以编写一些克隆函数。<br>
在这个特殊的例子中,即使忘了delete拷贝和移动操作也没什么问题。如果使用者在类中显式地声明了析构函数,则移动操作将不会隐式地生成。而且在本例中拷贝操作的生成也被禁止了。这就是为什么即使编译器可以隐式地提供析构函数,也最好显式地自己定义一个析构函数的原因。<br>
在有些情况下我们不希望拷贝类的对象,类层次中的基类就是很好的例子。通常,我们无法通过拷贝成员的方式来拷贝资源句柄。<br>
这种=delete的机制是通用的,也就是说,我们可以用它抑制任何操作。</p>
<h1>1 模板</h1>
<p>显然，需要使用向量的人不一定总是使用 double 向量。向量是个通用的概念，不应局限于浮点数。因此，向量的元素类型应该独立表示。一个模板（template）就是一个类或一个函数，但需要我们用一组类型或值对其进行参数化。我们使用模板表示那些通用的概念，然后通过指定实参（比如指定元素的类型为 double）生成特定的类型或函数。</p>
<h2 id="参数化类型">参数化类型</h2>
<p>对于我们之前使用的double向量，只要将其改为template并且用一个形参替换掉特定类型double，就能将其泛化成任意类型的向量了。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">template&lt;typename T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span><br>&#123;<br><span class="hljs-attr">private</span>:<br>  T* elem;<span class="hljs-comment">//指向含有sz个T类型元素的数组</span><br>  int sz;<br><span class="hljs-attr">public</span>:<br>  <span class="hljs-title class_">Vector</span>(int s);<span class="hljs-comment">//构造函数：建立不变式，获取资源</span><br>  ~<span class="hljs-title class_">Vector</span>() &#123; <span class="hljs-keyword">delete</span>[]elem; &#125;<span class="hljs-comment">//析构函数：释放资源</span><br>  <span class="hljs-comment">//拷贝和移动操作</span><br>  T&amp; operator[](int i);<br>  <span class="hljs-keyword">const</span> T&amp; operator[](int i)<span class="hljs-keyword">const</span>;<br>  int <span class="hljs-title function_">size</span>()<span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> sz; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>前缀template<typename T>指明T是该声明的形参，它是数学上“对所有T”或“对所有类型T”的C++表达。<br>
成员函数的定义方式类似：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">template&lt;typename T&gt;<br><span class="hljs-title class_">Vector</span>&lt;T&gt;::<span class="hljs-title class_">Vector</span>(int s)<br>&#123;<br>  <span class="hljs-keyword">if</span> (s &lt; <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Negative</span>_size();<br>    elem = <span class="hljs-keyword">new</span> T[s];<br>    sz = s;<br>  &#125;<br>&#125;;<br><br>template&lt;typename T&gt;<br><span class="hljs-keyword">const</span> T&amp; <span class="hljs-title class_">Vector</span>&lt;T&gt;::operator[](int i)<span class="hljs-keyword">const</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || <span class="hljs-title function_">size</span>() &lt;= i)<br>  &#123;<br>    <span class="hljs-keyword">throw</span> out_of_range&#123; <span class="hljs-string">&quot;Vector::operator[]&quot;</span> &#125;;<br>  &#125;<br>  <span class="hljs-keyword">return</span> elem[i];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>基于上述定义，我们定义Vector的方式变为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Vector</span>&lt;char&gt;<span class="hljs-title function_">vc</span>(<span class="hljs-number">200</span>);<span class="hljs-comment">//含有200个字符的向量</span><br><span class="hljs-title class_">Vector</span>&lt;string&gt;<span class="hljs-title function_">vs</span>(<span class="hljs-number">17</span>);<span class="hljs-comment">//含有17个字符串的向量</span><br><span class="hljs-title class_">Vector</span>&lt;list&lt;int&gt;&gt;<span class="hljs-title function_">vli</span>(<span class="hljs-number">45</span>);<span class="hljs-comment">//含有45个整数列表的向量</span><br></code></pre></td></tr></table></figure>
<p>其中，最后一行Vector&lt;list<int>&gt;中的&gt;&gt;表示嵌套模板实参的结束，并不是输入运算符被放错了地方，不用非得像C++98那样在两个&gt;之间加个空格。<br>
我们使用Vector的方式是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span>(<span class="hljs-keyword">const</span> <span class="hljs-title class_">Vector</span>&lt;string&gt;&amp; vs)<span class="hljs-comment">//字符串的向量</span><br>&#123;<br>  <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i != vs.<span class="hljs-title function_">size</span>(); ++i)<br>  &#123;<br>    cout &lt;&lt; vs[i] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>为了让我们的Vector支持范围for循环，需要为之定义适当的begin()和end()函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">template&lt;typename T&gt;<br>T* <span class="hljs-title function_">begin</span>(<span class="hljs-params">Vector&lt;T&gt;&amp; x</span>)<br>&#123;<br>  <span class="hljs-keyword">return</span> &amp;x[<span class="hljs-number">0</span>];<span class="hljs-comment">//指针指向第一个元素</span><br>&#125;<br><br>template&lt;typename T&gt;<br>T* <span class="hljs-title function_">end</span>(<span class="hljs-params">Vector&lt;T&gt;&amp; x</span>)<br>&#123;<br>  <span class="hljs-keyword">return</span> x.<span class="hljs-title function_">begin</span>() + x.<span class="hljs-title function_">size</span>();<span class="hljs-comment">//指针指向末尾元素的下一个位置</span><br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>在此基础上，我们就能编写如下的代码了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">f2</span>(<span class="hljs-keyword">const</span> <span class="hljs-title class_">Vector</span>&lt;string&gt;&amp; vs)<span class="hljs-comment">//字符串组成的Vector</span><br>&#123;<br>  <span class="hljs-keyword">for</span> (auto&amp; s : vs)<br>  &#123;<br>    cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="函数模板">函数模板</h2>
<p>模板的用途当然远不止是用元素类型参数化容器，我们用模板能参数化标准库中的很多类型和算法。例如，下面这段程序可以计算任意容器中元素的和：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">template&lt;typename <span class="hljs-title class_">Container</span>,typename <span class="hljs-title class_">Value</span>&gt;<br><span class="hljs-title class_">Value</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> Container&amp; c, Value v</span>)<br>&#123;<br>  <span class="hljs-keyword">for</span> (auto x : c)<br>  &#123;<br>    v += x;<br>  &#125;<br>  <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>模板参数Value和函数参数v使得v使得调用者可以指定累加器（用于求和的变量）的类型和初始值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">user</span>(<span class="hljs-params">Vector&lt;int&gt;&amp; vi, std::list&lt;double&gt;&amp; ld, std::vector&lt;double&gt;</span>)<br>&#123;<br>  int x = <span class="hljs-title function_">sum</span>(vi, <span class="hljs-number">0</span>);<span class="hljs-comment">//求整数向量的和（累计整数）</span><br>  double d = <span class="hljs-title function_">sum</span>(vi, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//求整数向量的和（累计浮点数）</span><br>  double dd = <span class="hljs-title function_">sum</span>(ld, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//求浮点数列表的和</span><br>  auto z = <span class="hljs-title function_">sum</span>(vc, complex&lt;double&gt;&#123;&#125;);<span class="hljs-comment">//求complex&lt;double&gt;向量的和</span><br>  <span class="hljs-comment">//初始值是&#123;0.0,0.0&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>将一些int值累加到double变量中的做法让我们可以得体的处理超出int表示范围的数值。请注意sum&lt;T,V&gt;的模板实参类型是如何根据函数实参推断出来的。幸运的是，我们无须显式的指定这些类型。<br>
这里的sum()可以看做是标准库accumulate()的简化版本。</p>
<h2 id="函数对象">函数对象</h2>
<p>模板的一个特殊用途是函数对象，有时也称为函子，我们可以像调用函数一样使用函数对象。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">template&lt;typename T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Less_than</span><br>&#123;<br>  <span class="hljs-keyword">const</span> T val;<span class="hljs-comment">//待比较的值</span><br><span class="hljs-attr">public</span>:<br>  <span class="hljs-title class_">Less</span>_than(<span class="hljs-keyword">const</span> T&amp; v) :<span class="hljs-title function_">val</span>(<span class="hljs-params">v</span>) &#123;&#125;<br>  bool <span class="hljs-title function_">operator</span>()(<span class="hljs-keyword">const</span> T&amp; x)<span class="hljs-keyword">const</span> <span class="hljs-comment">//调用运算符</span><br>  &#123; <br>      <span class="hljs-keyword">return</span> x &lt; val; <br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>其中，名为operator()的函数实现了“函数调用”“调用”或“应用”运算符（）。<br>
我们能为某些实参类型定义Less_than类型的命名变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Less</span>_than&lt;int&gt;lti&#123;<span class="hljs-number">42</span>&#125;;<span class="hljs-comment">//lti将使用&lt;比较i和42（i&lt;42）</span><br><span class="hljs-title class_">Less</span>_than&lt;string&gt;lts&#123;<span class="hljs-string">&quot;Backus&quot;</span>&#125;;<span class="hljs-comment">//lts将使用&lt;比较s和“Buckus”（s&lt;&quot;Backus&quot;）</span><br></code></pre></td></tr></table></figure>
<p>接下来，我们就能像调用函数一样调用该对象了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">fct</span>(<span class="hljs-params">int n,<span class="hljs-keyword">const</span> string&amp; s</span>)<br>&#123;<br>    bool b1=<span class="hljs-title function_">lti</span>(n);<span class="hljs-comment">//如果n&lt;42则为真</span><br>    bool b2=<span class="hljs-title function_">lts</span>(s);<span class="hljs-comment">//如果s&lt;&quot;Backus&quot;则为真</span><br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样的函数对象经常作为算法的实参出现。例如，我们可以像下面这样统计令断言返回true的值的个数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">template&lt;typename C,typename P&gt;<br>int <span class="hljs-title function_">count</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> C&amp; c, P pred</span>)<br>&#123;<br>  int cnt = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> auto&amp; x : c)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">pred</span>(x))<br>    &#123;<br>      ++cnt;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>一个谓词的返回值或者是true，或者是false。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> Vector&lt;int&gt;&amp; vec, <span class="hljs-keyword">const</span> list&lt;string&gt;&amp; lst, int x, <span class="hljs-keyword">const</span> string&amp; s</span>)<br>&#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;number of values less than &quot;</span> &lt;&lt; x <br>    &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt; <span class="hljs-title function_">count</span>(vec, <span class="hljs-title class_">Less</span>_than&lt;int&gt;&#123;x&#125;)<br>    &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>  cout &lt;&lt; <span class="hljs-string">&quot;number of values less than&quot;</span> &lt;&lt; s <br>    &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt; <span class="hljs-title function_">count</span>(lst, <span class="hljs-title class_">Less</span>_than&lt;string&gt;(s)) <br>    &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里的[&amp;]（int a）{return a&lt;x；}被称为 lambda 表达式（lambda expression），它生成一个函数对象，就像 Less_than<int>{x}一样。[&amp;]是一个捕获获列表（capture list），它指明所用的局部名字（如 x）将通过引用访问。如果我们希望只&quot;捕获&quot;x，则可以写成[&amp;x]；如果希望给生成的函数对象传递一个 x 的拷贝，则写成[=x]。什么也不捕获是[]，捕获所有通过引用访问的局部名字是[&amp;]，捕获所有以值访问的局部名字是[=]。<br>
使用 lambda 虽然简单便捷，但也有可能稍显晦涩难懂。对于身复杂的操作（不是简单的一条表达式），我们更愿意给该操作起个名字，以便更加清晰地表述它的目的并且在程序中随处使用它。<br>
在原书3.2.4节中我们不得不编写很多像 draw_all（）和 rotate_al1（）这样的函数来执行针对指针 vector 或 unique_ptrvector 中元素的操作。函数对象（尤其是 lambda）能在一定程度上解决这一问题，其核心思想是把容器的遍历和对每个元素的具体操作分离开来。<br>
首先，我们需要定义一个函数，它负责把某个操作应用于指针容器的元素所指的每个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">template&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">Oper</span>&gt;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">for_all</span>(C&amp; c, <span class="hljs-title class_">Oper</span> op)<span class="hljs-comment">//假定C是一个指针容器</span><br>&#123;<br>  <span class="hljs-keyword">for</span> (auto&amp; x : c)<br>  &#123;<br>    <span class="hljs-title function_">op</span>(*x);<span class="hljs-comment">//传给op()每个元素所指对象的引用</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接下来，我们改写3.2.4节中的user(),而无需编写一大堆_all()函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-title function_">user</span>(<span class="hljs-params"></span>)<br>&#123;<br>  vector&lt;unique_ptr&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Shape</span> &gt;</span>&gt; v;</span><br><span class="language-xml">  while (cin)</span><br><span class="language-xml">  &#123;</span><br><span class="language-xml">    v.push_back(read_shape(cin));</span><br><span class="language-xml">  &#125;</span><br><span class="language-xml">  for_all(v.[](Shape&amp; s) &#123;s.draw(); &#125;);//fraw_all()</span><br><span class="language-xml">  for_all(v.[](Shape&amp; s) &#123;s.rotate(45); &#125;);//roate_all(45)</span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure>
<p>我给lambda传入Shape的引用，这样lambda就无需考虑容器中对象的存储方式了。特别是，即使把v改成一个vector&lt;Shape*&gt;，那些for_all()调用也仍然能够正常工作。<br>
<strong>这里需要解释一下函数式编程：</strong><br>
在C++中，lambda表达式提供了一种定义匿名函数对象的方式。这些函数对象可以捕获其所在作用域中的变量（通过值捕获或引用捕获），并且可以作为参数传递给其他函数，或者存储在变量中以供后续使用。C++11标准引入了lambda表达式，使得C++在函数式编程方面有了更强的能力。<br>
C++中的lambda表达式遵循以下基本语法结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[capture](parameters) <span class="hljs-keyword">mutable</span> -&gt; return_type &#123;<br>    function_body<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>capture</strong>：捕获列表，指定lambda表达式体内部可以访问的外部变量。按值捕获（使用<code>=</code>或变量名）意味着外部变量的副本将在lambda表达式内部可用；按引用捕获（使用<code>&amp;</code>或<code>&amp;变量名</code>）意味着lambda表达式内部将使用外部变量的引用。如果不需要捕获任何变量，可以使用空捕获列表<code>[]</code>。</p>
</li>
<li>
<p><strong>parameters</strong>：参数列表，与普通函数的参数列表类似。如果lambda表达式不接受任何参数，则可以省略参数列表，但圆括号<code>()</code>必须保留。</p>
</li>
<li>
<p><strong>mutable</strong>：可选的关键字，如果指定，则允许在lambda表达式体内修改按值捕获的变量。</p>
</li>
<li>
<p><strong>return_type</strong>：返回类型，对于可推导返回类型的lambda表达式，可以省略此部分（C++11及更高版本支持返回类型推导）。</p>
</li>
<li>
<p><strong>function_body</strong>：函数体，包含lambda表达式的实现代码。如果函数体只包含一个返回语句，并且没有复杂的控制流（如循环或条件语句），则可以使用基于表达式的lambda简化语法。</p>
</li>
</ul>
<p><strong>注意事项:</strong></p>
<ul>
<li>lambda表达式在C++中是通过编译器生成的函数对象（通常是<code>std::function</code>的某种特化或类似的内部类型）来实现的。</li>
<li>捕获列表中的变量是按照值捕获还是引用捕获会影响lambda表达式的生命周期和捕获变量的有效性。</li>
<li>使用<code>mutable</code>关键字时，需要小心避免意外修改捕获的变量，因为这可能会导致未定义的行为（特别是当捕获的变量在lambda表达式外部也被修改时）。</li>
<li>对于返回类型推导，编译器会尝试根据lambda表达式的函数体来确定返回类型。如果函数体包含多个返回语句，并且这些语句的返回类型不同，则编译器将报错，因为无法推导出一个统一的返回类型。</li>
</ul>
<p>这里作者还想扩展一下关于编程范式的问题：</p>
<blockquote>
<p>结构化编程<br>
结构化编程，也称作过程式编程，或面向过程编程。<br>
迪克斯特拉（E.W.dijkstra）在 1969 年提出结构化编程，摒弃了 goto 语句，而以模块化设计为中心，将待开发的软件系统划分为若干个相互独立的模块，这样使完成每一个模块的工作变得单纯而明确，为设计一些较大的软件打下了良好的基础。按照结构化编程的观点，任何算法功能都可以通过三种基本程序结构（顺序、选择和循环）的组合来实现。<br>
结构化编程主要表现在以下三个方面：<br>
1.<strong>自顶向下，逐步求精</strong>。将编写程序看成是一个逐步演化的过程，将分析问题的过程划分成若干个层次，每一个新的层次都是上一个层次的细化。<br>
2.<strong>模块化</strong>。将系统分解成若干个模块，每个模块实现特定的功能，最终的系统由这些模块组装而成，模块之间通过接口传递信息。<br>
3.<strong>语句结构化</strong>。在每个模块中只允许出现顺序、选择和循环三种流程结构的语句。<br>
结构化程序设计是用计算机的思维方式去处理问题，将数据结构和算法分离（程序 = 数据结构 + 算法）。数据结构描述待处理数据的组织形式，而算法描述具体的操作过程。我们用过程函数把这些算法一步一步的实现，使用的时候一个一个的依次调用就可以了。在三种主流的编程范式中，结构化编程离图灵机模型最近。人们学习编程的时候，大多数都是从结构化编程开始。按照结构化编程在做设计时，也是按照指令和状态（数据）两个纬度来考虑。在指令方面，先分解过程 Procedure，然后通过 Procedure 之间的一系列关系来构建整个计算，对应算法（流程图）设计。在状态方面，将实例数据都以全局变量的形式放在模块的静态数据区，对应数据结构设计。<br>
结构化编程一般偏底层，一般适用于追求确定性和性能的系统软件。这类软件偏静态规划，需求变化也不频繁，适合多人并行协作开发。将软件先分完层和模块，然后再确定模块间的 API，接着各组就可以同时启动开发。各组进行数据结构设计和算法流程设计，并在规定的时间内进行集成交付。分层模块化架构支撑了软件的大规模并行开发，且偏静态规划式开发交付。层与层之间限定了依赖方向，即层只能向下依赖，但同层内模块之间的依赖却无法约束，经常会出现模块之间互相依赖的情况，导致可裁剪性和可复用性过粗，响应变化能力较弱。<br>
<strong>结构化编程的优点：</strong><br>
1.贴近图灵机模型，可以充分调动硬件，控制性强。从硬件到 OS，都是从图灵机模型层累上来的。结构化编程离硬图灵机模型比较近，可以充分挖掘底下的能力，尽量变得可控。<br>
2.流程清晰。从 main 函数看代码，可以一路看下去，直到结束。<br>
<strong>结构化编程的缺点：</strong><br>
1.数据的全局访问性带来较高的耦合复杂度，局部可复用性及响应变化能力差，模块可测试性差。想单独复用一个 Procedure 比较困难，需要将该过程函数相关的全局数据及与全局数据相关的其他过程函数（生命周期关联）及其他数据（指针变量关联）一起拎出来复用，但这个过程是隐式的，必须追着代码一点点看才能做到。同理，想要单独修改一个 Procedure 也比较困难，经常需要将关联的所有 Procedure 进行同步修改才能做到，即散弹式修改。还有一点，就是模块之间可能有数据耦合，打桩复杂度高，很难单独测试。<br>
2.随着软件规模的不断膨胀，结构化编程组织程序的方式显得比较僵硬。结构化编程贴近图灵机模型，恰恰说明结构化编程抽象能力差，离领域问题的距离比较远，在代码中找不到领域概念的直接映射，难以组织管理大规模软件。</p>
</blockquote>
<blockquote>
<p>面向对象编程<br>
随着软件种类的不断增多，软件规模的不断膨胀，人们希望可以更小粒度的对软件进行复用和裁剪。<br>
<strong>基本设计</strong><br>
将全局数据拆开，并将数据与其紧密耦合的方法放在一个逻辑边界内，这个逻辑边界就是对象。用户只能访问对象的 public 方法，而看不到对象内部的数据。对象将数据和方法天然的封装在一个逻辑边界内，可以整体直接复用而不用做任何裁剪或隐式关联。<br>
人们将领域问题又开始映射成实体及关系（程序 = 实体 + 关系），而不再是数据结构和算法（过程）了，这就是面向对象编程，核心特点是封装、继承和多态。<br>
封装是面向对象的根基，它将紧密相关的信息放在一起，形成一个逻辑单元。我们要隐藏数据，基于行为进行封装，最小化接口，不要暴露实现细节。<br>
继承分为两种，即实现继承和接口继承。实现继承是站在子类的视角看问题，而接口继承是站在父类的视角看问题。很多程序员把实现继承当作一种代码复用的方式，但这并不是一种好的代码复用方式，推荐使用组合。<br>
对于面向对象而言，多态至关重要，接口继承是常见的一种多态的实现方式。正因为多态的存在，软件设计才有了更大的弹性，能够更好地适应未来的变化。只使用封装和继承的编程方式，我们称之为基于对象编程，而只有把多态加进来，才能称之为面向对象编程。可以这么说，面向对象设计的核心就是多态的设计。<br>
<strong>面向对象编程的优点：</strong><br>
1.对象自封装数据和行为，利于理解和复用。<br>
2.对象作为“稳定的设计质料”，适合广域使用。<br>
3.多态提高了响应变化的能力，进一步提升了软件规模。<br>
4.对设计的理解和演进优先是对模型和结构的理解和调整。不要一上来就看代码，面向对象的代码看着看着很容易断，比如遇到虚接口，就跟不下去了。通常是先掌握模型和结构，然后在结构中打开某个点的代码进行查看和修改。请记住，先模型，再接口，后实现。<br>
<strong>面向对象编程的缺点：</strong><br>
1.业务逻辑碎片化，散落在离散的对象内。类的设计遵循单一职责原则，为了完成一个业务流程，需要在多个类中跳来跳去。<br>
2.行为和数据的不匹配协调，即所谓的贫血模型和充血模型之争。后来发现可通过 DCI（Data、Context 和 Interactive）架构来解决该问题。<br>
3.面向对象建模依赖工程经验，缺乏严格的理论支撑。面向对象建模回答了从领域问题如何映射到对象模型，但一般只是讲 OOA 和 OOD 的典型案例或最佳实践，属于归纳法范畴，并没有严格的数学推导和证明。</p>
</blockquote>
<blockquote>
<p>函数式编程<br>
与结构化编程与面向对象编程不同，函数式编程对很多人来说要陌生一些。你可能知道，C++ 和 Java 已经引入了 Lambda 表达式，目的就是为了支持函数式编程。函数式编程中的函数不是结构化编程中的函数，而是数学中的函数，结构化编程中的函数是一个过程（Procedure）。<br>
<strong>基本设计</strong><br>
函数式编程的起源是数学家 Alonzo Church 发明的 Lambda 演算（Lambda calculus，也写作 λ-calculus）。所以，Lambda 这个词在函数式编程中经常出现，你可以把它简单地理解成匿名函数。函数式编程有很多特点：<br>
1.函数是一等公民。一等公民的含义：<br>
（1）它可以按需创建；<br>
（2）它可以存储在数据结构中；<br>
（3）它可以当作参数传给另一个函数；<br>
（4）它可以当作另一个函数的返回值。<br>
2.纯函数。所谓纯函数，是符合下面两点的函数：<br>
（1）对于相同的输入，返回相同的输出；<br>
（2）没有副作用。<br>
3.惰性求值。惰性求值是一种求值策略，它将求值的过程延迟到真正需要这个值的时候。<br>
4.不可变数据。函数式编程的不变性主要体现在值和纯函数上。值类似于 DDD 中的值对象，一旦创建，就不能修改，除非重新创建。值保证不会显式修改一个数据，纯函数保证不会隐式修改一个数据。当你深入学习函数式编程时，会遇到无副作用、无状态和引用透明等说法，其实都是在讨论不变性。<br>
5,递归。函数式编程用递归作为流程控制的机制，一般为尾递归。函数式编程还有两个重要概念：高阶函数和闭包。所谓高阶函数，是指一种比较特殊的函数，它们可以接收函数作为输入，或者返回一个函数作为输出。<br>
闭包是由函数及其相关的引用环境组合而成的实体，即闭包 = 函数 + 引用环境。闭包有独立生命周期，能捕获上下文（环境）。站在面向对象编程的角度，闭包就是只有一个接口（方法）的对象，即将单一职责原则做到了极致。可见，闭包的设计粒度更小，创建成本更低，很容易做组合式设计。在面向对象编程中，设计粒度是一个 Object，它可能还需要拆，但你可能已经没有意识再去拆，那么上帝类大对象就会存在了，创建成本高。在函数式编程中，闭包给你一个更精细化设计的能力，一次就可以设计出单一接口的有独立生命周期的可以捕获上下文的原子对象，天然就是易于组合易于重用的，并且是易于应对变化的。<br>
有一句话说的很好：闭包是穷人的对象，对象是穷人的闭包。有的语言没有闭包，你没有办法，只能拿对象去模拟闭包。又有一些语言没有对象，但单一接口不能完整表达一个业务概念，你没有办法，只能将多个闭包组合在一起当作对象用。<br>
对于函数式编程，数据是不可变的，所以一般只能通过模式匹配和递归来完成图灵计算。当程序员选择将函数式编程作为思维底座时，就需要解决如何将领域问题映射到数据和函数（程序 = 数据 + 函数）。函数式设计的思路就是高阶函数与组合，背后是抽象代数那一套逻辑。下面这张图是关于高阶函数的，左边是将函数作为输入，右边是将函数作为输出：<br>
![在这里插入图片描述](./C++程序设计语言笔记——引言：第三章 C++概览之抽象机制3image\744c5fad2ae04f42b5abf1dbb35b6542.png)<br>
对于将函数作为输入的高阶函数，就是面向对象的策略模式。对于将函数作为输出的高阶函数，就是面向对象的工厂模式。每个高阶函数都是职责单一的，所以函数式设计是以原子的方式通过策略模式和工厂模式来组合类似面向对象的一切。在这个过程中，到底哪些函数作为入参，哪些函数作为返回值，然后这些返回值函数再传给哪些函数，接着再返回哪些函数…，你发现你在套公式，通过公式的层层嵌套完成一个算法的描述，所以核心就是设计有哪些高阶函数以及它们的组合规则，这是函数式设计中最难的，就是抽象代数的部分。可见，函数式设计的基本方法为：借助闭包的单一接口的标准化和高阶函数的可组合性，通过规则串联设计，完成数据从源到结果的映射描述。这里的映射是通过多个高阶函数的形式化组合完成，描述就像写数学公式一样放在那，等源数据从一头传入，然后经过层层函数公式的处理，最后变成你想要的结果。数据在形式化转移的过程中，不仅仅包括数据本身，还包括规则的创建、返回和传递。<br>
<strong>函数式编程的优点：</strong><br>
1.高度的抽象，易于扩展。函数式编程是数据化表达，非常抽象，在表达范围内是易于扩展的。<br>
2.声明式表达，易于理解。<br>
3.形式化验证，易于自证。<br>
4.不可变状态，易于并发。数据不可变不是并发的必要条件，不共享数据才是，但不可变使得并发更加容易。<br>
<strong>函数式编程的缺点：</strong><br>
1.对问题域的代数化建模门槛高，适用域受限。现实是复杂的，不是在每个方面都是自洽的，要找到一套完整的规则映射是非常困难的。在一些狭窄的领域，可能找得到，而一旦扩展一下，就会破坏该狭窄领域，你发现以前找到的抽象代数建模方式就不再适用了。<br>
2.在图灵机上性能较差。函数式编程增加了很多中间层，它的规则描述和惰性求值等使得优化变得困难。<br>
3.不可变的约束造成了数据泥团耦合。领域对象是有状态的，这些状态只能通过函数来传递，导致很多函数有相同的入参和返回值。<br>
4.闭包接口粒度过细，往往需要再组合才能构成业务概念。<br>
参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/354528902">https://zhuanlan.zhihu.com/p/354528902</a></p>
</blockquote>
<blockquote>
<p>总结<br>
如果把实现功能比作填充下面的表格的话：<br>
![在这里插入图片描述](./C++程序设计语言笔记——引言：第三章 C++概览之抽象机制3image\9e84c70c5f0f4d6da1cca16a556fdcaa.png)<br>
函数式编程相当于按列填充这张表格，实现一个函数相当于把所有数据变种(variant)的同一操作都实现了<br>
面向对象式编程相当于按行填充，实现一个对象相当于把一个数据变种的所有不同操作都实现了。<br>
我们很难凭空地比较这两种不同编程范式地好坏，它们都是解决问题不同的正确的方式。就具体问题来说：如果我们有很多数据变种，少量的操作，函数式编程可能比较好些；反之则面相对象编程比较好些。<br>
在程序面对扩展时，函数式编程允许我们在不改变现有代码的情况下（自然地）添加新的操作；面向对象编程则允许我们（自然地）添加新的数据变种。<br>
参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/111314360">https://zhuanlan.zhihu.com/p/111314360</a></p>
</blockquote>
<h2 id="可变参数模板">可变参数模板</h2>
<p>定义模板时可以令其接受任意数量任意类型的实参，这样的模板称为可变参数模板。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">template&lt;typename T,typename... <span class="hljs-title class_">Tail</span>&gt;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">T head, Tail... tail</span>)<br>&#123;<br>  <span class="hljs-title function_">g</span>(head);<span class="hljs-comment">//对head做某些操作</span><br>  <span class="hljs-title function_">f</span>(tail..)<span class="hljs-comment">//再次处理tail</span><br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-comment">//不执行任何操作</span><br></code></pre></td></tr></table></figure>
<p>实现可变参数模板的关键是：当你传给它多个参数时，谨记把第一个参数和其他参数区分对待。此处，我们首先处理第一个参数（head），然后使用剩余参数（tail）递归地调用 f（）。省略号…表示列表的&quot;剩余部分&quot;。最终，tail 将变为空，我们需要另外一个独立的函数来处理它。<br>
调用 f（）的形式如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">int <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)<br>&#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;first:&quot;</span>;<br>  <span class="hljs-title function_">f</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2.2</span>, <span class="hljs-string">&quot;hello&quot;</span>);<br>  cout &lt;&lt; <span class="hljs-string">&quot;\nsecond:&quot;</span>;<br>  <span class="hljs-title function_">f</span>(<span class="hljs-number">0.2</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&quot;yuck!&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>  cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面的程序首先调用 f（1，2。2，“hello”），然后调用 f（2。2，“hello”），接着调用 f（“hello”），最终会调用 f（）。g（head）又会做什么呢？显然，在一个真实的程序中，1 将完成我们希望对每个实参执行的操作。例如，我们想要输出实参（这里是 head）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javscript">template&lt;typename T&gt;<br>void g(T x)<br>&#123;<br>  cout &lt;&lt; x &lt;&lt; &quot;&quot;;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>则其输出的内容是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">first</span>:<span class="hljs-number">1</span> <span class="hljs-number">2.2</span> hello<br><span class="hljs-attr">second</span>:<span class="hljs-number">0.2</span> c yuck! <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<p>从效果上看，f（）类似于 printf（）的简单变形，仅用 3 行代码及相应的声明就实现了打印任意列表和值的功能。<br>
可变参数模板有时也简称为可变参数（variadic），它的优势是可以接受我们希望传递给它的任意实参，而缺点则是接口的类型检查会比较复杂。</p>
<h2 id="别名">别名</h2>
<p>在很多情况下，我们应该为类型或模板引入一个同义词（见 6。5 节）。例如，标准库头文件<cstddef>：包含别名 size t 的定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">using</span> size_t=unsigned int；<br></code></pre></td></tr></table></figure>
<p>其中 size t 的实际类型依赖于具体实现，在另外一个实现中 size t 可能变成 unsigned long。使用 size_t，程序员就能写出易于移植的代码。<br>
参数化的类型经常为与其模板实参关联的类型提供别名，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">template&lt;typename T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span> &#123;<br>public：<br>     <span class="hljs-keyword">using</span> value_type T；<br>     <span class="hljs-comment">//…</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>事实上，每个标准库容器都提供了 value_type 作为其值类型的名字（见 31。3。1 节），这样我们编写的代码就能在任何一个服从这种规范的容器上工作了。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">template&lt;typename C&gt;<br><span class="hljs-keyword">using</span> <span class="hljs-title class_">Element</span>_type = typename <span class="hljs-attr">C</span>::value_tyoe;<br><br>template&lt;typename <span class="hljs-title class_">Container</span>&gt;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">algo</span>(<span class="hljs-params">Container&amp; c</span>)<br>&#123;<br>  <span class="hljs-title class_">Vector</span>&lt;<span class="hljs-title class_">Element</span>_tyoe&lt;<span class="hljs-title class_">Container</span>&gt;&gt;vec;<span class="hljs-comment">//保存结果</span><br>  <span class="hljs-comment">//...使用vec...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过绑定某些或全部模板实参，我们就能使用别名机制定义新的模板。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">template&lt;typename <span class="hljs-title class_">Key</span>,typename <span class="hljs-title class_">Value</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Map</span><br>&#123;<br>  <span class="hljs-comment">//..</span><br>&#125;;<br><br>template&lt;typename <span class="hljs-title class_">Value</span>&gt;<br><span class="hljs-keyword">using</span> <span class="hljs-title class_">String</span>_map = <span class="hljs-title class_">Map</span>&lt;string, <span class="hljs-title class_">Value</span>&gt;;<br><br><span class="hljs-title class_">String</span>_map&lt;int&gt;m;<span class="hljs-comment">//m是一个Map&lt;string,int&gt;</span><br></code></pre></td></tr></table></figure>
<h1>2 建议</h1>
<ul>
<li>直接用代码表达你的想法。</li>
<li>在代码中直接定义类来表示应用中的概念。</li>
<li>用具体类表示那些简单的概念或性能关键的组件。</li>
<li>避免“裸的” new 和 delete 操作。</li>
<li>用资源句柄和 RAII 管理资源。</li>
<li>当接口和实现需要完全分离时使用抽象类作为接口。</li>
<li>用类层次表示具有固有的层次关系的概念。</li>
<li>在设计类层次时，注意区分实现继承和接口继承。</li>
<li>控制好对象的构造、拷贝、移动和析构操作。</li>
<li>以值的方式返回容器（依赖于移动操作以提高效率）。</li>
<li>注意强资源安全，也就是说，不要泄漏任何你认为是资源的东西。</li>
<li>使用容器保存同类型值的集合，将其定义为资源管理模板。</li>
<li>使用函数模板表示通用的算法。</li>
<li>使用包括 lambda 表达式在内的函数对象表示策略和动作。</li>
<li>使用类型别名和模板别名为相似类型或可能在实现中变化的类型提供统一的符号表示法。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/C-%E7%AC%94%E8%AE%B0/" class="category-chain-item">C++笔记</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++程序设计语言笔记——引言：第三章 C++概览之抽象机制3</div>
      <div>https://mounthuangshan.github.io/C-笔记/C++笔记/C++程序设计语言笔记——引言：第三章 C++概览之抽象机制3/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>黄山</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年3月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/C-%E7%AC%94%E8%AE%B0/C++%E7%AC%94%E8%AE%B0/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BC%95%E8%A8%80%EF%BC%9A%E7%AC%AC%E4%B8%89%E7%AB%A0%20C++%E6%A6%82%E8%A7%88%E4%B9%8B%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B62/" title="C++程序设计语言笔记——引言：第三章 C++概览之抽象机制2">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">C++程序设计语言笔记——引言：第三章 C++概览之抽象机制2</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/C-%E7%AC%94%E8%AE%B0/C++%E7%AC%94%E8%AE%B0/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BC%95%E8%A8%80%EF%BC%9A%E7%AC%AC%E4%BA%8C%E7%AB%A0%20C++%E6%A6%82%E8%BF%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="C++程序设计语言笔记——引言：第二章 C++概述之基础知识">
                        <span class="hidden-mobile">C++程序设计语言笔记——引言：第二章 C++概述之基础知识</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
